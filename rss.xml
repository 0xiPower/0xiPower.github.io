<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>☯️xPower</title><description>Life is a fxxking movie.</description><link>https://newpower.pro/</link><language>zh_CN</language><item><title>随笔2025-05-08</title><link>https://newpower.pro/posts/notebook/2025-05-08/</link><guid isPermaLink="true">https://newpower.pro/posts/notebook/2025-05-08/</guid><pubDate>Thu, 08 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;🎁【开箱惊喜】HackQuest x Arbitrum共学营结营礼物大公开&lt;/h2&gt;
&lt;p&gt;激动的心，颤抖的手，终于收到了HackQuest和Arbitrum共学营的结营礼物！🎉&lt;br /&gt;
开箱的瞬间，满满的惊喜和感动，每一件小物都充满了心意和创意。🎨&lt;br /&gt;
👜 帆布袋：简约而不简单，上面的图案超级可爱，日常出门必备单品！&lt;br /&gt;
🔑 钥匙扣：设计感十足，细节满满，每次拿出钥匙都能想起这段难忘的学习旅程。&lt;br /&gt;
📚 笔记本：记录学习的点滴，每一页都是成长的见证。&lt;br /&gt;
🎖️ 徽章：每一枚都是对努力的肯定，也是对未来的期许。&lt;br /&gt;
这份礼物不仅是对过去努力的肯定，更是对未来的鼓励。感谢HackQuest和Arbitrum，让我在学习的道路上不断前行！🚀&lt;br /&gt;
Let&apos;s Quack!!!!!!!!!!!!!!!!!!!!!!!!!!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://asset-repository.vercel.app/blog/library/H00001.jpg&quot; alt=&quot;alt text&quot; /&gt;
&lt;img src=&quot;https://asset-repository.vercel.app/blog/library/H00002.jpg&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>Arbitrum Stylus 简要说明与使用教程</title><link>https://newpower.pro/posts/blockchain/arbitrum/arbitrumstylustutorial/</link><guid isPermaLink="true">https://newpower.pro/posts/blockchain/arbitrum/arbitrumstylustutorial/</guid><pubDate>Thu, 08 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Arbitrum Stylus 是 Arbitrum 网络中的一项新型功能，旨在为智能合约开发者提供更灵活、更高性能的工具。它打破了传统 EVM 框架中只能使用 Solidity 的限制，使得开发者可以借助多种编程语言（如 C、C++、Rust 等）在 Arbitrum 上编写合约，从而提升可扩展性与开发效率。根据官方文档和不同社区的测试，Stylus 在性能和资源利用率方面具有一定优势，引起了广泛关注。本文将结合官方资料和社区经验，为读者提供一份简要的使用指南。&lt;/p&gt;
&lt;h2&gt;一、背景与原理&lt;/h2&gt;
&lt;h3&gt;1.1 传统 EVM 的局限&lt;/h3&gt;
&lt;p&gt;以太坊虚拟机（EVM）为智能合约生态提供了基础支撑，但其在性能与多语言支持上存在局限。这些局限使得编写与部署高性能合约的过程较为艰难，尤其在涉及复杂业务逻辑或者需要高吞吐量时。&lt;/p&gt;
&lt;p&gt;在深入讨论之前，需要进一步了解 Stylus 引擎与 Arbitrum Rollup 之间的协同工作方式。Stylus 背后的核心思路是将多语言编译产物转换为与 Arbitrum VM 兼容的字节码，并利用 Arbitrum 的 Rollup 机制实现高吞吐量的交易打包与提交。同时，Stylus 还注重可维护性，对跨语言交互和数据结构格式进行了适配，让不同语言实现的逻辑能在同一合约生态中顺畅调用与组合。这为复杂场景下的风险控制与扩展提供了创新空间。&lt;/p&gt;
&lt;h3&gt;1.2 Arbitrum 与 Layer 2 扩容&lt;/h3&gt;
&lt;p&gt;Arbitrum 作为一种 Layer 2 解决方案，在主链上通过汇总批量交易来降低 Gas 成本并提高可扩展性。它利用了自己的执行环境，同时通过 Rollup 技术将交易数据安全地记录在以太坊上，实现高效与安全的平衡。&lt;/p&gt;
&lt;h3&gt;1.3 Stylus 的引入&lt;/h3&gt;
&lt;p&gt;在此基础上，Arbitrum 推出了 Stylus，实现了对多种系统级语言编写智能合约的支持。与传统 EVM 合约相比，Stylus 合约运行在与 Arbitrum 兼容的环境中，利用字节码级的方式整合 Rust、C/C++ 等语言所编译生成的构件。这使得开发者可在熟悉的语言中进行编程，并在 Arbitrum 上享受更高的吞吐量与灵活性。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;二、技术特性与优势&lt;/h2&gt;
&lt;h3&gt;2.1 多语言支持&lt;/h3&gt;
&lt;p&gt;Stylus 最突出的特性是能够使用多种语言编写合约，包括 Rust、C、C++ 等。通过官方提供的 SDK（如 &lt;a href=&quot;https://github.com/OffchainLabs/stylus-sdk-rs&quot;&gt;OffchainLabs/stylus-sdk-rs&lt;/a&gt;），开发者可以将本地项目编译为 Stylus 兼容的格式，再部署到 Arbitrum 网络。&lt;/p&gt;
&lt;p&gt;通过 Stylus，开发者在获取底层性能的同时也能灵活使用多样化的编程范式，例如 Rust 中的所有权模型、C++ 强调的面向对象特性等。在传统 EVM 框架下，一些高级语言特性往往需要手动转换为 Solidity 能接受的形式，但在 Stylus 中，此类操作可得到一定的简化。尤其在涉及大量运算或自定义内存结构时，多语言的支持可显著降低开发难度、提高执行效率。在部署环节，官方提供的编译流程也在不断完善，以尽量减轻对开发者的门槛。&lt;/p&gt;
&lt;h3&gt;2.2 高性能与低成本&lt;/h3&gt;
&lt;p&gt;据官方及社区的基准测试（参考 &lt;a href=&quot;https://arbitrum.io/stylus&quot;&gt;Arbitrum 官方文档&lt;/a&gt; 与 &lt;a href=&quot;https://docs.welldonestudio.io/tutorials/arbitrum-stylus-benchmark&quot;&gt;Arbitrum Stylus Benchmark&lt;/a&gt;），Stylus 合约在同等操作下往往可以实现较低的 Gas 消耗，同时保有更快的执行速度。尤其当合约逻辑复杂时，使用系统级语言可能在内存管理、计算等方面带来效率收益。&lt;/p&gt;
&lt;h3&gt;2.3 合约可组合性&lt;/h3&gt;
&lt;p&gt;除了性能的提升，Arbitrum Stylus 也关注与其他协议的交互和可组合性。正如 &lt;a href=&quot;https://fishyonchain.medium.com/arbitrum-stylus-a-new-standard-for-smart-contract-composability-2c5c3679ca20&quot;&gt;Fishyonchain 的文章&lt;/a&gt; 中所述，Stylus 将使复杂协议在合约层面的互操作变得更加容易，可在更多场景下实现与 DeFi、NFT 或其他 Layer 2 协议的联动。&lt;/p&gt;
&lt;h3&gt;2.4 与 Arbitrum 生态的融合&lt;/h3&gt;
&lt;p&gt;Stylus 充分利用了 Arbitrum 在 Layer 2 的技术栈，依托安全性与高吞吐量的基础，提供易于使用的接口。它既能与传统的 EVM 合约配合，实现资源共享和模块化部署，也能独立运行基于系统级语言的业务逻辑，兼具灵活性和兼容性。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;三、基础使用流程&lt;/h2&gt;
&lt;h3&gt;3.1 环境准备&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;编译工具链&lt;/strong&gt;：确保安装适用于目标语言（Rust/C/C++）的编译器，如进行 Rust 开发时，需要安装 &lt;code&gt;rustup&lt;/code&gt; 并设置好相应的 nightly 工具链。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Arbitrum 节点或测试网络&lt;/strong&gt;：可选择官方提供的 Rollup 测试环境，或者在本地搭建一个 Arbitrum 节点，用于对合约进行本地测试。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SDK 获取&lt;/strong&gt;：从 &lt;a href=&quot;https://github.com/OffchainLabs/stylus-sdk-rs&quot;&gt;OffchainLabs/stylus-sdk-rs&lt;/a&gt; 克隆或下载最新版本的 Stylus SDK，并按照文档指引进行安装和配置。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;3.2 编写 Stylus 合约&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;项目初始化&lt;/strong&gt;：以 Rust 为例，可使用 &lt;code&gt;cargo new&lt;/code&gt; 命令创建新项目。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现业务逻辑&lt;/strong&gt;：在项目中编写具体的函数和数据结构，并保证符合 Stylus 运行环境的适配要求（如入口函数、内存管理、回调等）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;测试与调试&lt;/strong&gt;：在本地通过编译工具链测试代码逻辑，使用官方或社区提供的测试框架检查合约行为。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于开发者而言，除了要掌握基本的 Rust 或 C/C++ 语法外，还需理解 Stylus 合约如何与 Arbitrum 上的其他合约进行信息交互。例如，与传统 EVM 合约之间的调用方式会包含一层 Stylus 专用的编解码步骤，确保映射到通用的字节码接口后双方能够正确接收与发送数据。同时，合约内部需要对 Gas 成本保持敏感，因为虽然 Stylus 有潜在的费用和性能优势，但不合理的逻辑仍可能导致资源浪费。&lt;/p&gt;
&lt;h3&gt;3.3 编译与部署&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;编译生成字节码&lt;/strong&gt;：按照 Stylus SDK 的说明，将 Rust/C/C++ 源码编译为 Stylus 兼容的字节码包。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;部署脚本&lt;/strong&gt;：使用 Arbitrum 提供的 CLI 工具或 Web 界面，将生成的字节码合约部署到测试网或主网。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;合约交互&lt;/strong&gt;：完成部署后，即可通过 Arbitrum 的 RPC 或者兼容的工具（如 Hardhat、Foundry 等），对合约方法进行调用或阅读合约状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在部署合约时，需要注意目标链所在的网络环境，如测试网或主网。为了在测试环境中更快地迭代，开发者可借助 Arbitrum 提供的公共测试网，或本地模拟环境，先完成初步验证和调试，再通过官方 CLI 或者第三方工具进行正式部署。部署后，可使用类似 Hardhat 或 Foundry 等工具与合约进行交互、测试调用结果，并借助区块浏览器或监控服务查看合约执行的细节与统计信息。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;四、使用示例&lt;/h2&gt;
&lt;p&gt;以下为一个极简的 Rust 示例，仅用于演示合约编写逻辑与部署方式（具体可参考官方 &lt;a href=&quot;https://docs.arbitrum.io/stylus/gentle-introduction&quot;&gt;Gentle Introduction&lt;/a&gt; 及相关文档）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 假设在 main.rs 中使用 Rust 编写
fn main() {
    // 在 Stylus 中执行的简单示例逻辑
    // 例如：读取输入参数、执行一些计算，然后返回结果
    let result = add(2, 3);
    println!(&quot;Execution result: {}&quot;, result);
}

fn add(a: i32, b: i32) -&amp;gt; i32 {
    a + b
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下方的示例仅仅展示了一个最简化的 Rust 主函数，但在真正的 Stylus 合约中，我们往往会定义多种接口函数和业务逻辑模块，并通过 SDK 中的 ABI 适配层来处理对外接口。很多情况下，需要结合链下数据进行混合计算或操作，例如通过 Oracles 获取价格信息，再在合约内执行精准的数值运算。正是这些对多语言特性的需求，促使 Stylus 的开发与演进。&lt;/p&gt;
&lt;p&gt;在完成本地测试后，通过 Stylus SDK 对项目进行打包并部署，即可在 Arbitrum 网络中与该合约进行交互。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;五、常见问题与未来展望&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;合约审计&lt;/strong&gt;：虽然 Stylus 提供多语言支持，但依然需要对合约逻辑、边界条件和安全隐患进行审计。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生态工具链&lt;/strong&gt;：Stylus 属于新兴技术，其可用的调试工具、框架与库仍在快速迭代，未来可能会出现更丰富的开发工具与最佳实践。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;与 EVM 的共存&lt;/strong&gt;：Stylus 并非取代 EVM，而是与 EVM 合约共同存在，为开发者提供多元化选择。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能与可扩展性&lt;/strong&gt;：后续官方或社区仍会进行深入优化，包含编译器层面和执行引擎层面的改进，提升整体性能。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外，由于 Stylus 仍处于积极的迭代阶段，合约安全审核和工具链测试必须引起足够的重视。开发者在正式发布前，应该借鉴常见的漏洞分析方法，对可能出现的越界读写、内存泄漏或函数访问控制不当等问题进行排查。随着社区的不断壮大，更多的审计机构和开发团队也将逐步建立完善的最佳实践与范式。未来，随着在合规性与易用性方面的改进，Stylus 将有望进一步融入主流 Layer 2 生态。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;六、参考资料&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://arbitrum.io/stylus&quot;&gt;Arbitrum 官方介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.arbitrum.io/stylus/gentle-introduction&quot;&gt;Arbitrum Stylus Gentle Introduction&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.welldonestudio.io/tutorials/arbitrum-stylus-benchmark&quot;&gt;Arbitrum Stylus Benchmark&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://fishyonchain.medium.com/arbitrum-stylus-a-new-standard-for-smart-contract-composability-2c5c3679ca20&quot;&gt;Fishyonchain: Stylus 可组合性文章&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/OffchainLabs/stylus-sdk-rs&quot;&gt;Stylus SDK (Rust)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过上述资料，可以进一步深入了解 Stylus 的实现原理与应用场景。总之，Arbitrum Stylus 集多语言支持、执行效率与安全性于一体，为智能合约开发者提供了新的选择。希望本教程能为初次接触本技术的读者带来帮助，后续可持续关注官方与社区的更新，及时掌握最新功能与最佳实践。&lt;/p&gt;
&lt;p&gt;对于那些希望通过多语言能力来提升合约可读性与可维护性的团队而言，Stylus 的出现无疑是一个重要机遇。它不仅扩大了人才储备的范围，也为各类新型用例提供了技术可行性。在具体应用上，无论是对 NFT 协议进行技术创新，还是实现更加复杂的金融衍生品逻辑，都可以充分利用多语言编程带来的灵活性。未来，借助社区的力量，Stylus 有望提供更齐全的库与开发框架来支撑大型项目的持续迭代与运行。&lt;/p&gt;
&lt;p&gt;希望本文能为读者提供一个清晰的 Stylus 入门指南，帮助大家在 Arbitrum 生态中更好地发挥多语言编程的优势。随着技术的不断发展，Stylus 将在智能合约领域扮演越来越重要的角色。&lt;/p&gt;
</content:encoded></item><item><title>Arbitrum Stylus：重新定义智能合约的五大核心竞争力</title><link>https://newpower.pro/posts/blockchain/arbitrum/arbitrumstylusintroduce/</link><guid isPermaLink="true">https://newpower.pro/posts/blockchain/arbitrum/arbitrumstylusintroduce/</guid><pubDate>Thu, 08 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;在区块链开发领域，智能合约的技术瓶颈长期困扰着开发者：Solidity 单一语言生态的封闭性、EVM 计算效率的天花板、高昂的 Gas 费用，如同三重枷锁限制着 Web3 应用的创新边界。2023 年，Arbitrum 推出的 Stylus 技术打破了这一僵局，通过&lt;strong&gt;多语言支持、极致性能优化、Gas 成本锐减、无缝扩展性&lt;/strong&gt;与&lt;strong&gt;模块化架构&lt;/strong&gt;，为智能合约开发开启了全新维度。本文将从技术落地角度，深度解析 Stylus 如何重塑行业规则。&lt;/p&gt;
&lt;h2&gt;一、编程语言革命：从「Solidity 孤岛」到「全栈语言互联」&lt;/h2&gt;
&lt;p&gt;传统 EVM 生态中，Solidity 是唯一官方语言，导致全球 90% 以上的开发者（精通 Rust/C++/Python 等主流语言）被挡在 Web3 门外。Stylus 通过&lt;strong&gt;WASM（WebAssembly）技术&lt;/strong&gt;彻底打破壁垒：&lt;/p&gt;
&lt;h3&gt;1. 工业级语言原生支持&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Rust/C++ 首选&lt;/strong&gt;：支持内存安全特性的 Rust（杜绝缓冲区溢出、悬垂指针等漏洞）与高性能计算见长的 C++，可直接编译为 WASM 字节码部署至 Arbitrum 链。例如，Rust 的加密库&lt;code&gt;rust-crypto&lt;/code&gt;、C++ 的数学库&lt;code&gt;Eigen&lt;/code&gt;可无缝集成到智能合约。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生态无缝对接&lt;/strong&gt;：通过&lt;code&gt;wasm-bindgen&lt;/code&gt;等工具，Python/Go 代码可间接转译为 WASM，实现「全栈语言上链」，彻底释放传统软件生态的万亿级开发资源。&lt;/p&gt;
&lt;h3&gt;2. 双引擎互操作架构&lt;/h3&gt;
&lt;p&gt;Stylus 并非推翻 EVM，而是构建 **「EVM+WASM」双虚拟机共生体系 **：&lt;/p&gt;
&lt;p&gt;Solidity 合约可调用 Rust 编写的高性能算法（如 zk-SNARK 证明生成）；&lt;/p&gt;
&lt;p&gt;C++ 开发的链上游戏逻辑能直接读取 EVM 账户的 ERC-721 资产；&lt;/p&gt;
&lt;p&gt;跨语言合约通过 ArbOS 的&lt;code&gt;arbitrum-std&lt;/code&gt;标准库实现数据交互，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Rust合约调用EVM的ERC-20转账
let transfer_result = evm_call(
    &quot;0xTokenContractAddress&quot;,
    &quot;transfer&quot;,
    &amp;amp;[sender_address, receiver_address, amount]
);

// EVM合约调用Rust的哈希计算
let hash = wasm_call(&quot;crypto_module&quot;, &quot;sha256&quot;, &amp;amp;data_bytes);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;二、性能跃升：从「EVM 龟速」到「WASM 超音速」&lt;/h2&gt;
&lt;p&gt;EVM 的栈式架构在复杂计算中效率低下，而 Stylus 基于 WASM 的线性内存模型与 JIT 编译，实现&lt;strong&gt;10-100 倍性能突破&lt;/strong&gt;（数据来源：Arbitrum 官方测试网）：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;计算场景&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;EVM 执行时间&lt;/th&gt;
&lt;th&gt;Stylus（Rust）&lt;/th&gt;
&lt;th&gt;效率提升&lt;/th&gt;
&lt;th&gt;Gas 成本对比&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SHA-256 哈希计算&lt;/td&gt;
&lt;td&gt;120ms&lt;/td&gt;
&lt;td&gt;8ms&lt;/td&gt;
&lt;td&gt;15 倍&lt;/td&gt;
&lt;td&gt;降低 93%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;椭圆曲线签名生成&lt;/td&gt;
&lt;td&gt;450ms&lt;/td&gt;
&lt;td&gt;32ms&lt;/td&gt;
&lt;td&gt;14 倍&lt;/td&gt;
&lt;td&gt;降低 89%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;金融衍生品定价模型&lt;/td&gt;
&lt;td&gt;1.2s&lt;/td&gt;
&lt;td&gt;65ms&lt;/td&gt;
&lt;td&gt;18 倍&lt;/td&gt;
&lt;td&gt;降低 91%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这种提升在 DeFi 高频交易中尤为关键：某算法交易协议迁移至 Stylus 后，每秒可处理 2000 笔套利交易，而同等操作在 EVM 上因 Gas 限制最多仅能处理 50 笔。&lt;/p&gt;
&lt;h2&gt;三、Gas 成本锐减：让「链上计算自由」成为可能&lt;/h2&gt;
&lt;p&gt;高 Gas 费用曾是链上复杂逻辑的「拦路虎」，Stylus 通过三重优化实现成本革命：&lt;/p&gt;
&lt;h3&gt;1. 计算效率原生优势&lt;/h3&gt;
&lt;p&gt;WASM 的二进制指令密度比 EVM 字节码高 50%，且无需复杂的 Gas 计量模型，同等计算量下 Gas 消耗呈指数级下降。例如：&lt;/p&gt;
&lt;p&gt;链上验证一个 zk-SNARK 证明，EVM 需消耗 200 万 Gas（约 15 美元），Stylus 仅需 20 万 Gas（约 1.2 美元）；&lt;/p&gt;
&lt;p&gt;复杂的金融合约交互（如期权定价），Gas 成本从平均 50 美元降至 3 美元以下。&lt;/p&gt;
&lt;h3&gt;2. 内存与存储优化&lt;/h3&gt;
&lt;p&gt;Rust 的所有权系统避免了 EVM 常见的「数据拷贝损耗」，WASM 的紧凑格式使链上存储成本降低 40%。某 NFT 游戏迁移后，角色属性动态更新的 Gas 成本从 2000Gas 降至 800Gas。&lt;/p&gt;
&lt;h2&gt;四、扩展性突破：从「功能受限」到「场景无限」&lt;/h2&gt;
&lt;p&gt;Stylus 通过&lt;strong&gt;模块化架构&lt;/strong&gt;与&lt;strong&gt;生态兼容性&lt;/strong&gt;，解锁三大类此前 EVM 无法承载的场景：&lt;/p&gt;
&lt;h3&gt;1. 高性能金融应用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;高频交易协议&lt;/strong&gt;：C++ 编写的订单簿引擎支持 10 万 TPS，延迟控制在 50 微秒，为算法交易、量化策略提供基础设施；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实时风险计算&lt;/strong&gt;：Rust 实现的蒙特卡洛模拟合约，可在 200ms 内完成万人级保单的风险评估，推动去中心化保险产品落地。&lt;/p&gt;
&lt;h3&gt;2. 链上原生交互体验&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;实时物理引擎&lt;/strong&gt;：C++ 移植的 Box2D 引擎在链上实现车辆碰撞、流体模拟，某赛车游戏因此达到 120FPS 流畅度，操作延迟从 3 秒缩短至 200ms；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态 NFT 系统&lt;/strong&gt;：支持复杂状态变更（如武器磨损度、土地肥力），单合约调用 Gas 成本仅为 EVM 的 1/20。&lt;/p&gt;
&lt;h3&gt;3. 企业级合规需求&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;KYC/AML 模块&lt;/strong&gt;：金融机构用 C++ 开发的合规验证逻辑，处理速度提升 50 倍，同时满足 GDPR 数据隐私要求；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;供应链溯源&lt;/strong&gt;：Rust 实现的零知识证明合约，在不泄露商业数据的前提下完成跨企业验证，审计时间从 30 天压缩至 2 小时。&lt;/p&gt;
&lt;h2&gt;五、Stylus 技术模块：构建开发者友好生态&lt;/h2&gt;
&lt;p&gt;Arbitrum 通过三层技术架构降低开发门槛，形成完整工具链闭环：&lt;/p&gt;
&lt;h3&gt;1. 语言层：保留开发习惯&lt;/h3&gt;
&lt;p&gt;支持主流 IDE（VS Code/PyCharm）调试，兼容 Git 版本控制与 Docker 容器化部署；&lt;/p&gt;
&lt;p&gt;提供&lt;code&gt;arbitrum-std-rs&lt;/code&gt;标准库，封装区块链核心接口（如区块高度获取、合约调用）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 获取当前区块时间戳
let current_time = arbitrum::chain::timestamp();

// 查询ERC-20合约余额
let balance = arbitrum::evm::erc20::balance_of(
    token_contract,
    user_address
);
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;2. 编译执行层：高效转化链路&lt;/h3&gt;
&lt;p&gt;基于 LLVM 编译器链，将高级语言转为 WASM 字节码，支持&lt;code&gt;cargo build --release&lt;/code&gt;一键生成部署文件；&lt;/p&gt;
&lt;p&gt;Stylus VM 针对区块链场景优化，内存访问速度比通用 WASM 引擎快 30%。&lt;/p&gt;
&lt;h3&gt;3. 互操作层：无缝连接 EVM&lt;/h3&gt;
&lt;p&gt;ArbOS 作为「智能合约操作系统」，实现双虚拟机状态共享与函数互调；&lt;/p&gt;
&lt;p&gt;支持 Solidity 与 Rust/C++ 合约在同一交易中协同，例如：Rust 预言机获取链下数据后，触发 EVM 借贷合约的利率调整。&lt;/p&gt;
&lt;h2&gt;结语：开启智能合约的「全新时代」&lt;/h2&gt;
&lt;p&gt;Arbitrum Stylus 的价值，远不止于技术参数的提升，更在于它打破了「区块链开发的语言壁垒」，让 5000 万传统开发者首次拥有平等参与 Web3 的机会。当 Rust 工程师能用熟悉的语言编写 DeFi 协议，当 C++ 开发者为链游注入复杂物理逻辑，当企业架构师用 Stylus 构建合规链上系统，我们正在见证的，是智能合约从「极客玩具」到「主流基础设施」的历史性跨越。&lt;/p&gt;
&lt;p&gt;对于开发者而言，现在正是抢占技术先机的黄金窗口 ——Stylus 不仅是一个工具，更是通往 Web3 创新蓝海的通行证。随着 Arbitrum 生态的持续扩张，这场由编程语言引发的革命，终将重塑整个区块链开发的未来图景。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;延伸探索&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.arbitrum.io/stylus/gentle-introduction&quot;&gt;Stylus 官方入门文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>《揭秘英语构词法：快速扩充词汇量的钥匙》</title><link>https://newpower.pro/posts/english/%E6%9E%84%E8%AF%8D%E6%B3%95/</link><guid isPermaLink="true">https://newpower.pro/posts/english/%E6%9E%84%E8%AF%8D%E6%B3%95/</guid><pubDate>Wed, 07 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;英语构词法：揭开词汇创造的密码&lt;/p&gt;
&lt;p&gt;你是否曾好奇英语词汇为何如此庞大且灵活？从 &quot;unhappiness&quot; 到 &quot;smartphone&quot;，从 &quot;email&quot; 到 &quot;smog&quot;，这些单词的诞生并非偶然，而是遵循着一套系统的构词规则。掌握英语构词法，就像获得一把钥匙，不仅能快速扩充词汇量，更能深入理解语言背后的逻辑。本文将带你探索构词法的核心奥秘，结合实例解析六大主要构词方式，助你成为词汇记忆的高效学习者。&lt;/p&gt;
&lt;h3&gt;一、派生法：词根词缀的化学反应&lt;/h3&gt;
&lt;p&gt;派生法是英语构词的主力军，约 70% 的词汇由此而生。它通过&lt;strong&gt;前缀改变词义&lt;/strong&gt;、&lt;strong&gt;后缀改变词性&lt;/strong&gt;，如同汉字的偏旁部首，赋予单词新的生命力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;词根的核心地位&lt;/strong&gt;：词根是单词的灵魂，如 &quot;vis&quot;（看）在 &quot;visible&quot;（可见的）、&quot;vision&quot;（视力）中反复出现。希腊语和拉丁语词根（如 &quot;hydr-&quot; 水、&quot;aqua-&quot; 水）与日耳曼语词汇（如 &quot;water&quot;）共同构成英语的双重词汇体系。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前缀的魔术手&lt;/strong&gt;：否定前缀 &quot;un-&quot;、&quot;in-&quot;、&quot;dis-&quot; 能瞬间反转词义（happy→unhappy），而 &quot;en-&quot;（使...）可将形容词转化为动词（large→enlarge）。值得注意的是，前缀可能因发音调整拼写（如 &quot;im-possible&quot; 而非 &quot;in-possible&quot;）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后缀的变形术&lt;/strong&gt;：后缀不仅改变词性，还能细化词义。例如，动词 &quot;work&quot; 加 &quot;-able&quot; 变为形容词 &quot;workable&quot;（可行的），而 &quot;accept&quot; 加 &quot;-able&quot; 成为 &quot;acceptable&quot;（可接受的）。需要注意的是，法语词根多接 &quot;-able&quot;，希腊 / 拉丁词根则常用 &quot;-ible&quot;（如 &quot;credible&quot; 可信的）。&lt;/p&gt;
&lt;h3&gt;二、合成法：词汇的积木游戏&lt;/h3&gt;
&lt;p&gt;合成法将两个或多个独立单词组合成新词，如同搭积木般直观。这种构词法在科技、日常用语中尤为常见，约占英语词汇的 30%。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;直接组合&lt;/strong&gt;：如 &quot;waterproof&quot;（防水的）由 &quot;water&quot;（水）和 &quot;proof&quot;（对抗）构成，&quot;highclass&quot;（高级的）结合 &quot;high&quot;（高）与 &quot;class&quot;（等级）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;混合词的创意&lt;/strong&gt;：当单词过长时，人们会截取部分字母组合，例如 &quot;smog&quot;（烟雾）来自 &quot;smoke&quot; 和 &quot;fog&quot;，&quot;brunch&quot;（早午餐）融合 &quot;breakfast&quot; 与 &quot;lunch&quot;。科技领域的 &quot;telecast&quot;（电视广播）由 &quot;television&quot; 和 &quot;broadcast&quot; 混合而成，展现了语言的创新性。&lt;/p&gt;
&lt;h3&gt;三、转化法：一词多义的变形记&lt;/h3&gt;
&lt;p&gt;转化法允许单词在词形不变的情况下转换词性，赋予语言极大的灵活性。例如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;名词→动词&lt;/strong&gt;：&quot;book&quot;（书）→&quot;book a flight&quot;（预订航班），&quot;hand&quot;（手）→&quot;hand me the pen&quot;（递给我笔）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;形容词→动词&lt;/strong&gt;：&quot;better&quot;（更好的）→&quot;better our lives&quot;（改善生活），&quot;slow&quot;（慢的）→&quot;slow down&quot;（减速）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动词→名词&lt;/strong&gt;：&quot;swim&quot;（游泳）→&quot;have a swim&quot;（游泳），&quot;laugh&quot;（笑）→&quot;burst into laughter&quot;（大笑）。&lt;/p&gt;
&lt;h3&gt;四、缩写法：语言的瘦身术&lt;/h3&gt;
&lt;p&gt;缩写法通过缩短单词或取首字母创造简洁表达，常见于日常交流和专业领域：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;截短词&lt;/strong&gt;：&quot;ad&quot;（广告）来自 &quot;advertisement&quot;，&quot;phone&quot;（电话）截取自 &quot;telephone&quot;，&quot;flu&quot;（流感）省略首尾字母。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首字母缩略词&lt;/strong&gt;：&quot;NASA&quot;（美国宇航局）、&quot;VIP&quot;（贵宾）、&quot;TOEFL&quot;（托福考试）等，读音可逐个字母或作为单词（如 &quot;NASA&quot; 读作 /&apos;næsə/）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特殊缩写&lt;/strong&gt;：&quot;AIDS&quot;（艾滋病）由 &quot;Acquired Immune Deficiency Syndrome&quot; 缩写而来，&quot;radar&quot;（雷达）则是 &quot;Radio Detection and Ranging&quot; 的首字母组合。&lt;/p&gt;
&lt;h3&gt;五、逆成法：反向创造的艺术&lt;/h3&gt;
&lt;p&gt;逆成法通过删除误认为词缀的部分创造新词，常见于动词生成。例如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;名词→动词&lt;/strong&gt;：&quot;editor&quot;（编辑）去掉 &quot;-or&quot; 变成 &quot;edit&quot;（编辑），&quot;donation&quot;（捐赠）去掉 &quot;-ation&quot; 成为 &quot;donate&quot;（捐赠）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;形容词→动词&lt;/strong&gt;：&quot;lazy&quot;（懒惰的）去掉 &quot;-y&quot; 变为 &quot;laze&quot;（偷懒），&quot;greedy&quot;（贪婪的）去掉 &quot;-y&quot; 成为 &quot;greed&quot;（贪婪）。&lt;/p&gt;
&lt;h3&gt;六、混合法：跨词融合的新物种&lt;/h3&gt;
&lt;p&gt;混合法结合两个单词的部分字母，创造兼具两者含义的新词：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首尾拼接&lt;/strong&gt;：&quot;motel&quot;（汽车旅馆）=motor + hotel，&quot;Chunnel&quot;（英法海底隧道）=channel + tunnel。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;保留部分词形&lt;/strong&gt;：&quot;paratroops&quot;（空降部队）=parachute + troops，&quot;docudrama&quot;（纪录片）=document + drama。&lt;/p&gt;
&lt;h3&gt;学习构词法的实用技巧&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;词根词缀拆解&lt;/strong&gt;：遇到生词时，尝试分解为前缀 + 词根 + 后缀。例如 &quot;invisible&quot;=in-（否定）+vis（看）+ -ible（可... 的），意为 &quot;不可见的&quot;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;建立词汇网络&lt;/strong&gt;：以词根为中心，扩展相关词汇。如 &quot;aud&quot;（听）可衍生出 &quot;audible&quot;（可听见的）、&quot;audience&quot;（听众）、&quot;audio&quot;（音频）等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意例外与变体&lt;/strong&gt;：并非所有派生词都遵循规则，例如 &quot;effible&quot;（可描述的）实际不存在，只有其否定形式 &quot;ineffible&quot;（不可描述的）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结合语境记忆&lt;/strong&gt;：通过阅读和听力积累合成词与转化词，如 &quot;Google&quot; 作为动词（搜索）在 &quot;I Google the answer&quot; 中的用法。&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- 英语构词法是词汇学习的加速器，掌握它不仅能让背单词事半功倍，更能提升对语言的敏感度。无论是通过派生法解析复杂词汇，还是用合成法创造新表达，构词法都揭示了语言的创造性与逻辑性。下次遇到陌生单词时，不妨尝试拆解它的 &quot;基因&quot;，你会发现词汇的世界远比想象中更有趣！ --&amp;gt;&lt;/p&gt;
&lt;p&gt;（本文参考资料：&lt;a href=&quot;https://mp.weixin.qq.com/s/Vj-1SIebCe0RWswom2o2sg&quot;&gt;英语构词法详解&lt;/a&gt;及多平台权威构词法研究成果）&lt;/p&gt;
</content:encoded></item><item><title>《玩转英语语法: 从基础到进阶》</title><link>https://newpower.pro/posts/english/%E8%AF%AD%E6%B3%95%E4%BD%93%E7%B3%BB/</link><guid isPermaLink="true">https://newpower.pro/posts/english/%E8%AF%AD%E6%B3%95%E4%BD%93%E7%B3%BB/</guid><pubDate>Wed, 07 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;一、语法体系基石：从字母到词性&lt;/h2&gt;
&lt;h3&gt;（一）26 个英文字母 —— 语言的最小单位&lt;/h3&gt;
&lt;p&gt;英语由 26 个字母构成，分为元音字母（Aa、Ee、Ii、Oo、Uu）和辅音字母（其余 21 个）。正确掌握字母的发音和书写，是拼写单词、学习音标和发音规则的基础。&lt;/p&gt;
&lt;h3&gt;（二）10 种单词词性 —— 句子的 “建筑材料”&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;词性&lt;/th&gt;
&lt;th&gt;缩写&lt;/th&gt;
&lt;th&gt;定义&lt;/th&gt;
&lt;th&gt;例词&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名词&lt;/td&gt;
&lt;td&gt;n.&lt;/td&gt;
&lt;td&gt;表示人或事物的总称&lt;/td&gt;
&lt;td&gt;apple（苹果）、pen（笔）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;动词&lt;/td&gt;
&lt;td&gt;v.&lt;/td&gt;
&lt;td&gt;表示动作或状态&lt;/td&gt;
&lt;td&gt;smile（微笑）、finish（完成）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;形容词&lt;/td&gt;
&lt;td&gt;adj.&lt;/td&gt;
&lt;td&gt;修饰名词，描述特质&lt;/td&gt;
&lt;td&gt;good（好的）、short（短的）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;副词&lt;/td&gt;
&lt;td&gt;adv.&lt;/td&gt;
&lt;td&gt;修饰动词、形容词或其他副词&lt;/td&gt;
&lt;td&gt;now（现在）、truly（真正地）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;代词&lt;/td&gt;
&lt;td&gt;pron.&lt;/td&gt;
&lt;td&gt;代替名词、形容词或数词&lt;/td&gt;
&lt;td&gt;he（他）、this（这个）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数词&lt;/td&gt;
&lt;td&gt;num.&lt;/td&gt;
&lt;td&gt;表示数量或顺序&lt;/td&gt;
&lt;td&gt;one（一）、first（第一）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;介词&lt;/td&gt;
&lt;td&gt;prep.&lt;/td&gt;
&lt;td&gt;用在名 / 代词前，说明关系&lt;/td&gt;
&lt;td&gt;in（在…… 里）、on（在…… 上）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;冠词&lt;/td&gt;
&lt;td&gt;art.&lt;/td&gt;
&lt;td&gt;用在名词前，限定范围&lt;/td&gt;
&lt;td&gt;a/an（泛指）、the（特指）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;连词&lt;/td&gt;
&lt;td&gt;conj.&lt;/td&gt;
&lt;td&gt;连接短语或句子&lt;/td&gt;
&lt;td&gt;and（和）、but（但是）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;感叹词&lt;/td&gt;
&lt;td&gt;int.&lt;/td&gt;
&lt;td&gt;表达情感或语气&lt;/td&gt;
&lt;td&gt;oh（哦）、well（嗯）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;二、语法核心：从词到句的逻辑纽带&lt;/h2&gt;
&lt;h3&gt;（一）20 个疑问代词 —— 精准提问的关键&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;疑问词&lt;/th&gt;
&lt;th&gt;提问对象&lt;/th&gt;
&lt;th&gt;例句&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;who&lt;/td&gt;
&lt;td&gt;人（主格）&lt;/td&gt;
&lt;td&gt;Who is standing there?（谁站在那里？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;whom&lt;/td&gt;
&lt;td&gt;人（宾格）&lt;/td&gt;
&lt;td&gt;Whom did you meet?（你遇见了谁？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;what&lt;/td&gt;
&lt;td&gt;事物&lt;/td&gt;
&lt;td&gt;What do you want?（你想要什么？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;why&lt;/td&gt;
&lt;td&gt;原因&lt;/td&gt;
&lt;td&gt;Why are you late?（你为什么迟到？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;where&lt;/td&gt;
&lt;td&gt;地点&lt;/td&gt;
&lt;td&gt;Where is the library?（图书馆在哪里？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;which&lt;/td&gt;
&lt;td&gt;特定范围的人 / 物&lt;/td&gt;
&lt;td&gt;Which book do you like?（你喜欢哪本书？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;when&lt;/td&gt;
&lt;td&gt;时间&lt;/td&gt;
&lt;td&gt;When will you leave?（你什么时候离开？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;how&lt;/td&gt;
&lt;td&gt;方式 / 程度&lt;/td&gt;
&lt;td&gt;How do you go to school?（你怎么去上学？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;whose&lt;/td&gt;
&lt;td&gt;所属关系&lt;/td&gt;
&lt;td&gt;Whose pen is this?（这是谁的笔？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;how old&lt;/td&gt;
&lt;td&gt;年龄&lt;/td&gt;
&lt;td&gt;How old is your sister?（你妹妹多大了？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;what color&lt;/td&gt;
&lt;td&gt;颜色&lt;/td&gt;
&lt;td&gt;What color is your car?（你的车是什么颜色？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;how tall&lt;/td&gt;
&lt;td&gt;高度&lt;/td&gt;
&lt;td&gt;How tall is the tree?（这棵树有多高？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;how big&lt;/td&gt;
&lt;td&gt;大小&lt;/td&gt;
&lt;td&gt;How big is your room?（你的房间有多大？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;how far&lt;/td&gt;
&lt;td&gt;距离&lt;/td&gt;
&lt;td&gt;How far is the school?（学校有多远？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;how many&lt;/td&gt;
&lt;td&gt;可数名词数量&lt;/td&gt;
&lt;td&gt;How many books are there?（有多少本书？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;how much&lt;/td&gt;
&lt;td&gt;不可数名词数量 / 价格&lt;/td&gt;
&lt;td&gt;How much milk do you need?（你需要多少牛奶？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;how often&lt;/td&gt;
&lt;td&gt;频率&lt;/td&gt;
&lt;td&gt;How often do you exercise?（你多久锻炼一次？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;what time&lt;/td&gt;
&lt;td&gt;具体时间&lt;/td&gt;
&lt;td&gt;What time is it?（几点了？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;how long&lt;/td&gt;
&lt;td&gt;时长 / 长度&lt;/td&gt;
&lt;td&gt;How long does it take?（需要多长时间？）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;（二）8 组人称代词 —— 明确指代关系&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;人称&lt;/th&gt;
&lt;th&gt;主格&lt;/th&gt;
&lt;th&gt;宾格&lt;/th&gt;
&lt;th&gt;形容词性物主代词&lt;/th&gt;
&lt;th&gt;名词性物主代词&lt;/th&gt;
&lt;th&gt;反身代词&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;第一人称单数&lt;/td&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;me&lt;/td&gt;
&lt;td&gt;my&lt;/td&gt;
&lt;td&gt;mine&lt;/td&gt;
&lt;td&gt;myself&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第一人称复数&lt;/td&gt;
&lt;td&gt;we&lt;/td&gt;
&lt;td&gt;us&lt;/td&gt;
&lt;td&gt;our&lt;/td&gt;
&lt;td&gt;ours&lt;/td&gt;
&lt;td&gt;ourselves&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第二人称单 / 复数&lt;/td&gt;
&lt;td&gt;you&lt;/td&gt;
&lt;td&gt;you&lt;/td&gt;
&lt;td&gt;your&lt;/td&gt;
&lt;td&gt;yours&lt;/td&gt;
&lt;td&gt;yourself/yourselves&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第三人称单数（男）&lt;/td&gt;
&lt;td&gt;he&lt;/td&gt;
&lt;td&gt;him&lt;/td&gt;
&lt;td&gt;his&lt;/td&gt;
&lt;td&gt;his&lt;/td&gt;
&lt;td&gt;himself&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第三人称单数（女）&lt;/td&gt;
&lt;td&gt;she&lt;/td&gt;
&lt;td&gt;her&lt;/td&gt;
&lt;td&gt;her&lt;/td&gt;
&lt;td&gt;hers&lt;/td&gt;
&lt;td&gt;herself&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第三人称单数（物）&lt;/td&gt;
&lt;td&gt;it&lt;/td&gt;
&lt;td&gt;it&lt;/td&gt;
&lt;td&gt;its&lt;/td&gt;
&lt;td&gt;its&lt;/td&gt;
&lt;td&gt;itself&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第三人称复数&lt;/td&gt;
&lt;td&gt;they&lt;/td&gt;
&lt;td&gt;them&lt;/td&gt;
&lt;td&gt;their&lt;/td&gt;
&lt;td&gt;theirs&lt;/td&gt;
&lt;td&gt;themselves&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;三、时态 —— 动词的 “时间魔法”&lt;/h2&gt;
&lt;p&gt;英语共有 16 种时态，按 “时间轴”（现在、过去、将来、过去将来）和 “状态”（一般、进行、完成、完成进行）分为四大类：&lt;/p&gt;
&lt;h3&gt;（一）现在时态&lt;/h3&gt;
&lt;p&gt;一般现在时：主语 + 动词原形 / 第三人称单数（标志词：always, often, every day）例：She studies English every day.（她每天学英语。）&lt;/p&gt;
&lt;p&gt;现在进行时：主语 + am/is/are + 动词 - ing（标志词：now, look, listen）例：We are watching TV now.（我们正在看电视。）&lt;/p&gt;
&lt;p&gt;现在完成时：主语 + have/has + 过去分词（标志词：already, yet, ever）例：I have visited Beijing twice.（我去过北京两次。）&lt;/p&gt;
&lt;p&gt;现在完成进行时：主语 + have/has been + 动词 - ing（强调持续到现在的动作）例：She has been waiting for an hour.（她等了一个小时了。）&lt;/p&gt;
&lt;h3&gt;（二）过去时态&lt;/h3&gt;
&lt;p&gt;一般过去时：主语 + 动词过去式（标志词：yesterday, ago, last year）例：He went to the park yesterday.（他昨天去了公园。）&lt;/p&gt;
&lt;p&gt;过去进行时：主语 + was/were + 动词 - ing（标志词：at that time, when/while 引导的从句）例：They were playing basketball when it rained.（下雨时他们正在打篮球。）&lt;/p&gt;
&lt;p&gt;过去完成时：主语 + had + 过去分词（标志词：by + 过去时间）例：She had left before I arrived.（我到之前她已经走了。）&lt;/p&gt;
&lt;p&gt;过去完成进行时：主语 + had been + 动词 - ing（强调过去持续到过去某时的动作）例：He had been working here for 10 years before he retired.（退休前他在这里工作了 10 年。）&lt;/p&gt;
&lt;h3&gt;（三）将来时态&lt;/h3&gt;
&lt;p&gt;一般将来时：主语 + will/shall + 动词原形（标志词：tomorrow, next week）例：We will visit the museum tomorrow.（我们明天要去参观博物馆。）&lt;/p&gt;
&lt;p&gt;将来进行时：主语 + will be + 动词 - ing（强调将来某时正在进行的动作）例：She will be studying at 8 o&apos;clock tonight.（今晚 8 点她会在学习。）&lt;/p&gt;
&lt;p&gt;将来完成时：主语 + will have + 过去分词（标志词：by + 将来时间）例：By next year, I will have finished the project.（到明年，我将完成这个项目。）&lt;/p&gt;
&lt;p&gt;将来完成进行时：主语 + will have been + 动词 - ing（强调将来持续到某时的动作）例：They will have been living here for 5 years by next month.（到下个月，他们在这里住了 5 年了。）&lt;/p&gt;
&lt;h3&gt;（四）过去将来时态（以过去某时间为基准的 “将来”）&lt;/h3&gt;
&lt;p&gt;过去将来时：主语 + would + 动词原形（标志词：常用于宾语从句）例：He said he would come back soon.（他说他很快会回来。）&lt;/p&gt;
&lt;p&gt;过去将来进行时：主语 + would be + 动词 - ing例：She told me she would be waiting for me there.（她告诉我她会在那里等我。）&lt;/p&gt;
&lt;p&gt;过去将来完成时：主语 + would have + 过去分词例：He thought he would have finished the work by then.（他以为到那时他已经完成工作了。）&lt;/p&gt;
&lt;p&gt;过去将来完成进行时：主语 + would have been + 动词 - ing例：They knew they would have been studying for 3 hours by 9 o&apos;clock.（他们知道到 9 点他们会已经学习了 3 个小时。）&lt;/p&gt;
&lt;h2&gt;四、句子结构 —— 语法的 “骨架”&lt;/h2&gt;
&lt;h3&gt;（一）5 种简单句基本结构&lt;/h3&gt;
&lt;p&gt;主语 + 谓语（S+V）例：She laughs.（她笑了。）&lt;/p&gt;
&lt;p&gt;主语 + 谓语 + 宾语（S+V+O）例：I love English.（我爱英语。）&lt;/p&gt;
&lt;p&gt;主语 + 系动词 + 表语（S+Link.V+P）例：The cake tastes delicious.（蛋糕尝起来很美味。）&lt;/p&gt;
&lt;p&gt;主语 + 谓语 + 间接宾语 + 直接宾语（S+V+IO+DO）例：He gave me a book.（他给了我一本书。）&lt;/p&gt;
&lt;p&gt;主语 + 谓语 + 宾语 + 宾语补足语（S+V+O+C）例：We made him our monitor.（我们选他当班长。）&lt;/p&gt;
&lt;h3&gt;（二）3 大从句体系&lt;/h3&gt;
&lt;p&gt;名词性从句（包括主语从句、宾语从句、表语从句、同位语从句）例：What he said is true.（他说的是真的。）（主语从句）&lt;/p&gt;
&lt;p&gt;形容词性从句（定语从句）例：The book that I bought yesterday is interesting.（我昨天买的书很有趣。）&lt;/p&gt;
&lt;p&gt;副词性从句（状语从句，包括时间、地点、原因、条件、让步等）例：I will call you when I arrive.（我到了就给你打电话。）（时间状语从句）&lt;/p&gt;
&lt;h2&gt;五、语法细节：缩略词与时态标志词&lt;/h2&gt;
&lt;h3&gt;（一）常用缩略词 —— 口语与写作的 “简化工具”&lt;/h3&gt;
&lt;p&gt;主语 + be 动词：I&apos;m=I am, he&apos;s=he is, they&apos;re=they are&lt;/p&gt;
&lt;p&gt;否定形式：isn&apos;t=is not, aren&apos;t=are not, can&apos;t=cannot&lt;/p&gt;
&lt;p&gt;将来时：I&apos;ll=I will, we&apos;ll=we will, won&apos;t=will not&lt;/p&gt;
&lt;p&gt;其他：what&apos;s=what is, that&apos;s=that is, here&apos;s=here is&lt;/p&gt;
&lt;h3&gt;（二）时态标志词 —— 快速判断时态的 “信号灯”&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;时态&lt;/th&gt;
&lt;th&gt;标志词&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;一般现在时&lt;/td&gt;
&lt;td&gt;always, often, usually, every day&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;一般过去时&lt;/td&gt;
&lt;td&gt;yesterday, ago, last week, in 2020&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;一般将来时&lt;/td&gt;
&lt;td&gt;tomorrow, next month, in the future&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;现在进行时&lt;/td&gt;
&lt;td&gt;now, look, listen, at present&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;过去进行时&lt;/td&gt;
&lt;td&gt;at that time, when/while 引导的从句&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;现在完成时&lt;/td&gt;
&lt;td&gt;already, yet, ever, never, since, for&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;六、句子成分解析：精准拆分句子&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;主语&lt;/strong&gt;：动作的发出者（例：She made her brother sad. 中 “She” 是主语）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;宾语&lt;/strong&gt;：动作的承受者（例：I love apples. 中 “apples” 是宾语）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表语&lt;/strong&gt;：说明主语的状态或特征（例：He is a teacher. 中 “a teacher” 是表语）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定语&lt;/strong&gt;：修饰名词的成分（例：The red car is mine. 中 “red” 是定语）&lt;/p&gt;
&lt;h2&gt;结语：系统化学习，让语法不再难懂&lt;/h2&gt;
&lt;p&gt;英语语法体系看似复杂，实则是由一个个 “模块” 组成的逻辑系统。从字母到词性，从时态到句子结构，每一部分都是环环相扣的。对于零基础学习者来说，通过 “分模块整理 + 例句理解 + 刻意练习”，就能逐步搭建起完整的语法框架。记住，语法不是死记硬背的规则，而是帮助我们理解和运用英语的工具。&lt;/p&gt;
</content:encoded></item><item><title>研-计划</title><link>https://newpower.pro/posts/notebook/%E4%B8%AD%E5%B1%B1%E5%A4%A7%E5%AD%A6-%E7%A0%94-%E8%AE%A1%E5%88%92/</link><guid isPermaLink="true">https://newpower.pro/posts/notebook/%E4%B8%AD%E5%B1%B1%E5%A4%A7%E5%AD%A6-%E7%A0%94-%E8%AE%A1%E5%88%92/</guid><pubDate>Thu, 01 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;1. 基础阶段（2025 年 5 月 - 2026 年 12 月）&lt;/h2&gt;
&lt;h3&gt;目标：系统学习各科基础知识，构建知识框架&lt;/h3&gt;
&lt;h3&gt;数学（数一）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;教材：《高等数学》（同济版）、《线性代数》（同济版）、《概率论与数理统计》（浙大版）。&lt;/li&gt;
&lt;li&gt;网课：张宇基础班（高数）、李永乐线代强化班、王式安概率论基础班。&lt;/li&gt;
&lt;li&gt;习题：《660 题》《基础过关 1000 题》，每周完成 2 个章节。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;英语（一）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;词汇：每日背诵 50 个考研高频词（推荐《红宝书》）。&lt;/li&gt;
&lt;li&gt;语法：学习长难句分析（推荐田静《句句真研》）。&lt;/li&gt;
&lt;li&gt;阅读：精析 2005-2010 年真题阅读，每篇翻译并总结错题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;专业课（408）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;教材：《数据结构》（严蔚敏）、《计算机组成原理》（唐朔飞）、《操作系统》（汤小丹）、《计算机网络》（谢希仁）。&lt;/li&gt;
&lt;li&gt;网课：王道考研基础班，配套《王道考研复习指导书》。&lt;/li&gt;
&lt;li&gt;练习：完成教材课后习题，整理思维导图。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2. 强化阶段（2027 年 1 月 - 2027 年 6 月）&lt;/h2&gt;
&lt;h3&gt;目标：深化重点难点，提高解题速度&lt;/h3&gt;
&lt;h3&gt;数学&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;习题：《张宇 18 讲》《李林 880 题》，重点突破中高难度题型。&lt;/li&gt;
&lt;li&gt;真题：限时完成 2000-2015 年真题，每周 2 套，分析错题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;英语&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;阅读：精析 2011-2020 年真题，总结阅读技巧（如定位法、排除法）。&lt;/li&gt;
&lt;li&gt;写作：背诵 10 篇大作文模板，每周练习 1 篇。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;专业课&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;真题：完成 2009-2018 年 408 真题，总结高频考点（如数据结构中的算法设计、计组中的流水线计算）。&lt;/li&gt;
&lt;li&gt;模拟题：做《王道模拟 8 套卷》，训练答题时间分配。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3. 冲刺阶段（2027 年 7 月 - 2027 年 12 月）&lt;/h2&gt;
&lt;h3&gt;目标：模拟实战，查漏补缺&lt;/h3&gt;
&lt;h3&gt;数学&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;真题：二刷 2016-2022 年真题，重点关注近 5 年新题型。&lt;/li&gt;
&lt;li&gt;模拟题：做《李林 6+4 套卷》《合工大超越卷》，保持题感。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;英语&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;模考：每周全真模拟 1 套真题（含作文），严格限时 3 小时。&lt;/li&gt;
&lt;li&gt;翻译：练习 2010-2020 年真题翻译，总结翻译技巧。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;专业课&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;真题：三刷 408 真题，重点突破薄弱环节（如操作系统中的进程调度、计算机网络中的 TCP 协议）。&lt;/li&gt;
&lt;li&gt;复试准备：提前学习离散数学（推荐《离散数学及其应用》）和 C 语言（推荐《C Primer Plus》），为复试笔试做准备。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;政治&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;教材：《肖秀荣精讲精练》《1000 题》。&lt;/li&gt;
&lt;li&gt;网课：徐涛强化班（马原、毛中特）。&lt;/li&gt;
&lt;li&gt;冲刺：11 月开始背诵《肖四》《肖八》，关注时政热点。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;时间管理&lt;/h2&gt;
&lt;h3&gt;每日规划&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数学：3 小时（1.5 小时网课 + 1.5 小时习题）。&lt;/li&gt;
&lt;li&gt;英语：2 小时（1 小时单词 + 1 小时阅读）。&lt;/li&gt;
&lt;li&gt;专业课：3 小时（2 小时网课 + 1 小时习题）。&lt;/li&gt;
&lt;li&gt;政治：1 小时（后期增加至 2 小时）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;每周总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;周日上午复盘本周学习进度，调整下周计划。&lt;/li&gt;
&lt;li&gt;整理错题本，标注易错知识点。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;资源推荐&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;科目&lt;/th&gt;
&lt;th&gt;推荐资料&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;数学&lt;/td&gt;
&lt;td&gt;《张宇考研数学基础 30 讲》《李林考研数学 880 题》《历年真题详解》&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;英语&lt;/td&gt;
&lt;td&gt;《考研英语长难句解密》《考研英语高分写作》《黄皮书真题解析》&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;专业课&lt;/td&gt;
&lt;td&gt;《王道考研复习指导书》《天勤计算机考研高分笔记》《408 真题解析》&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;政治&lt;/td&gt;
&lt;td&gt;《肖秀荣精讲精练》《徐涛冲刺背诵笔记》《肖四肖八》&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content:encoded></item><item><title>Git工具-重置揭密</title><link>https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/110git%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86/</link><guid isPermaLink="true">https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/110git%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86/</guid><pubDate>Wed, 18 Nov 2020 17:43:57 GMT</pubDate><content:encoded>&lt;p&gt;在继续了解更专业的工具前，我们先探讨一下 Git 的 &lt;code&gt;reset&lt;/code&gt; 和 &lt;code&gt;checkout&lt;/code&gt; 命令。 在初遇的 Git 命令中，这两个是最让人困惑的。 它们能做很多事情，所以看起来我们很难真正地理解并恰当地运用它们。 针对这一点，我们先来做一个简单的比喻。&lt;/p&gt;
&lt;h2&gt;三棵树&lt;/h2&gt;
&lt;p&gt;理解 &lt;code&gt;reset&lt;/code&gt; 和 &lt;code&gt;checkout&lt;/code&gt; 的最简方法，就是以 Git 的思维框架（将其作为内容管理器）来管理三棵不同的树。 “树” 在我们这里的实际意思是 “文件的集合”，而不是指特定的数据结构。 （在某些情况下索引看起来并不像一棵树，不过我们现在的目的是用简单的方式思考它。）&lt;/p&gt;
&lt;p&gt;Git 作为一个系统，是以它的一般操作来管理并操纵这三棵树的：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;树&lt;/th&gt;
&lt;th&gt;用途&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;HEAD&lt;/td&gt;
&lt;td&gt;上一次提交的快照，下一次提交的父结点&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Index&lt;/td&gt;
&lt;td&gt;预期的下一次提交的快照&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Working Directory&lt;/td&gt;
&lt;td&gt;沙盒&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;HEAD&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;HEAD 是当前分支引用的指针，它总是指向该分支上的最后一次提交&lt;/strong&gt;。 这表示 HEAD 将是下一次提交的父结点。 通常，理解 HEAD 的最简方式，就是将它看做 &lt;strong&gt;该分支上的最后一次提交&lt;/strong&gt; 的快照。&lt;/p&gt;
&lt;p&gt;其实，查看快照的样子很容易。 下例就显示了 HEAD 快照实际的目录列表，以及其中每个文件的 SHA-1 校验和：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git cat-file -p HEAD
tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
author Scott Chacon  1301511835 -0700
committer Scott Chacon  1301511835 -0700

initial commit

$ git ls-tree -r HEAD
100644 blob a906cb2a4a904a152...   README
100644 blob 8f94139338f9404f2...   Rakefile
040000 tree 99f1a6d12cb4b6f19...   lib
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Git 的 &lt;code&gt;cat-file&lt;/code&gt; 和 &lt;code&gt;ls-tree&lt;/code&gt; 是底层命令，它们一般用于底层工作，在日常工作中并不使用。 不过它们能帮助我们了解到底发生了什么。&lt;/p&gt;
&lt;h3&gt;索引&lt;/h3&gt;
&lt;p&gt;索引是你的 &lt;strong&gt;预期的下一次提交&lt;/strong&gt;。 我们也会将这个概念引用为 Git 的“暂存区”，这就是当你运行 &lt;code&gt;git commit&lt;/code&gt; 时 Git 看起来的样子。&lt;/p&gt;
&lt;p&gt;Git 将上一次检出到工作目录中的所有文件填充到索引区，它们看起来就像最初被检出时的样子。 之后你会将其中一些文件替换为新版本，接着通过 &lt;code&gt;git commit&lt;/code&gt; 将它们转换为树来用作新的提交。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git ls-files -s
100644 a906cb2a4a904a152e80877d4088654daad0c859 0 README
100644 8f94139338f9404f26296befa88755fc2598c289 0 Rakefile
100644 47c6340d6459e05787f644c2447d2595f5d3a54b 0 lib/simplegit.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再说一次，我们在这里又用到了 &lt;code&gt;git ls-files&lt;/code&gt; 这个幕后的命令，它会显示出索引当前的样子。&lt;/p&gt;
&lt;p&gt;确切来说，索引在技术上并非树结构，它其实是以扁平的清单实现的。不过对我们而言，把它当做树就够了。&lt;/p&gt;
&lt;h3&gt;工作目录&lt;/h3&gt;
&lt;p&gt;最后，你就有了自己的 &lt;strong&gt;工作目录&lt;/strong&gt;（通常也叫 &lt;strong&gt;工作区&lt;/strong&gt;）。 另外两棵树以一种高效但并不直观的方式，将它们的内容存储在 &lt;code&gt;.git&lt;/code&gt; 文件夹中。 工作目录会将它们解包为实际的文件以便编辑。 你可以把工作目录当做 &lt;strong&gt;沙盒&lt;/strong&gt;。在你将修改提交到暂存区并记录到历史之前，可以随意更改。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ tree
.
├── README
├── Rakefile
└── lib
    └── simplegit.rb

1 directory, 3 files
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;工作流程&lt;/h2&gt;
&lt;p&gt;经典的 Git 工作流程是通过操纵这三个区域来以更加连续的状态记录项目快照的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/reset-workflow.png&quot; alt=&quot;reset workflow&quot; /&gt;&lt;/p&gt;
&lt;p&gt;让我们来可视化这个过程：假设我们进入到一个新目录，其中有一个文件。 我们称其为该文件的 &lt;strong&gt;v1&lt;/strong&gt; 版本，将它标记为蓝色。 现在运行 &lt;code&gt;git init&lt;/code&gt;，这会创建一个 Git 仓库，其中的 HEAD 引用指向未创建的 &lt;code&gt;master&lt;/code&gt; 分支。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/reset-ex1.png&quot; alt=&quot;reset ex1&quot; /&gt;&lt;/p&gt;
&lt;p&gt;此时，只有工作目录有内容。&lt;/p&gt;
&lt;p&gt;现在我们想要提交这个文件，所以用 &lt;code&gt;git add&lt;/code&gt; 来获取工作目录中的内容，并将其复制到索引中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/reset-ex2.png&quot; alt=&quot;reset ex2&quot; /&gt;&lt;/p&gt;
&lt;p&gt;接着运行 &lt;code&gt;git commit&lt;/code&gt;，它会取得索引中的内容并将它保存为一个永久的快照， 然后创建一个指向该快照的提交对象，最后更新 &lt;code&gt;master&lt;/code&gt; 来指向本次提交。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/reset-ex3.png&quot; alt=&quot;reset ex3&quot; /&gt;&lt;/p&gt;
&lt;p&gt;此时如果我们运行 &lt;code&gt;git status&lt;/code&gt;，会发现没有任何改动，因为现在三棵树完全相同。&lt;/p&gt;
&lt;p&gt;现在我们想要对文件进行修改然后提交它。 我们将会经历同样的过程；首先在工作目录中修改文件。 我们称其为该文件的 &lt;strong&gt;v2&lt;/strong&gt; 版本，并将它标记为红色。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/reset-ex4.png&quot; alt=&quot;reset ex4&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果现在运行 &lt;code&gt;git status&lt;/code&gt;，我们会看到文件显示在 “Changes not staged for commit” 下面并被标记为红色，因为该条目在索引与工作目录之间存在不同。 接着我们运行 &lt;code&gt;git add&lt;/code&gt; 来将它暂存到索引中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/reset-ex5.png&quot; alt=&quot;reset ex5&quot; /&gt;&lt;/p&gt;
&lt;p&gt;此时，由于索引和 HEAD 不同，若运行 &lt;code&gt;git status&lt;/code&gt; 的话就会看到 “Changes to be committed” 下的该文件变为绿色 ——也就是说，现在预期的下一次提交与上一次提交不同。 最后，我们运行 &lt;code&gt;git commit&lt;/code&gt; 来完成提交。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/reset-ex6.png&quot; alt=&quot;reset ex6&quot; /&gt;&lt;/p&gt;
&lt;p&gt;现在运行 &lt;code&gt;git status&lt;/code&gt; 会没有输出，因为三棵树又变得相同了。&lt;/p&gt;
&lt;p&gt;切换分支或克隆的过程也类似。 当检出一个分支时，它会修改 &lt;strong&gt;HEAD&lt;/strong&gt; 指向新的分支引用，将 &lt;strong&gt;索引&lt;/strong&gt; 填充为该次提交的快照， 然后将 &lt;strong&gt;索引&lt;/strong&gt; 的内容复制到 &lt;strong&gt;工作目录&lt;/strong&gt; 中。&lt;/p&gt;
&lt;h2&gt;重置的作用&lt;/h2&gt;
&lt;p&gt;在以下情景中观察 &lt;code&gt;reset&lt;/code&gt; 命令会更有意义。&lt;/p&gt;
&lt;p&gt;为了演示这些例子，假设我们再次修改了 &lt;code&gt;file.txt&lt;/code&gt; 文件并第三次提交它。 现在的历史看起来是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/reset-start.png&quot; alt=&quot;reset start&quot; /&gt;&lt;/p&gt;
&lt;p&gt;让我们跟着 &lt;code&gt;reset&lt;/code&gt; 看看它都做了什么。 它以一种简单可预见的方式直接操纵这三棵树。 它做了三个基本操作。&lt;/p&gt;
&lt;h3&gt;第 1 步：移动 HEAD&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;reset&lt;/code&gt; 做的第一件事是移动 HEAD 的指向。 这与改变 HEAD 自身不同（&lt;code&gt;checkout&lt;/code&gt; 所做的）；&lt;code&gt;reset&lt;/code&gt; 移动 HEAD 指向的分支。 这意味着如果 HEAD 设置为 &lt;code&gt;master&lt;/code&gt; 分支（例如，你正在 &lt;code&gt;master&lt;/code&gt; 分支上）， 运行 &lt;code&gt;git reset 9e5e6a4&lt;/code&gt; 将会使 &lt;code&gt;master&lt;/code&gt; 指向 &lt;code&gt;9e5e6a4&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/reset-soft.png&quot; alt=&quot;reset soft&quot; /&gt;&lt;/p&gt;
&lt;p&gt;无论你调用了何种形式的带有一个提交的 &lt;code&gt;reset&lt;/code&gt;，它首先都会尝试这样做。 使用 &lt;code&gt;reset --soft&lt;/code&gt;，它将仅仅停在那儿。&lt;/p&gt;
&lt;p&gt;现在看一眼上图，理解一下发生的事情：它本质上是撤销了上一次 &lt;code&gt;git commit&lt;/code&gt; 命令。 当你在运行 &lt;code&gt;git commit&lt;/code&gt; 时，Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。 当你将它 &lt;code&gt;reset&lt;/code&gt; 回 &lt;code&gt;HEAD~&lt;/code&gt;（HEAD 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。 现在你可以更新索引并再次运行 &lt;code&gt;git commit&lt;/code&gt; 来完成 &lt;code&gt;git commit --amend&lt;/code&gt; 所要做的事情了（见 &lt;a href=&quot;https://git-scm.com/book/zh/v2/ch00/_git_amend&quot;&gt;修改最后一次提交&lt;/a&gt;）。&lt;/p&gt;
&lt;h3&gt;第 2 步：更新索引（--mixed）&lt;/h3&gt;
&lt;p&gt;注意，如果你现在运行 &lt;code&gt;git status&lt;/code&gt; 的话，就会看到新的 HEAD 和以绿色标出的它和索引之间的区别。&lt;/p&gt;
&lt;p&gt;接下来，&lt;code&gt;reset&lt;/code&gt; 会用 HEAD 指向的当前快照的内容来更新索引。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/reset-mixed.png&quot; alt=&quot;reset mixed&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果指定 &lt;code&gt;--mixed&lt;/code&gt; 选项，&lt;code&gt;reset&lt;/code&gt; 将会在这时停止。 这也是默认行为，所以如果没有指定任何选项（在本例中只是 &lt;code&gt;git reset HEAD~&lt;/code&gt;），这就是命令将会停止的地方。&lt;/p&gt;
&lt;p&gt;现在再看一眼上图，理解一下发生的事情：它依然会撤销一上次 &lt;code&gt;提交&lt;/code&gt;，但还会 &lt;em&gt;取消暂存&lt;/em&gt; 所有的东西。 于是，我们回滚到了所有 &lt;code&gt;git add&lt;/code&gt; 和 &lt;code&gt;git commit&lt;/code&gt; 的命令执行之前。&lt;/p&gt;
&lt;h3&gt;第 3 步：更新工作目录（--hard）&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;reset&lt;/code&gt; 要做的的第三件事情就是让工作目录看起来像索引。 如果使用 &lt;code&gt;--hard&lt;/code&gt; 选项，它将会继续这一步。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/reset-hard.png&quot; alt=&quot;reset hard&quot; /&gt;&lt;/p&gt;
&lt;p&gt;现在让我们回想一下刚才发生的事情。 你撤销了最后的提交、&lt;code&gt;git add&lt;/code&gt; 和 &lt;code&gt;git commit&lt;/code&gt; 命令 &lt;strong&gt;以及&lt;/strong&gt; 工作目录中的所有工作。&lt;/p&gt;
&lt;p&gt;必须注意，&lt;code&gt;--hard&lt;/code&gt; 标记是 &lt;code&gt;reset&lt;/code&gt; 命令唯一的危险用法，它也是 Git 会真正地销毁数据的仅有的几个操作之一。 其他任何形式的 &lt;code&gt;reset&lt;/code&gt; 调用都可以轻松撤消，但是 &lt;code&gt;--hard&lt;/code&gt; 选项不能，因为它强制覆盖了工作目录中的文件。 在这种特殊情况下，我们的 Git 数据库中的一个提交内还留有该文件的 &lt;strong&gt;v3&lt;/strong&gt; 版本， 我们可以通过 &lt;code&gt;reflog&lt;/code&gt; 来找回它。但是若该文件还未提交，Git 仍会覆盖它从而导致无法恢复。&lt;/p&gt;
&lt;h3&gt;回顾&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;reset&lt;/code&gt; 命令会以特定的顺序重写这三棵树，在你指定以下选项时停止：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;移动 HEAD 分支的指向 &lt;em&gt;（若指定了 &lt;code&gt;--soft&lt;/code&gt;，则到此停止）&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;使索引看起来像 HEAD &lt;em&gt;（若未指定 &lt;code&gt;--hard&lt;/code&gt;，则到此停止）&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;使工作目录看起来像索引&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;通过路径来重置&lt;/h2&gt;
&lt;p&gt;前面讲述了 &lt;code&gt;reset&lt;/code&gt; 基本形式的行为，不过你还可以给它提供一个作用路径。 若指定了一个路径，&lt;code&gt;reset&lt;/code&gt; 将会跳过第 1 步，并且将它的作用范围限定为指定的文件或文件集合。 这样做自然有它的道理，因为 HEAD 只是一个指针，你无法让它同时指向两个提交中各自的一部分。 不过索引和工作目录 &lt;em&gt;可以部分更新&lt;/em&gt;，所以重置会继续进行第 2、3 步。&lt;/p&gt;
&lt;p&gt;现在，假如我们运行 &lt;code&gt;git reset file.txt&lt;/code&gt; （这其实是 &lt;code&gt;git reset --mixed HEAD file.txt&lt;/code&gt; 的简写形式，因为你既没有指定一个提交的 SHA-1 或分支，也没有指定 &lt;code&gt;--soft&lt;/code&gt; 或 &lt;code&gt;--hard&lt;/code&gt;），它会：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;移动 HEAD 分支的指向 &lt;em&gt;（已跳过）&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;让索引看起来像 HEAD &lt;em&gt;（到此处停止）&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以它本质上只是将 &lt;code&gt;file.txt&lt;/code&gt; 从 HEAD 复制到索引中。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/reset-path1.png&quot; alt=&quot;reset path1&quot; /&gt;&lt;/p&gt;
&lt;p&gt;它还有 &lt;em&gt;取消暂存文件&lt;/em&gt; 的实际效果。 如果我们查看该命令的示意图，然后再想想 &lt;code&gt;git add&lt;/code&gt; 所做的事，就会发现它们正好相反。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/reset-path2.png&quot; alt=&quot;reset path2&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这就是为什么 &lt;code&gt;git status&lt;/code&gt; 命令的输出会建议运行此命令来取消暂存一个文件。 （查看 &lt;a href=&quot;https://git-scm.com/book/zh/v2/ch00/_unstaging&quot;&gt;取消暂存的文件&lt;/a&gt; 来了解更多。）&lt;/p&gt;
&lt;p&gt;我们可以不让 Git 从 HEAD 拉取数据，而是通过具体指定一个提交来拉取该文件的对应版本。 我们只需运行类似于 &lt;code&gt;git reset eb43bf file.txt&lt;/code&gt; 的命令即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/reset-path3.png&quot; alt=&quot;reset path3&quot; /&gt;&lt;/p&gt;
&lt;p&gt;它其实做了同样的事情，也就是把工作目录中的文件恢复到 &lt;strong&gt;v1&lt;/strong&gt; 版本，运行 &lt;code&gt;git add&lt;/code&gt; 添加它， 然后再将它恢复到 &lt;strong&gt;v3&lt;/strong&gt; 版本（只是不用真的过一遍这些步骤）。 如果我们现在运行 &lt;code&gt;git commit&lt;/code&gt;，它就会记录一条“将该文件恢复到 &lt;strong&gt;v1&lt;/strong&gt; 版本”的更改， 尽管我们并未在工作目录中真正地再次拥有它。&lt;/p&gt;
&lt;p&gt;还有一点同 &lt;code&gt;git add&lt;/code&gt; 一样，就是 &lt;code&gt;reset&lt;/code&gt; 命令也可以接受一个 &lt;code&gt;--patch&lt;/code&gt; 选项来一块一块地取消暂存的内容。 这样你就可以根据选择来取消暂存或恢复内容了。&lt;/p&gt;
&lt;h2&gt;压缩&lt;/h2&gt;
&lt;p&gt;我们来看看如何利用这种新的功能来做一些有趣的事情——压缩提交。&lt;/p&gt;
&lt;p&gt;假设你的一系列提交信息中有 “oops.”“WIP” 和 “forgot this file”， 聪明的你就能使用 &lt;code&gt;reset&lt;/code&gt; 来轻松快速地将它们压缩成单个提交，也显出你的聪明。 （&lt;a href=&quot;https://git-scm.com/book/zh/v2/ch00/_squashing&quot;&gt;压缩提交&lt;/a&gt; 展示了另一种方式，不过在本例中用 &lt;code&gt;reset&lt;/code&gt; 更简单。）&lt;/p&gt;
&lt;p&gt;假设你有一个项目，第一次提交中有一个文件，第二次提交增加了一个新的文件并修改了第一个文件，第三次提交再次修改了第一个文件。 由于第二次提交是一个未完成的工作，因此你想要压缩它。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/reset-squash-r1.png&quot; alt=&quot;reset squash r1&quot; /&gt;&lt;/p&gt;
&lt;p&gt;那么可以运行 &lt;code&gt;git reset --soft HEAD~2&lt;/code&gt; 来将 HEAD 分支移动到一个旧一点的提交上（即你想要保留的最近的提交）：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/reset-squash-r2.png&quot; alt=&quot;reset squash r2&quot; /&gt;&lt;/p&gt;
&lt;p&gt;然后只需再次运行 &lt;code&gt;git commit&lt;/code&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/reset-squash-r3.png&quot; alt=&quot;reset squash r3&quot; /&gt;&lt;/p&gt;
&lt;p&gt;现在你可以查看可到达的历史，即将会推送的历史，现在看起来有个 v1 版 &lt;code&gt;file-a.txt&lt;/code&gt; 的提交， 接着第二个提交将 &lt;code&gt;file-a.txt&lt;/code&gt; 修改成了 v3 版并增加了 &lt;code&gt;file-b.txt&lt;/code&gt;。 包含 v2 版本的文件已经不在历史中了。&lt;/p&gt;
&lt;h2&gt;检出&lt;/h2&gt;
&lt;p&gt;最后，你大概还想知道 &lt;code&gt;checkout&lt;/code&gt; 和 &lt;code&gt;reset&lt;/code&gt; 之间的区别。 和 &lt;code&gt;reset&lt;/code&gt; 一样，&lt;code&gt;checkout&lt;/code&gt; 也操纵三棵树，不过它有一点不同，这取决于你是否传给该命令一个文件路径。&lt;/p&gt;
&lt;h3&gt;不带路径&lt;/h3&gt;
&lt;p&gt;运行 &lt;code&gt;git checkout [branch]&lt;/code&gt; 与运行 &lt;code&gt;git reset --hard [branch]&lt;/code&gt; 非常相似，它会更新所有三棵树使其看起来像 &lt;code&gt;[branch]&lt;/code&gt;，不过有两点重要的区别。&lt;/p&gt;
&lt;p&gt;首先不同于 &lt;code&gt;reset --hard&lt;/code&gt;，&lt;code&gt;checkout&lt;/code&gt; 对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。 其实它还更聪明一些。它会在工作目录中先试着简单合并一下，这样所有_还未修改过的_文件都会被更新。 而 &lt;code&gt;reset --hard&lt;/code&gt; 则会不做检查就全面地替换所有东西。&lt;/p&gt;
&lt;p&gt;第二个重要的区别是 &lt;code&gt;checkout&lt;/code&gt; 如何更新 HEAD。 &lt;code&gt;reset&lt;/code&gt; 会移动 HEAD 分支的指向，而 &lt;code&gt;checkout&lt;/code&gt; 只会移动 HEAD 自身来指向另一个分支。&lt;/p&gt;
&lt;p&gt;例如，假设我们有 &lt;code&gt;master&lt;/code&gt; 和 &lt;code&gt;develop&lt;/code&gt; 分支，它们分别指向不同的提交；我们现在在 &lt;code&gt;develop&lt;/code&gt; 上（所以 HEAD 指向它）。 如果我们运行 &lt;code&gt;git reset master&lt;/code&gt;，那么 &lt;code&gt;develop&lt;/code&gt; 自身现在会和 &lt;code&gt;master&lt;/code&gt; 指向同一个提交。 而如果我们运行 &lt;code&gt;git checkout master&lt;/code&gt; 的话，&lt;code&gt;develop&lt;/code&gt; 不会移动，HEAD 自身会移动。 现在 HEAD 将会指向 &lt;code&gt;master&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;所以，虽然在这两种情况下我们都移动 HEAD 使其指向了提交 A，但_做法_是非常不同的。 &lt;code&gt;reset&lt;/code&gt; 会移动 HEAD 分支的指向，而 &lt;code&gt;checkout&lt;/code&gt; 则移动 HEAD 自身。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/reset-checkout.png&quot; alt=&quot;reset checkout&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;带路径&lt;/h3&gt;
&lt;p&gt;运行 &lt;code&gt;checkout&lt;/code&gt; 的另一种方式就是指定一个文件路径，这会像 &lt;code&gt;reset&lt;/code&gt; 一样不会移动 HEAD。 它就像 &lt;code&gt;git reset [branch] file&lt;/code&gt; 那样用该次提交中的那个文件来更新索引，但是它也会覆盖工作目录中对应的文件。 它就像是 &lt;code&gt;git reset --hard [branch] file&lt;/code&gt;（如果 &lt;code&gt;reset&lt;/code&gt; 允许你这样运行的话）， 这样对工作目录并不安全，它也不会移动 HEAD。&lt;/p&gt;
&lt;p&gt;此外，同 &lt;code&gt;git reset&lt;/code&gt; 和 &lt;code&gt;git add&lt;/code&gt; 一样，&lt;code&gt;checkout&lt;/code&gt; 也接受一个 &lt;code&gt;--patch&lt;/code&gt; 选项，允许你根据选择一块一块地恢复文件内容。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;希望你现在熟悉并理解了 &lt;code&gt;reset&lt;/code&gt; 命令，不过关于它和 &lt;code&gt;checkout&lt;/code&gt; 之间的区别，你可能还是会有点困惑，毕竟不太可能记住不同调用的所有规则。&lt;/p&gt;
&lt;p&gt;下面的速查表列出了命令对树的影响。 “HEAD” 一列中的 “REF” 表示该命令移动了 HEAD 指向的分支引用，而 “HEAD” 则表示只移动了 HEAD 自身。 特别注意 &lt;em&gt;WD Safe?&lt;/em&gt; 一列——如果它标记为 &lt;strong&gt;NO&lt;/strong&gt;，那么运行该命令之前请考虑一下。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;HEAD&lt;/th&gt;
&lt;th&gt;Index&lt;/th&gt;
&lt;th&gt;Workdir&lt;/th&gt;
&lt;th&gt;WD Safe?&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Commit Level&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;reset --soft [commit]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;REF&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;reset [commit]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;REF&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;reset --hard [commit]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;REF&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;NO&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;checkout &amp;lt;commit&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;HEAD&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;File Level&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;reset [commit] &amp;lt;paths&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;checkout [commit] &amp;lt;paths&amp;gt;&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;YES&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;NO&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content:encoded></item><item><title>Git分支管理-查看分支</title><link>https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/40git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86-%E6%9F%A5%E7%9C%8B%E5%88%86%E6%94%AF/</link><guid isPermaLink="true">https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/40git%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86-%E6%9F%A5%E7%9C%8B%E5%88%86%E6%94%AF/</guid><pubDate>Wed, 18 Nov 2020 17:43:57 GMT</pubDate><content:encoded>&lt;h3&gt;查看分支&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ git branch
  iss53
* master  # 带星号*表示当前所在分支
  testing
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;git branch&lt;/code&gt; 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表。&lt;/p&gt;
&lt;h3&gt;查看每个分支的最后提交&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ git branch -v
  iss53   93b412c fix javascript issue
* master  7a98805 Merge branch &apos;iss53&apos;
  testing 782fd34 test
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;查看已(未)合并的分支&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;--merged&lt;/code&gt; 与 &lt;code&gt;--no-merged&lt;/code&gt; 这两个选项可以查看哪些分支已经合并或未合并到 &lt;strong&gt;当前&lt;/strong&gt; 分支。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git branch --merged # 查看已合并分支列表
  iss53
* master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面列表中分支名字前没有 &lt;code&gt;*&lt;/code&gt; 号的分支通常可以使用 &lt;code&gt;git branch -d&lt;/code&gt; 删除掉；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git branch --no-merged # 查看未合并的分支列表
  testing
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面显示未合并的分支，尝试使用 &lt;code&gt;git branch -d&lt;/code&gt; 命令删除它时会失败：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git branch -d testing
error: The branch &apos;testing&apos; is not fully merged.
If you are sure you want to delete it, run &apos;git branch -D testing&apos;.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;强制删除未合并的分支:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git branch -D testing
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;查看指定分支的已(未)合并的分支&lt;/h4&gt;
&lt;p&gt;上面描述的选项 &lt;code&gt;--merged&lt;/code&gt; 和 &lt;code&gt;--no-merged&lt;/code&gt; 会在没有给定提交或分支名作为参数时， 分别列出已合并或未合并到 &lt;strong&gt;当前&lt;/strong&gt; 分支的分支。&lt;/p&gt;
&lt;p&gt;你总是可以提供一个附加的参数来查看其它分支的合并状态而不必检出它们。 例如，尚未合并到 &lt;code&gt;testing&lt;/code&gt; 分支的有哪些？&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git branch --no-merged testing
  topicA
  featureB
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Git分支-分支原理</title><link>https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/20git%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E5%8E%9F%E7%90%86/</link><guid isPermaLink="true">https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/20git%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E5%8E%9F%E7%90%86/</guid><pubDate>Wed, 18 Nov 2020 17:43:57 GMT</pubDate><content:encoded>&lt;p&gt;Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。 与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。&lt;/p&gt;
&lt;h3&gt;首次提交&lt;/h3&gt;
&lt;p&gt;在进行提交操作时，Git 会保存一个提交对象（commit object）。&lt;/p&gt;
&lt;p&gt;假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。 暂存操作会为每一个文件计算校验和（使用 SHA-1 哈希算法），然后会把当前版本的文件快照保存到 Git 仓库中 （Git 使用 &lt;em&gt;blob&lt;/em&gt; 对象来保存它们），最终将校验和加入到暂存区域等待提交：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git add README test.rb LICENSE
git commit -m &apos;The initial commit of my project&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当使用 &lt;code&gt;git commit&lt;/code&gt; 进行提交操作时，Git 会先计算每一个子目录（本例中只有项目根目录）的校验和， 然后在 Git 仓库中这些校验和保存为树对象。随后，Git 便会创建一个提交对象， 它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。 如此一来，Git 就可以在需要的时候重现此次保存的快照。&lt;/p&gt;
&lt;p&gt;现在，Git 仓库中有五个对象：三个 &lt;strong&gt;&lt;em&gt;blob&lt;/em&gt; 对象&lt;/strong&gt;（保存着文件快照）、一个 &lt;strong&gt;树对象&lt;/strong&gt; （记录着目录结构和 blob 对象索引）以及一个 &lt;strong&gt;提交对象&lt;/strong&gt;（包含着指向前述树对象的指针和所有提交信息）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200906145443.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&apos;center&apos;&amp;gt;图1. 首次提交对象及其树结构 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;h4&gt;小结&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git add&lt;/code&gt; 加入暂存操作，会为每个文件创建计算校验和，以及每个文件对应的&lt;strong&gt;文件快照（blob对象&lt;/strong&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;git commit&lt;/code&gt; 提交操作，计算子目录或跟目录的校验和 保存为&lt;strong&gt;树对象&lt;/strong&gt;。随后，创建一个&lt;strong&gt;提交对象&lt;/strong&gt;，包含着指向树对象的指针和所有提交信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;再次提交&lt;/h3&gt;
&lt;p&gt;做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200906152315.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&apos;center&apos;&amp;gt;图2. 提交对象及其父对象 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;h3&gt;Git 的分支&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Git 的分支，其实本质上仅仅是指向提交对象的可变指针&lt;/strong&gt;。 Git 的默认分支名字是 &lt;code&gt;master&lt;/code&gt;。 在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 &lt;code&gt;master&lt;/code&gt; 分支。 &lt;strong&gt;&lt;code&gt;master&lt;/code&gt; 分支指针会在每次提交时自动向前移动&lt;/strong&gt;。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Git 的 &lt;code&gt;master&lt;/code&gt; 分支并不是一个特殊分支。 它就跟其它分支完全没有区别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200906154109.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&apos;center&apos;&amp;gt;图3. 分支及其提交历史 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;h3&gt;创建分支&lt;/h3&gt;
&lt;p&gt;Git 是怎么创建新分支的呢？ 很简单，它&lt;strong&gt;只是为你创建了一个可以移动的新的指针&lt;/strong&gt;。 比如，创建一个 testing 分支， 你需要使用 &lt;code&gt;git branch&lt;/code&gt; 命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git branch testing
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这会在当前所在的提交对象上创建一个指针。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200906154330.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&apos;center&apos;&amp;gt;图4. 两个指向相同提交历史的分支 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;h3&gt;当前分支的指针&lt;/h3&gt;
&lt;p&gt;Git 是怎么知道当前在哪一个分支上呢？ 很简单，它有一个&lt;strong&gt;名为 &lt;code&gt;HEAD&lt;/code&gt; 的特殊指针&lt;/strong&gt;，&lt;strong&gt;指向当前所在的本地分支&lt;/strong&gt;（译注：&lt;strong&gt;将 &lt;code&gt;HEAD&lt;/code&gt; 想象为当前分支的别名&lt;/strong&gt;）。 在本例中，你仍然在 &lt;code&gt;master&lt;/code&gt; 分支上。 因为 &lt;code&gt;git branch&lt;/code&gt; 命令仅仅 &lt;strong&gt;创建&lt;/strong&gt; 一个新分支，并不会自动切换到新分支中去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200906205325.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&apos;center&apos;&amp;gt;图5. HEAD 指向当前所在的分支 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;h3&gt;查看当前所在分支&lt;/h3&gt;
&lt;p&gt;你可以简单地使用 &lt;code&gt;git log&lt;/code&gt; 命令查看各个分支当前所指的对象。 提供这一功能的参数是 &lt;code&gt;--decorate&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log --oneline --decorate
f30ab (HEAD -&amp;gt; master, testing) add feature # f30ab提交对象 (HEAD当前所在分支 -&amp;gt; master分支，testing 分支)
34ac2 Fixed bug # 34ac2 提交对象
98ca9 The initial commit of my project # 98ca9 提交对象
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;正如你所见，当前 &lt;code&gt;master&lt;/code&gt; 和 &lt;code&gt;testing&lt;/code&gt; 分支均指向校验和以 &lt;code&gt;f30ab&lt;/code&gt; 开头的提交对象。&lt;/p&gt;
&lt;h3&gt;分支切换&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git checkout testing  # git checkout &amp;lt;分支名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样 &lt;code&gt;HEAD&lt;/code&gt; 就指向 &lt;code&gt;testing&lt;/code&gt; 分支了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200906205917.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&apos;center&apos;&amp;gt;图6. HEAD 指向当前所在的分支 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;那么，这样的实现方式会给我们带来什么好处呢？ 现在不妨再提交一次：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim test.rb
git commit -a -m &apos;made a change&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200906210338.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&apos;center&apos;&amp;gt;图7. HEAD 分支随着提交操作自动向前移动 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;如图所示，你的 &lt;code&gt;testing&lt;/code&gt; 分支向前移动了，但是 &lt;code&gt;master&lt;/code&gt; 分支却没有，它仍然指向运行 &lt;code&gt;git checkout&lt;/code&gt; 时所指的对象。 这就有意思了，现在我们切换回 &lt;code&gt;master&lt;/code&gt; 分支看看：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200906210810.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&apos;center&apos;&amp;gt;图8. 检出时 HEAD 随之移动 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;这条命令&lt;strong&gt;做了两件事&lt;/strong&gt;。 &lt;strong&gt;一是使 HEAD 指回 &lt;code&gt;master&lt;/code&gt; 分支，二是将工作目录恢复成 &lt;code&gt;master&lt;/code&gt; 分支所指向的快照内容&lt;/strong&gt;。 也就是说，你现在做修改的话，项目将始于一个较旧的版本。 本质上来讲，这就是忽略 &lt;code&gt;testing&lt;/code&gt; 分支所做的修改，以便于向另一个方向进行开发。&lt;/p&gt;
&lt;p&gt;我们不妨再稍微做些修改并提交：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;vim test.rb
git commit -a -m &apos;made other changes&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，这个项目的提交历史已经产生了分叉（参见 &lt;a href=&quot;https://git-scm.com/book/zh/v2/ch00/divergent_history&quot;&gt;项目分叉历史&lt;/a&gt;）。 因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回 master 分支进行了另外一些工作。 上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 &lt;code&gt;branch&lt;/code&gt;、&lt;code&gt;checkout&lt;/code&gt; 和 &lt;code&gt;commit&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200906211331.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&apos;center&apos;&amp;gt;图9. 项目分叉历史 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;你可以简单地使用 &lt;code&gt;git log&lt;/code&gt; 命令查看分叉历史。 运行 &lt;code&gt;git log --oneline --decorate --graph --all&lt;/code&gt; ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log --oneline --decorate --graph --all
* c2b9e (HEAD, master) made other changes
| * 87ab2 (testing) made a change
|/
* f30ab add feature
* 34ac2 fixed bug
* 98ca9 initial commit of my project
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？&lt;/p&gt;
&lt;p&gt;这与过去大多数版本控制系统形成了鲜明的对比，它们在创建分支时，将所有的项目文件都复制一遍，并保存到一个特定的目录。 完成这样繁琐的过程通常需要好几秒钟，有时甚至需要好几分钟。所需时间的长短，完全取决于项目的规模。 而在 Git 中，任何规模的项目都能在瞬间创建新分支。 同时，由于每次提交都会记录父对象，所以寻找恰当的合并基础（译注：即共同祖先）也是同样的简单和高效。 这些高效的特性使得 Git 鼓励开发人员频繁地创建和使用分支。&lt;/p&gt;
&lt;h3&gt;创建分支同时切换&lt;/h3&gt;
&lt;p&gt;通常我们会在创建一个新分支后立即切换过去，可以使用如下命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b &amp;lt;newbranchname&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>常用Git命令清单</title><link>https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%89%8B%E5%86%8C/00%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/</link><guid isPermaLink="true">https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%89%8B%E5%86%8C/00%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/</guid><pubDate>Wed, 18 Nov 2020 17:43:57 GMT</pubDate><content:encoded>&lt;p&gt;一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Workspace：工作区&lt;/li&gt;
&lt;li&gt;Index / Stage：暂存区&lt;/li&gt;
&lt;li&gt;Repository：仓库区（或本地仓库）&lt;/li&gt;
&lt;li&gt;Remote：远程仓库&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;一、新建代码库&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 在当前目录新建一个Git代码库
$ git init

# 新建一个目录，将其初始化为Git代码库
$ git init [project-name]

# 下载一个项目和它的整个代码历史
$ git clone [url]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;二、配置&lt;/h2&gt;
&lt;p&gt;Git的设置文件为&lt;code&gt;.gitconfig&lt;/code&gt;，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 显示当前的Git配置
$ git config --list

# 编辑Git配置文件
$ git config -e [--global]

# 设置提交代码时的用户信息
$ git config [--global] user.name &quot;[name]&quot;
$ git config [--global] user.email &quot;[email address]&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;三、增加/删除文件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 添加指定文件到暂存区
$ git add [file1] [file2] ...

# 添加指定目录到暂存区，包括子目录
$ git add [dir]

# 添加当前目录的所有文件到暂存区
$ git add .

# 添加每个变化前，都会要求确认
# 对于同一个文件的多处变化，可以实现分次提交
$ git add -p

# 删除工作区文件，并且将这次删除放入暂存区
$ git rm [file1] [file2] ...

# 停止追踪指定文件，但该文件会保留在工作区
$ git rm --cached [file]

# 改名文件，并且将这个改名放入暂存区
$ git mv [file-original] [file-renamed]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;四、代码提交&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 提交暂存区到仓库区
$ git commit -m [message]

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;五、分支&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 切换到上一个分支
$ git checkout -

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;六、标签&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 列出所有tag
$ git tag

# 新建一个tag在当前commit
$ git tag [tag]

# 新建一个tag在指定commit
$ git tag [tag] [commit]

# 删除本地tag
$ git tag -d [tag]

# 删除远程tag
$ git push origin :refs/tags/[tagName]

# 查看tag信息
$ git show [tag]

# 提交指定tag
$ git push [remote] [tag]

# 提交所有tag
$ git push [remote] --tags

# 新建一个分支，指向某个tag
$ git checkout -b [branch] [tag]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;七、查看信息&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 搜索提交历史，根据关键词
$ git log -S [keyword]

# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s

# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件
$ git log [tag] HEAD --grep feature

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# 显示指定文件相关的每一次diff
$ git log -p [file]

# 显示过去5次提交
$ git log -5 --pretty --oneline

# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn

# 显示指定文件是什么人在什么时间修改过
$ git blame [file]

# 显示暂存区和工作区的差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [file]

# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

# 显示今天你写了多少行代码
$ git diff --shortstat &quot;@{0 day ago}&quot;

# 显示某次提交的元数据和内容变化
$ git show [commit]

# 显示某次提交发生变化的文件
$ git show --name-only [commit]

# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

# 显示当前分支的最近几次提交
$ git reflog
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;八、远程同步&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 下载远程仓库的所有变动
$ git fetch [remote]

# 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote]

# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

# 上传本地指定分支到远程仓库
$ git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;九、撤销&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]

# 恢复暂存区的所有文件到工作区
$ git checkout .

# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]

# 暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;十、常用操作组合&lt;/h2&gt;
&lt;h3&gt;1. 修改本地分支名和远程分支名&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git branch -m old_branch new_branch # 重命名本地分支
git push origin :old_branch # 删除远程旧分支（分支名前有冒号）
git push --set-upstream origin new_branch # 推送新的分支，并设置本地分支跟踪新的远程分支
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;相关文章：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2019/12/git-undo.html&quot;&gt;《如何撤销 Git 操作？》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html&quot;&gt;《git cherry-pick 教程》&lt;/a&gt; 复制某分支上的部分提交到另一个分支上（相对于可以选择指定提交的 rebase 操作）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;命令清单来源：&lt;a href=&quot;https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html&quot;&gt;https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded></item><item><title>Git变基合并</title><link>https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%89%8B%E5%86%8C/03git%E5%8F%98%E5%9F%BA%E5%90%88%E5%B9%B6/</link><guid isPermaLink="true">https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%89%8B%E5%86%8C/03git%E5%8F%98%E5%9F%BA%E5%90%88%E5%B9%B6/</guid><pubDate>Wed, 18 Nov 2020 17:43:57 GMT</pubDate><content:encoded>&lt;h2&gt;说明&lt;/h2&gt;
&lt;p&gt;以下 &lt;code&gt;v2&lt;/code&gt; 是某个需求的开发分支， &lt;code&gt;dev&lt;/code&gt;是总的开发分支，&lt;code&gt;v2&lt;/code&gt; 是基于&lt;code&gt;dev&lt;/code&gt;分支签出的。&lt;/p&gt;
&lt;p&gt;当完成&lt;code&gt;v2&lt;/code&gt;的开发后，需要把代码合并到&lt;code&gt;dev&lt;/code&gt;，我们可以使用&lt;code&gt;rebase&lt;/code&gt;进行合并：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 首先将 v2 push到远程仓库
git add .
git commit -m &apos;xxx&apos;
git push origin v2

# 切换到 dev 拉取最新代码
git checkout dev
git pull origin dev

# 切换到 v2
git checkout v2
git rebase dev # 将 v2 的所有[commit] 变基到(应用到) dev

# 切换到 dev
git checkout dev
git merge v2  # 将 dev分支 快进合并 （此时 (HEAD -&amp;gt; dev, v2) [commit] 两个分支指向同一个提交）

# 查看 原v2的[commit]记录 是否在dev分支的最前面（变基成功会把v2的提交记录应用到dev分支的最前面）
git log

 # 如果到这一步发现有问题，尝试使用 git --abort中止变基，如果还是有问题的可以在dev分支上使用《后悔药》操作， 再到v2分支上使用《后悔药》操作，即可使两个分支都回退到 rebase变基 之前的状态

# 试运行项目是否有问题
yarn start

git status # 查看状态是否有问题
git push origin dev # 推送到远程仓库的 dev

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;变基要遵守的准则&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;几个人同时在一个分支上进行开发和提交时，开发中途请不要私自执行变基，只有在大家都完成工作之后才可以执行变基。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;变基的实质&lt;/h3&gt;
&lt;p&gt;变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。
因此，&lt;strong&gt;变基操作过后的分支将不要再使用&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;后悔药&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 查看HEAD指针变动记录
git reflog
# 记录示例(当前分支是v2):
07c398f (HEAD -&amp;gt; v2, master) HEAD@{0}: checkout: moving from master to v2
07c398f (HEAD -&amp;gt; v2, master) HEAD@{1}: rebase (finish): returning to refs/heads/master
07c398f (HEAD -&amp;gt; v2, master) HEAD@{2}: rebase (start): checkout v2
15a97d8 HEAD@{3}: reset: moving to 15a97d8
07c398f (HEAD -&amp;gt; v2, master) HEAD@{4}: merge v2: Fast-forward
15a97d8 HEAD@{5}: checkout: moving from v2 to master
07c398f (HEAD -&amp;gt; v2, master) HEAD@{6}: rebase (finish): returning to refs/heads/v2
07c398f (HEAD -&amp;gt; v2, master) HEAD@{7}: rebase (pick): C
15a97d8 HEAD@{8}: rebase (start): checkout master # 首次rebase
d278ecd HEAD@{9}: checkout: moving from master to v2 # rebase前的状态
15a97d8 HEAD@{10}: commit: D

# 可见，示例中最初的 rebase 操作是 HEAD@{8}，想回退到变基前的状态需让指针指向 HEAD@{9}
git reset --hard d278ecd  # 重置当前分支的HEAD为指定[commit]，同时重置暂存区和工作区，与指定[commit]一致

# 此时打印 log 查看是否回到之前的状态
git log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：此操作只能回退当前的分支，如其他分支也要回退，需要切换到该分支并执行上面操作。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;开发期间的rebase操作&lt;/h2&gt;
&lt;h3&gt;背景&lt;/h3&gt;
&lt;p&gt;有两个分支：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dev
*v2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;v2&lt;/code&gt; 是基于&lt;code&gt;dev&lt;/code&gt;切出来的。&lt;/p&gt;
&lt;p&gt;提交记录如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  dev
a - b - c
  v2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;开发期间，两个分支同时有新的commit ：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    dev
a - b - c - d - e
  \ - f - g
    v2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当前你正在&lt;code&gt;v2&lt;/code&gt;进行开发，&lt;code&gt;dev&lt;/code&gt;也同时进行开发，并有重大的改变，你需要把&lt;code&gt;dev&lt;/code&gt;的提交同步到&lt;code&gt;v2&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需求： 把&lt;code&gt;dev&lt;/code&gt;中新的提交同步到&lt;code&gt;v2&lt;/code&gt;，且不能影响&lt;code&gt;dev&lt;/code&gt;分支。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;操作步骤&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基于最新的 &lt;code&gt;dev&lt;/code&gt; 切一个新的分支 &lt;code&gt;dev-copy&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;dev-copy&lt;/code&gt; 和 &lt;code&gt;dev&lt;/code&gt;  两者的 commit ID 一致。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在&lt;code&gt;dev-copy&lt;/code&gt;中执行rebase，将 &lt;code&gt;dev-copy&lt;/code&gt; 的提交变基到 &lt;code&gt;v2&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git rebase v2 # 将 dev-copy 的提交[commit] 变基到(应用到) v2
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除原&lt;code&gt;v2&lt;/code&gt;分支，将&lt;code&gt;dev-copy&lt;/code&gt;分支名改为&lt;code&gt;v2&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 当前在 dev-copy 分支
git branch -d v2 # 删除分支
git branch -m dev-copy v2 # 重命名
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;git cherry-pick&lt;/h2&gt;
&lt;p&gt;来源：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html&quot;&gt;《git cherry-pick 教程》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用于将单个或几个&lt;code&gt;[commit]&lt;/code&gt;复制到另一个分支。&lt;/p&gt;
&lt;h3&gt;基本应用&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git cherry-pick &amp;lt;commitHash&amp;gt; # 将commitHash应用于当前分支
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面命令就会将指定的提交&lt;code&gt;commitHash&lt;/code&gt;，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的&lt;strong&gt;哈希值会不一样&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;git cherry-pick命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。&lt;/p&gt;
&lt;h3&gt;转移多个提交&lt;/h3&gt;
&lt;p&gt;Cherry pick 支持一次转移多个提交。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git cherry-pick &amp;lt;HashA&amp;gt; &amp;lt;HashB&amp;gt; # A和B提交
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的命令将 A 和 B 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。&lt;/p&gt;
&lt;p&gt;如果想要转移一系列的连续提交，可以使用下面的简便语法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git cherry-pick A..B # A到B提交，不包含A
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的命令可以转移从 A 到 B 的所有提交。它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意，使用上面的命令，提交 A 将不会包含在 Cherry pick 中。如果要包含提交 A，可以使用下面的语法。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git cherry-pick A^..B # A到B提交，包含A
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Git工具-重写历史</title><link>https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/100git%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2/</link><guid isPermaLink="true">https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/100git%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2/</guid><pubDate>Wed, 18 Nov 2020 17:43:57 GMT</pubDate><content:encoded>&lt;p&gt;许多时候，在使用 Git 时，你可能想要修订提交历史。 Git 很棒的一点是它允许你在最后时刻做决定。 你可以在将暂存区内容提交前决定哪些文件进入提交，可以通过 &lt;code&gt;git stash&lt;/code&gt; 来决定不与某些内容工作， 也可以重写已经发生的提交就像它们以另一种方式发生的一样。 这可能涉及改变提交的顺序，改变提交中的信息或修改文件，将提交压缩或是拆分， 或完全地移除提交——在将你的工作成果与他人共享之前。&lt;/p&gt;
&lt;p&gt;在本节中，你可以学到如何完成这些工作，这样在与他人分享你的工作成果时你的提交历史将如你所愿地展示出来。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Note&lt;/th&gt;
&lt;th&gt;在满意之前不要推送你的工作Git 的基本原则之一是，由于克隆中有很多工作是本地的，因此你可以 &lt;strong&gt;在本地&lt;/strong&gt; 随便重写历史记录。 然而一旦推送了你的工作，那就完全是另一回事了，除非你有充分的理由进行更改，否则应该将推送的工作视为最终结果。 简而言之，在对它感到满意并准备与他人分享之前，应当避免推送你的工作。&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;修改最后一次提交&lt;/h2&gt;
&lt;p&gt;修改你最近一次提交可能是所有修改历史提交的操作中最常见的一个。 对于你的最近一次提交，你往往想做两件事情：简单地修改提交信息， 或者通过添加、移除或修改文件来更改提交实际的内容。&lt;/p&gt;
&lt;h3&gt;修改提交信息&lt;/h3&gt;
&lt;p&gt;如果，你只是想修改最近一次提交的提交信息，那么很简单：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git commit --amend
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面这条命令会将最后一次的提交信息载入到编辑器中供你修改。 当保存并关闭编辑器后，编辑器会将更新后的提交信息写入新提交中，它会成为新的最后一次提交。&lt;/p&gt;
&lt;h3&gt;修改实际内容&lt;/h3&gt;
&lt;p&gt;另一方面，如果你想要修改最后一次提交的实际内容，那么流程很相似：首先作出你想要补上的修改， 暂存它们，然后用 &lt;code&gt;git commit --amend&lt;/code&gt; 以新的改进后的提交来 &lt;strong&gt;替换&lt;/strong&gt; 掉旧有的最后一次提交，&lt;/p&gt;
&lt;p&gt;使用这个技巧的时候需要小心，因为修正会改变提交的 SHA-1 校验和。 它类似于一个小的变基——&lt;strong&gt;如果已经推送了最后一次提交就不要修正它&lt;/strong&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Tip&lt;/th&gt;
&lt;th&gt;修补后的提交可能需要修补提交信息当你在修补一次提交时，可以同时修改提交信息和提交内容。 如果你修补了提交的内容，那么几乎肯定要更新提交消息以反映修改后的内容。另一方面，如果你的修补是琐碎的（如修改了一个笔误或添加了一个忘记暂存的文件）， 那么之前的提交信息不必修改，你只需作出更改，暂存它们，然后通过以下命令避免不必要的编辑器环节即可：&lt;code&gt;$ git commit --amend --no-edit&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;修改多个提交信息&lt;/h2&gt;
&lt;p&gt;为了修改在提交历史中较远的提交，必须使用更复杂的工具。 Git 没有一个改变历史工具，但是可以使用变基工具来变基一系列提交，基于它们原来的 HEAD 而不是将其移动到另一个新的上面。 通过交互式变基工具，可以在任何想要修改的提交后停止，然后修改信息、添加文件或做任何想做的事情。 可以通过给 &lt;code&gt;git rebase&lt;/code&gt; 增加 &lt;code&gt;-i&lt;/code&gt; 选项来交互式地运行变基。 必须指定想要重写多久远的历史，这可以通过告诉命令将要变基到的提交来做到。&lt;/p&gt;
&lt;p&gt;例如，如果想要修改最近三次提交信息，或者那组提交中的任意一个提交信息， 将想要修改的最近一次提交的父提交作为参数传递给 &lt;code&gt;git rebase -i&lt;/code&gt; 命令，即 &lt;code&gt;HEAD~2^&lt;/code&gt; 或 &lt;code&gt;HEAD~3&lt;/code&gt;。 记住 &lt;code&gt;~3&lt;/code&gt; 可能比较容易，因为你正尝试修改最后三次提交；但是注意实际上指定了以前的四次提交，即想要修改提交的父提交：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git rebase -i HEAD~3
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再次记住这是一个变基命令——在 &lt;code&gt;HEAD~3..HEAD&lt;/code&gt; 范围内的每一个修改了提交信息的提交及其 &lt;strong&gt;所有后裔&lt;/strong&gt; 都会被重写。 不要涉及任何已经推送到中央服务器的提交——这样做会产生一次变更的两个版本，因而使他人困惑。&lt;/p&gt;
&lt;p&gt;运行这个命令会在文本编辑器上给你一个提交的列表，看起来像下面这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file

# Rebase 710f0f8..a5f4a0d onto 710f0f8
#
# Commands:
# p, pick &amp;lt;commit&amp;gt; = use commit
# r, reword &amp;lt;commit&amp;gt; = use commit, but edit the commit message
# e, edit &amp;lt;commit&amp;gt; = use commit, but stop for amending
# s, squash &amp;lt;commit&amp;gt; = use commit, but meld into previous commit
# f, fixup &amp;lt;commit&amp;gt; = like &quot;squash&quot;, but discard this commit&apos;s log message
# x, exec &amp;lt;command&amp;gt; = run command (the rest of the line) using shell
# b, break = stop here (continue rebase later with &apos;git rebase --continue&apos;)
# d, drop &amp;lt;commit&amp;gt; = remove commit
# l, label &amp;lt;label&amp;gt; = label current HEAD with a name
# t, reset &amp;lt;label&amp;gt; = reset HEAD to a label
# m, merge [-C &amp;lt;commit&amp;gt; | -c &amp;lt;commit&amp;gt;] &amp;lt;label&amp;gt; [# &amp;lt;oneline&amp;gt;]
# .       create a merge commit using the original merge commit&apos;s
# .       message (or the oneline, if no original merge commit was
# .       specified). Use -c &amp;lt;commit&amp;gt; to reword the commit message.
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;需要重点注意的是相对于正常使用的 &lt;code&gt;log&lt;/code&gt; 命令，这些提交显示的顺序是相反的。 运行一次 &lt;em&gt;log&lt;/em&gt; 命令，会看到类似这样的东西：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log --pretty=format:&quot;%h %s&quot; HEAD~3..HEAD
a5f4a0d added cat-file
310154e updated README formatting and added blame
f7f3f6d changed my name a bit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意其中的反序显示。 交互式变基给你一个它将会运行的脚本。 它将会从你在命令行中指定的提交（&lt;code&gt;HEAD~3&lt;/code&gt;）开始，从上到下的依次重演每一个提交引入的修改。 它将最旧的而不是最新的列在上面，因为那会是第一个将要重演的。&lt;/p&gt;
&lt;p&gt;你需要修改脚本来让它停留在你想修改的变更上。 要达到这个目的，你只要将你想修改的每一次提交前面的 ‘pick’ 改为 ‘edit’。 例如，只想修改第三次提交信息，可以像下面这样修改文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;edit f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当保存并退出编辑器时，Git 将你带回到列表中的最后一次提交，把你送回命令行并提示以下信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git rebase -i HEAD~3
Stopped at f7f3f6d... changed my name a bit
You can amend the commit now, with

       git commit --amend

Once you&apos;re satisfied with your changes, run

       git rebase --continue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这些指令准确地告诉你该做什么。 输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git commit --amend
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改提交信息，然后退出编辑器。 然后，运行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git rebase --continue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令将会自动地应用另外两个提交，然后就完成了。 如果需要将不止一处的 pick 改为 edit，需要在每一个修改为 edit 的提交上重复这些步骤。 每一次，Git 将会停止，让你修正提交，然后继续直到完成。&lt;/p&gt;
&lt;h2&gt;重新排序提交&lt;/h2&gt;
&lt;p&gt;也可以使用交互式变基来重新排序或完全移除提交。 如果想要移除 “added cat-file” 提交然后修改另外两个提交引入的顺序，可以将变基脚本从这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pick f7f3f6d changed my name a bit
pick 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改为这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pick 310154e updated README formatting and added blame
pick f7f3f6d changed my name a bit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当保存并退出编辑器时，Git 将你的分支带回这些提交的父提交，应用 &lt;code&gt;310154e&lt;/code&gt; 然后应用 &lt;code&gt;f7f3f6d&lt;/code&gt;，最后停止。 事实修改了那些提交的顺序并完全地移除了 “added cat-file” 提交。&lt;/p&gt;
&lt;h2&gt;压缩提交&lt;/h2&gt;
&lt;p&gt;通过交互式变基工具，也可以将一连串提交压缩成一个单独的提交。 在变基信息中脚本给出了有用的指令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#
# Commands:
# p, pick &amp;lt;commit&amp;gt; = use commit
# r, reword &amp;lt;commit&amp;gt; = use commit, but edit the commit message
# e, edit &amp;lt;commit&amp;gt; = use commit, but stop for amending
# s, squash &amp;lt;commit&amp;gt; = use commit, but meld into previous commit
# f, fixup &amp;lt;commit&amp;gt; = like &quot;squash&quot;, but discard this commit&apos;s log message
# x, exec &amp;lt;command&amp;gt; = run command (the rest of the line) using shell
# b, break = stop here (continue rebase later with &apos;git rebase --continue&apos;)
# d, drop &amp;lt;commit&amp;gt; = remove commit
# l, label &amp;lt;label&amp;gt; = label current HEAD with a name
# t, reset &amp;lt;label&amp;gt; = reset HEAD to a label
# m, merge [-C &amp;lt;commit&amp;gt; | -c &amp;lt;commit&amp;gt;] &amp;lt;label&amp;gt; [# &amp;lt;oneline&amp;gt;]
# .       create a merge commit using the original merge commit&apos;s
# .       message (or the oneline, if no original merge commit was
# .       specified). Use -c &amp;lt;commit&amp;gt; to reword the commit message.
#
# These lines can be re-ordered; they are executed from top to bottom.
#
# If you remove a line here THAT COMMIT WILL BE LOST.
#
# However, if you remove everything, the rebase will be aborted.
#
# Note that empty commits are commented out
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果，指定 “squash” 而不是 “pick” 或 “edit”，Git 将应用两者的修改并合并提交信息在一起。 所以，如果想要这三次提交变为一个提交，可以这样修改脚本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pick f7f3f6d changed my name a bit
squash 310154e updated README formatting and added blame
squash a5f4a0d added cat-file
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当保存并退出编辑器时，Git 应用所有的三次修改然后将你放到编辑器中来合并三次提交信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# This is a combination of 3 commits.
# The first commit&apos;s message is:
changed my name a bit

# This is the 2nd commit message:

updated README formatting and added blame

# This is the 3rd commit message:

added cat-file
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当你保存之后，你就拥有了一个包含前三次提交的全部变更的提交。&lt;/p&gt;
&lt;h2&gt;拆分提交&lt;/h2&gt;
&lt;p&gt;拆分一个提交会撤消这个提交，然后多次地部分地暂存与提交直到完成你所需次数的提交。 例如，假设想要拆分三次提交的中间那次提交。 想要将它拆分为两次提交：第一个 “updated README formatting”，第二个 “added blame” 来代替原来的 “updated README formatting and added blame”。 可以通过修改 &lt;code&gt;rebase -i&lt;/code&gt; 的脚本来做到这点，将要拆分的提交的指令修改为 “edit”：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;pick f7f3f6d changed my name a bit
edit 310154e updated README formatting and added blame
pick a5f4a0d added cat-file
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后，当脚本带你进入到命令行时，重置那个提交，拿到被重置的修改，从中创建几次提交。 当保存并退出编辑器时，Git 带你到列表中第一个提交的父提交，应用第一个提交（&lt;code&gt;f7f3f6d&lt;/code&gt;）， 应用第二个提交（&lt;code&gt;310154e&lt;/code&gt;），然后让你进入命令行。 那里，可以通过 &lt;code&gt;git reset HEAD^&lt;/code&gt; 做一次针对那个提交的混合重置，实际上将会撤消那次提交并将修改的文件取消暂存。 现在可以暂存并提交文件直到有几个提交，然后当完成时运行 &lt;code&gt;git rebase --continue&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git reset HEAD^
git add README
git commit -m &apos;updated README formatting&apos;
git add lib/simplegit.rb
git commit -m &apos;added blame&apos;
git rebase --continue
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Git 在脚本中应用最后一次提交（&lt;code&gt;a5f4a0d&lt;/code&gt;），历史记录看起来像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log -4 --pretty=format:&quot;%h %s&quot;
1c002dd added cat-file
9b29157 added blame
35cfb2b updated README formatting
f3cc40e changed my name a bit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再次强调，这些改动了所有在列表中的提交的 SHA-1 校验和，所以要确保列表中的提交还没有推送到共享仓库中。&lt;/p&gt;
&lt;h2&gt;核武器级选项：filter-branch&lt;/h2&gt;
&lt;p&gt;有另一个历史改写的选项，如果想要通过脚本的方式改写大量提交的话可以使用它——例如，全局修改你的邮箱地址或从每一个提交中移除一个文件。 这个命令是 &lt;code&gt;filter-branch&lt;/code&gt;，它可以改写历史中大量的提交，除非你的项目还没有公开并且其他人没有基于要改写的工作的提交做的工作，否则你不应当使用它。 然而，它可以很有用。 你将会学习到几个常用的用途，这样就得到了它适合使用地方的想法。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Caution&lt;/th&gt;
&lt;th&gt;&lt;code&gt;git filter-branch&lt;/code&gt; 有很多陷阱，不再推荐使用它来重写历史。 请考虑使用 &lt;code&gt;git-filter-repo&lt;/code&gt;，它是一个 Python 脚本，相比大多数使用 &lt;code&gt;filter-branch&lt;/code&gt; 的应用来说，它做得要更好。它的文档和源码可访问 &lt;a href=&quot;https://github.com/newren/git-filter-repo&quot;&gt;https://github.com/newren/git-filter-repo&lt;/a&gt; 获取。&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;从每一个提交中移除一个文件&lt;/h3&gt;
&lt;p&gt;这经常发生。 有人粗心地通过 &lt;code&gt;git add .&lt;/code&gt; 提交了一个巨大的二进制文件，你想要从所有地方删除。 可能偶然地提交了一个包括一个密码的文件，然而你想要开源项目。 &lt;code&gt;filter-branch&lt;/code&gt; 是一个可能会用来擦洗整个提交历史的工具。 为了从整个提交历史中移除一个叫做 &lt;code&gt;passwords.txt&lt;/code&gt; 的文件，可以使用 &lt;code&gt;--tree-filter&lt;/code&gt; 选项给 &lt;code&gt;filter-branch&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git filter-branch --tree-filter &apos;rm -f passwords.txt&apos; HEAD
Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
Ref &apos;refs/heads/master&apos; was rewritten
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;--tree-filter&lt;/code&gt; 选项在检出项目的每一个提交后运行指定的命令然后重新提交结果。 在本例中，你从每一个快照中移除了一个叫作 &lt;code&gt;passwords.txt&lt;/code&gt; 的文件，无论它是否存在。 如果想要移除所有偶然提交的编辑器备份文件，可以运行类似 &lt;code&gt;git filter-branch --tree-filter &apos;rm -f *~&apos; HEAD&lt;/code&gt; 的命令。&lt;/p&gt;
&lt;p&gt;最后将可以看到 Git 重写树与提交然后移动分支指针。 通常一个好的想法是在一个测试分支中做这件事，然后当你决定最终结果是真正想要的，可以硬重置 &lt;code&gt;master&lt;/code&gt; 分支。 为了让 &lt;code&gt;filter-branch&lt;/code&gt; 在所有分支上运行，可以给命令传递 &lt;code&gt;--all&lt;/code&gt; 选项。&lt;/p&gt;
&lt;h3&gt;使一个子目录做为新的根目录&lt;/h3&gt;
&lt;p&gt;假设已经从另一个源代码控制系统中导入，并且有几个没意义的子目录（&lt;code&gt;trunk&lt;/code&gt;、&lt;code&gt;tags&lt;/code&gt; 等等）。 如果想要让 &lt;code&gt;trunk&lt;/code&gt; 子目录作为每一个提交的新的项目根目录，&lt;code&gt;filter-branch&lt;/code&gt; 也可以帮助你那么做：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git filter-branch --subdirectory-filter trunk HEAD
Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
Ref &apos;refs/heads/master&apos; was rewritten
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在新项目根目录是 &lt;code&gt;trunk&lt;/code&gt; 子目录了。 Git 会自动移除所有不影响子目录的提交。&lt;/p&gt;
&lt;h3&gt;全局修改邮箱地址&lt;/h3&gt;
&lt;p&gt;另一个常见的情形是在你开始工作时忘记运行 &lt;code&gt;git config&lt;/code&gt; 来设置你的名字与邮箱地址， 或者你想要开源一个项目并且修改所有你的工作邮箱地址为你的个人邮箱地址。 任何情形下，你也可以通过 &lt;code&gt;filter-branch&lt;/code&gt; 来一次性修改多个提交中的邮箱地址。 需要小心的是只修改你自己的邮箱地址，所以你使用 &lt;code&gt;--commit-filter&lt;/code&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git filter-branch --commit-filter &apos;
        if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;schacon@localhost&quot; ];
        then
                GIT_AUTHOR_NAME=&quot;Scott Chacon&quot;;
                GIT_AUTHOR_EMAIL=&quot;schacon@example.com&quot;;
                git commit-tree &quot;$@&quot;;
        else
                git commit-tree &quot;$@&quot;;
        fi&apos; HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这会遍历并重写每一个提交来包含你的新邮箱地址。 因为提交包含了它们父提交的 SHA-1 校验和，这个命令会修改你的历史中的每一个提交的 SHA-1 校验和， 而不仅仅只是那些匹配邮箱地址的提交。&lt;/p&gt;
</content:encoded></item><item><title>Git分支开发工作流</title><link>https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/50git%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81/</link><guid isPermaLink="true">https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/50git%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81/</guid><pubDate>Wed, 18 Nov 2020 17:43:57 GMT</pubDate><content:encoded>&lt;p&gt;文档：&lt;a href=&quot;https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E5%B7%A5%E4%BD%9C%E6%B5%81&quot;&gt;Git分支开发工作流&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;长期分支&lt;/h3&gt;
&lt;p&gt;因为 Git 使用简单的三方合并，所以就算在一段较长的时间内，反复把一个分支合并入另一个分支，也不是什么难事。 也就是说，在整个项目开发周期的不同阶段，你可以同时拥有多个开放的分支；你可以定期地把某些主题分支合并入其他分支中。&lt;/p&gt;
&lt;p&gt;许多使用 Git 的开发者都喜欢使用这种方式来工作，比如&lt;strong&gt;只在 &lt;code&gt;master&lt;/code&gt; 分支上保留完全稳定的代码&lt;/strong&gt;，开发过程在&lt;code&gt;dev&lt;/code&gt;分支，开发完成后并入&lt;code&gt;test&lt;/code&gt;分支进行测试，通过测试的稳定代码才并入&lt;code&gt;master&lt;/code&gt;分支中。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dev&lt;/code&gt;和&lt;code&gt;test&lt;/code&gt;分支不需要保持绝对稳定，但在&lt;code&gt;test&lt;/code&gt;通过测试达到稳定状态，就可以被合并入&lt;code&gt;master&lt;/code&gt;分支。&lt;/p&gt;
&lt;p&gt;事实上我们刚才讨论的，是随着你的提交而不断右移的指针。 稳定分支(&lt;code&gt;master&lt;/code&gt;)的指针总是在提交历史中落后一大截，而前沿分支(&lt;code&gt;dev&lt;/code&gt;或&lt;code&gt;test&lt;/code&gt;)的指针往往比较靠前。&lt;/p&gt;
&lt;p&gt;你可以用这种方法维护不同层次的稳定性。 一些大型项目还有一个 &lt;code&gt;proposed&lt;/code&gt;（建议） 或 &lt;code&gt;pu: proposed updates&lt;/code&gt;（建议更新）分支，它可能因包含一些不成熟的内容而不能进入&lt;code&gt;master&lt;/code&gt; 分支。 这么做的目的是使你的分支具有不同级别的稳定性；当它们具有一定程度的稳定性后，再把它们合并入具有更高级别稳定性的分支中。 再次强调一下，使用多个长期分支的方法并非必要，但是这么做通常很有帮助，尤其是当你在一个非常庞大或者复杂的项目中工作时。&lt;/p&gt;
&lt;h3&gt;主题分支 (短期分支)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;主题分支对任何规模的项目都适用&lt;/strong&gt;。 主题分支是一种&lt;strong&gt;短期分支&lt;/strong&gt;，它被&lt;strong&gt;用来实现单一特性或其相关工作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;你已经在上一节中你创建的 &lt;code&gt;iss53&lt;/code&gt; 和 &lt;code&gt;hotfix&lt;/code&gt; 主题分支中看到过这种用法。 你在上一节用到的主题分支（&lt;code&gt;iss53&lt;/code&gt; 和 &lt;code&gt;hotfix&lt;/code&gt; 分支）中提交了一些更新，并且在它们合并入主干分支之后，你又删除了它们。 这项技术能使你快速并且完整地进行上下文切换（context-switch）——因为你的工作被分散到不同的流水线中，在不同的流水线中&lt;strong&gt;每个分支都仅与其目标特性相关&lt;/strong&gt;，因此，&lt;strong&gt;在做代码审查之类的工作的时候就能更加容易地看出你做了哪些改动&lt;/strong&gt;。 你可以把做出的改动在主题分支中保留几分钟、几天甚至几个月，等它们成熟之后再合并，而不用在乎它们建立的顺序或工作进度。&lt;/p&gt;
&lt;p&gt;考虑这样一个例子，你在 &lt;code&gt;master&lt;/code&gt; 分支上工作到 &lt;code&gt;C1&lt;/code&gt;，这时为了解决一个问题而新建 &lt;code&gt;iss91&lt;/code&gt; 分支，在 &lt;code&gt;iss91&lt;/code&gt; 分支上工作到 &lt;code&gt;C4&lt;/code&gt;，然而对于那个问题你又有了新的想法，于是你再新建一个 &lt;code&gt;iss91v2&lt;/code&gt; 分支试图用另一种方法解决那个问题，接着你回到 &lt;code&gt;master&lt;/code&gt; 分支工作了一会儿，你又冒出了一个不太确定的想法，你便在 &lt;code&gt;C10&lt;/code&gt; 的时候新建一个 &lt;code&gt;dumbidea&lt;/code&gt; 分支，并在上面做些实验。 你的提交历史看起来像下面这个样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/topic-branches-1.png&quot; alt=&quot;拥有多个主题分支的提交历史。&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&quot;center&quot;&amp;gt;图1. 拥有多个主题分支的提交历史 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;现在，我们假设两件事情：你决定使用第二个方案来解决那个问题，即使用在 &lt;code&gt;iss91v2&lt;/code&gt; 分支中方案。 另外，你将 &lt;code&gt;dumbidea&lt;/code&gt; 分支拿给你的同事看过之后，结果发现这是个惊人之举。 这时你可以&lt;strong&gt;抛弃 &lt;code&gt;iss91&lt;/code&gt; 分支（即丢弃 &lt;code&gt;C5&lt;/code&gt; 和 &lt;code&gt;C6&lt;/code&gt; 提交）&lt;/strong&gt;，然后把另外两个分支合并入主干分支。 最终你的提交历史看起来像下面这个样子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/topic-branches-2.png&quot; alt=&quot;合并了  和  分支之后的提交历史。&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&quot;center&quot;&amp;gt;图2. 合并了 dumbidea 和 iss91v2 分支之后的提交历史 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;我们将会在 &lt;a href=&quot;https://git-scm.com/book/zh/v2/ch00/ch05-distributed-git&quot;&gt;分布式 Git&lt;/a&gt; 中向你揭示更多有关分支工作流的细节， 因此，请确保你阅读完那个章节之后，再来决定你的下个项目要使用什么样的分支策略（branching scheme）。&lt;/p&gt;
&lt;p&gt;请牢记，当你做这么多操作的时候，这些分支全部都存于本地。 当你新建和合并分支的时候，所有这一切都只发生在你本地的 Git 版本库中 —— 没有与服务器发生交互。&lt;/p&gt;
</content:encoded></item><item><title>Git分支-远程分支</title><link>https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/60git%E5%88%86%E6%94%AF-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/</link><guid isPermaLink="true">https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/60git%E5%88%86%E6%94%AF-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF/</guid><pubDate>Wed, 18 Nov 2020 17:43:57 GMT</pubDate><content:encoded>&lt;p&gt;&lt;strong&gt;远程引用是对远程仓库的引用（指针）&lt;/strong&gt;，包括分支、标签等等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;远程分支本质上也是一个指针，指向远程地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;查看远程引用列表与信息&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git ls-remote &amp;lt;remote&amp;gt; # 远程引用的完整列表
git remote show &amp;lt;remote&amp;gt; # 远程分支的更多信息
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面两行命令比较少用，更常见的做法是利用远程跟踪分支。&lt;/p&gt;
&lt;h3&gt;远程跟踪分支&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;远程跟踪分支是远程分支状态的引用&lt;/strong&gt;。它们是你无法移动的本地引用。一旦你进行了网络通信， Git 就会为你移动它们以&lt;strong&gt;精确反映远程仓库的状态&lt;/strong&gt;。请将它们&lt;strong&gt;看做书签&lt;/strong&gt;， 这样可以提醒你该分支在远程仓库中的位置就是你最后一次连接到它们的位置。&lt;/p&gt;
&lt;p&gt;它们&lt;strong&gt;以 &lt;code&gt;&amp;lt;remote&amp;gt;/&amp;lt;branch&amp;gt;&lt;/code&gt; 的形式命名&lt;/strong&gt;。 例如，如果你想要&lt;strong&gt;查看最后一次与远程仓库 &lt;code&gt;origin&lt;/code&gt; 通信时 &lt;code&gt;master&lt;/code&gt; 分支的状态&lt;/strong&gt;，你可以查看 &lt;code&gt;origin/master&lt;/code&gt; 分支。 你与同事合作解决一个问题并且他们推送了一个 &lt;code&gt;iss53&lt;/code&gt; 分支，你可能有自己的本地 &lt;code&gt;iss53&lt;/code&gt; 分支， 然而在服务器上的分支会以 &lt;code&gt;origin/iss53&lt;/code&gt; 来表示。&lt;/p&gt;
&lt;p&gt;这可能有一点儿难以理解，让我们来看一个例子。 假设你的网络里有一个在 &lt;code&gt;git.ourcompany.com&lt;/code&gt; 的 Git 服务器。 如果你从这里克隆，Git 的 &lt;code&gt;clone&lt;/code&gt; 命令会为你自动将其命名为 &lt;code&gt;origin&lt;/code&gt;，拉取它的所有数据， 创建一个指向它的 &lt;code&gt;master&lt;/code&gt; 分支的指针，并且&lt;strong&gt;在本地将其命名为 &lt;code&gt;origin/master&lt;/code&gt;&lt;/strong&gt;。 Git 也会给你一个与 origin 的 &lt;code&gt;master&lt;/code&gt; 分支在指向同一个地方的本地 &lt;code&gt;master&lt;/code&gt; 分支，这样你就有工作的基础。&lt;/p&gt;
&lt;p&gt;&amp;lt;mark&amp;gt;&lt;strong&gt;笔记：从远程克隆下来的仓库有一个叫&lt;code&gt;origin/master&lt;/code&gt;的远程跟踪分支 和 一个本地的&lt;code&gt;master&lt;/code&gt;分支&lt;/strong&gt;&amp;lt;/mark&amp;gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;笔记：“origin” 并无特殊含义远程仓库名字 “origin” 与分支名字 “master” 一样，在 Git 中并没有任何特别的含义一样。 同时 “master” 是当你运行 &lt;code&gt;git init&lt;/code&gt; 时默认的起始分支名字，原因仅仅是它的广泛使用， “origin” 是当你运行 &lt;code&gt;git clone&lt;/code&gt; 时默认的远程仓库名字。 如果你运行 &lt;code&gt;git clone -o booyah&lt;/code&gt;，那么你默认的远程分支名字将会是 &lt;code&gt;booyah/master&lt;/code&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/remote-branches-1.png&quot; alt=&quot;克隆之后的服务器与本地仓库。&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&quot;center&quot;&amp;gt;图1.  克隆之后的服务器与本地仓库 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;如果你在本地的 &lt;code&gt;master&lt;/code&gt; 分支做了一些工作，在同一段时间内有其他人推送提交到 &lt;code&gt;git.ourcompany.com&lt;/code&gt; 并且更新了它的 &lt;code&gt;master&lt;/code&gt; 分支，这就是说你们的提交历史已走向不同的方向。 即便这样，只要你保持不与 &lt;code&gt;origin&lt;/code&gt; 服务器连接（并拉取数据），你的 &lt;code&gt;origin/master&lt;/code&gt; 指针就不会移动。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/remote-branches-2.png&quot; alt=&quot;本地与远程的工作可以分叉。&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&quot;center&quot;&amp;gt;图2.  本地与远程的工作可以分叉 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;如果要与给定的远程仓库同步数据，运行 &lt;code&gt;git fetch &amp;lt;remote&amp;gt;&lt;/code&gt; 命令（在本例中为 &lt;code&gt;git fetch origin&lt;/code&gt;）。 这个命令查找 “origin” 是哪一个服务器（在本例中，它是 &lt;code&gt;git.ourcompany.com&lt;/code&gt;）， 从中抓取本地没有的数据，并且更新本地数据库，移动 &lt;code&gt;origin/master&lt;/code&gt; 指针到更新之后的位置。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/remote-branches-3.png&quot; alt=&quot; 更新你的远程仓库引用。&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&quot;center&quot;&amp;gt;图3.   git fetch 更新你的远程跟踪分支 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;mark&amp;gt;笔记: 本地的 master 分支 可能 和 远程跟踪分支 origin/master 分叉&amp;lt;/mark&amp;gt;&lt;/p&gt;
&lt;p&gt;为了演示有多个远程仓库与远程分支的情况，我们假定你有另一个内部 Git 服务器，仅服务于你的某个敏捷开发团队。 这个服务器位于 &lt;code&gt;git.team1.ourcompany.com&lt;/code&gt;。 你可以运行 &lt;code&gt;git remote add&lt;/code&gt; 命令添加一个新的远程仓库引用到当前的项目，这个命令我们会在 &lt;a href=&quot;https://git-scm.com/book/zh/v2/ch00/ch02-git-basics-chapter&quot;&gt;Git 基础&lt;/a&gt; 中详细说明。 将这个远程仓库&lt;strong&gt;命名为 &lt;code&gt;teamone&lt;/code&gt;，将其作为完整 URL 的缩写&lt;/strong&gt;。&amp;lt;mark&amp;gt;远程仓库名本质上是远程URL的缩写&amp;lt;/mark&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/remote-branches-4.png&quot; alt=&quot;添加另一个远程仓库。&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&quot;center&quot;&amp;gt;图4.   添加另一个远程仓库 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;现在，可以运行 &lt;code&gt;git fetch teamone&lt;/code&gt; 来抓取远程仓库 &lt;code&gt;teamone&lt;/code&gt; 有而本地没有的数据。 因为那台服务器上现有的数据是 &lt;code&gt;origin&lt;/code&gt; 服务器上的一个子集， 所以 Git 并不会抓取数据而是会设置远程跟踪分支 &lt;code&gt;teamone/master&lt;/code&gt; 指向 &lt;code&gt;teamone&lt;/code&gt; 的 &lt;code&gt;master&lt;/code&gt; 分支。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/remote-branches-5.png&quot; alt=&quot;远程跟踪分支 。&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&quot;center&quot;&amp;gt;图5.   远程跟踪分支 teamone/master ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;h3&gt;推送&lt;/h3&gt;
&lt;p&gt;当你想要公开分享一个分支时，需要将其推送到有写入权限的远程仓库上。 本地的分支并不会自动与远程仓库同步——你必须显式地推送想要分享的分支。 这样，你就可以把不愿意分享的内容放到私人分支上，而将需要和别人协作的内容推送到公开分支。&lt;/p&gt;
&lt;p&gt;如果希望和别人一起在名为 &lt;code&gt;serverfix&lt;/code&gt; 的分支上工作，你可以像推送第一个分支那样推送它。 运行 &lt;code&gt;git push &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt;&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git push origin serverfix
Counting objects: 24, done.
Delta compression using up to 8 threads.
Compressing objects: 100% (15/15), done.
Writing objects: 100% (24/24), 1.91 KiB | 0 bytes/s, done.
Total 24 (delta 2), reused 0 (delta 0)
To https://github.com/schacon/simplegit
 * [new branch]      serverfix -&amp;gt; serverfix
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里有些工作被简化了。 &lt;strong&gt;Git 自动将 &lt;code&gt;serverfix&lt;/code&gt; 分支名字展开为 &lt;code&gt;refs/heads/serverfix:refs/heads/serverfix&lt;/code&gt;，&lt;/strong&gt; 那意味着，“推送本地的 &lt;code&gt;serverfix&lt;/code&gt; 分支来更新远程仓库上的 &lt;code&gt;serverfix&lt;/code&gt; 分支。” 我们将会详细学习 &lt;a href=&quot;https://git-scm.com/book/zh/v2/ch00/ch10-git-internals&quot;&gt;Git 内部原理&lt;/a&gt; 的 &lt;code&gt;refs/heads/&lt;/code&gt; 部分， 但是现在可以先把它放在儿。你也可以运行 &lt;code&gt;git push origin serverfix:serverfix&lt;/code&gt;， 它会做同样的事——也就是说“&lt;strong&gt;推送本地的 &lt;code&gt;serverfix&lt;/code&gt; 分支，将其作为远程仓库的 &lt;code&gt;serverfix&lt;/code&gt; 分支&lt;/strong&gt;” 可以通过这种格式来推送本地分支到一个命名不相同的远程分支。&lt;/p&gt;
&lt;h4&gt;重命名远程仓库上的分支名&lt;/h4&gt;
&lt;p&gt;如果并不想让远程仓库上的分支叫做 &lt;code&gt;serverfix&lt;/code&gt;，可以运行 &lt;code&gt;git push origin serverfix:awesomebranch&lt;/code&gt; 来将本地的 &lt;code&gt;serverfix&lt;/code&gt; 分支推送到远程仓库上的 &lt;code&gt;awesomebranch&lt;/code&gt; 分支。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Note&lt;/th&gt;
&lt;th&gt;如何避免每次输入密码如果你正在使用 HTTPS URL 来推送，Git 服务器会询问用户名与密码。 默认情况下它会在终端中提示服务器是否允许你进行推送。如果不想在每一次推送时都输入用户名与密码，你可以设置一个 “credential cache”。 最简单的方式就是将其保存在内存中几分钟，可以简单地运行 &lt;code&gt;git config --global credential.helper cache&lt;/code&gt; 来设置它。想要了解更多关于不同验证缓存的可用选项，查看 &lt;a href=&quot;https://git-scm.com/book/zh/v2/ch00/_credential_caching&quot;&gt;凭证存储&lt;/a&gt;。&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;下一次其他协作者从服务器上抓取数据时，他们会在本地生成一个远程分支 &lt;code&gt;origin/serverfix&lt;/code&gt;，指向服务器的 &lt;code&gt;serverfix&lt;/code&gt; 分支的引用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git fetch origin
remote: Counting objects: 7, done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 3 (delta 0)
Unpacking objects: 100% (3/3), done.
From https://github.com/schacon/simplegit
 * [new branch]      serverfix    -&amp;gt; origin/serverfix
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要特别注意的一点是当抓取到新的远程跟踪分支时，本地不会自动生成一份可编辑的副本（拷贝）。 换一句话说，这种情况下，不会有一个新的 &lt;code&gt;serverfix&lt;/code&gt; 分支——只有一个不可以修改的 &lt;code&gt;origin/serverfix&lt;/code&gt; 指针。&lt;/p&gt;
&lt;p&gt;可以运行 &lt;code&gt;git merge origin/serverfix&lt;/code&gt; 将这些工作合并到当前所在的分支。 如果想要在自己的 &lt;code&gt;serverfix&lt;/code&gt; 分支上工作，可以将其建立在远程跟踪分支之上：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git checkout -b serverfix origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch &apos;serverfix&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这会给你一个用于工作的本地分支，并且起点位于 &lt;code&gt;origin/serverfix&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;跟踪分支&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;从一个远程跟踪分支检出一个本地分支会自动创建所谓的“跟踪分支”（它跟踪的分支叫做“上游分支”）&lt;/strong&gt;。 &lt;strong&gt;跟踪分支是与远程分支有直接关系的本地分支&lt;/strong&gt;。 如果在一个跟踪分支上输入 &lt;code&gt;git pull&lt;/code&gt;，Git 能自动地识别去哪个服务器上抓取、合并到哪个分支。&lt;/p&gt;
&lt;p&gt;当克隆一个仓库时，它通常会自动地创建一个跟踪 &lt;code&gt;origin/master&lt;/code&gt; 的 &lt;code&gt;master&lt;/code&gt; 分支。 然而，如果你愿意的话可以设置其他的跟踪分支，或是一个在其他远程仓库上的跟踪分支，又或者不跟踪 &lt;code&gt;master&lt;/code&gt; 分支。 最简单的实例就是像之前看到的那样，运行 &lt;code&gt;git checkout -b &amp;lt;branch&amp;gt; &amp;lt;remote&amp;gt;/&amp;lt;branch&amp;gt;&lt;/code&gt;。 这是一个十分常用的操作所以 Git 提供了 &lt;code&gt;--track&lt;/code&gt; 快捷方式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git checkout --track origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch &apos;serverfix&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于这个操作太常用了，该捷径本身还有一个捷径。 如果你尝试检出的分支 (a) 不存在且 (b) 刚好只有一个名字与之匹配的远程分支，那么 Git 就会为你创建一个跟踪分支：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git checkout serverfix
Branch serverfix set up to track remote branch serverfix from origin.
Switched to a new branch &apos;serverfix&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果想要将本地分支与远程分支设置为不同的名字，你可以轻松地使用上一个命令增加一个不同名字的本地分支：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git checkout -b sf origin/serverfix
Branch sf set up to track remote branch serverfix from origin.
Switched to a new branch &apos;sf&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，本地分支 &lt;code&gt;sf&lt;/code&gt; 会自动从 &lt;code&gt;origin/serverfix&lt;/code&gt; 拉取。&lt;/p&gt;
&lt;p&gt;设置已有的本地分支跟踪一个刚刚拉取下来的远程分支，或者想要修改正在跟踪的上游分支， 你可以在任意时间使用 &lt;code&gt;-u&lt;/code&gt; 或 &lt;code&gt;--set-upstream-to&lt;/code&gt; 选项运行 &lt;code&gt;git branch&lt;/code&gt; 来显式地设置。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git branch -u origin/serverfix
Branch serverfix set up to track remote branch serverfix from origin.
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Note&lt;/th&gt;
&lt;th&gt;上游快捷方式当设置好跟踪分支后，可以通过简写 &lt;code&gt;@{upstream}&lt;/code&gt; 或 &lt;code&gt;@{u}&lt;/code&gt; 来引用它的上游分支。 所以在 &lt;code&gt;master&lt;/code&gt; 分支时并且它正在跟踪 &lt;code&gt;origin/master&lt;/code&gt; 时，如果愿意的话可以使用 &lt;code&gt;git merge @{u}&lt;/code&gt; 来取代 &lt;code&gt;git merge origin/master&lt;/code&gt;。&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;查看跟踪分支&lt;/h3&gt;
&lt;p&gt;如果想要查看设置的所有跟踪分支，可以使用 &lt;code&gt;git branch&lt;/code&gt; 的 &lt;code&gt;-vv&lt;/code&gt; 选项。 这会将所有的本地分支列出来并且包含更多的信息，如每一个分支正在跟踪哪个远程分支与本地分支是否是领先、落后或是都有。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git branch -vv
  iss53     7e424c3 [origin/iss53: ahead 2] forgot the brackets
  master    1ae2a45 [origin/master] deploying index fix
* serverfix f8674d9 [teamone/server-fix-good: ahead 3, behind 1] this should do it
  testing   5ea463a trying something new
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里可以看到 &lt;code&gt;iss53&lt;/code&gt; 分支正在跟踪 &lt;code&gt;origin/iss53&lt;/code&gt; 并且 “ahead” 是 2，意味着本地有两个提交还没有推送到服务器上。 也能看到 &lt;code&gt;master&lt;/code&gt; 分支正在跟踪 &lt;code&gt;origin/master&lt;/code&gt; 分支并且是最新的。 接下来可以看到 &lt;code&gt;serverfix&lt;/code&gt; 分支正在跟踪 &lt;code&gt;teamone&lt;/code&gt; 服务器上的 &lt;code&gt;server-fix-good&lt;/code&gt; 分支并且领先 3 落后 1， 意味着服务器上有一次提交还没有合并入同时本地有三次提交还没有推送。 最后看到 &lt;code&gt;testing&lt;/code&gt; 分支并没有跟踪任何远程分支。&lt;/p&gt;
&lt;p&gt;需要重点注意的一点是这些数字的值来自于你从每个服务器上最后一次抓取的数据。 &lt;strong&gt;这个命令并没有连接服务器&lt;/strong&gt;，它只会告诉你关于本地缓存的服务器数据。 如果想要统计最新的领先与落后数字，需要在运行此命令前抓取所有的远程仓库。 可以像这样做：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git fetch --all; git branch -vv
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;拉取&lt;/h3&gt;
&lt;p&gt;当 &lt;code&gt;git fetch&lt;/code&gt; 命令从服务器上抓取本地没有的数据时，它并不会修改工作目录中的内容。 它只会获取数据然后让你自己合并。 然而，有一个命令叫作 &lt;code&gt;git pull&lt;/code&gt; 在大多数情况下它的含义是一个 &lt;code&gt;git fetch&lt;/code&gt; 紧接着一个 &lt;code&gt;git merge&lt;/code&gt; 命令。 如果有一个像之前章节中演示的设置好的跟踪分支，不管它是显式地设置还是通过 &lt;code&gt;clone&lt;/code&gt; 或 &lt;code&gt;checkout&lt;/code&gt; 命令为你创建的，&lt;code&gt;git pull&lt;/code&gt; 都会查找当前分支所跟踪的服务器与分支， 从服务器上抓取数据然后尝试合并入那个远程分支。&lt;/p&gt;
&lt;p&gt;由于 &lt;code&gt;git pull&lt;/code&gt; 的魔法经常令人困惑所以通常单独显式地使用 &lt;code&gt;fetch&lt;/code&gt; 与 &lt;code&gt;merge&lt;/code&gt; 命令会更好一些。&lt;/p&gt;
&lt;h3&gt;删除远程分支&lt;/h3&gt;
&lt;p&gt;假设你已经通过远程分支做完所有的工作了——也就是说你和你的协作者已经完成了一个特性， 并且将其合并到了远程仓库的 &lt;code&gt;master&lt;/code&gt; 分支（或任何其他稳定代码分支）。 可以运行带有 &lt;code&gt;--delete&lt;/code&gt; 选项的 &lt;code&gt;git push&lt;/code&gt; 命令来删除一个远程分支。 如果想要从服务器上删除 &lt;code&gt;serverfix&lt;/code&gt; 分支，运行下面的命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git push origin --delete serverfix
To https://github.com/schacon/simplegit
 - [deleted]         serverfix
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;基本上这个命令做的只是从服务器上移除这个指针。 Git 服务器通常会保留数据一段时间直到垃圾回收运行，所以如果不小心删除掉了，通常是很容易恢复的。&lt;/p&gt;
</content:encoded></item><item><title>Git分支-变基</title><link>https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/70git%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA/</link><guid isPermaLink="true">https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/70git%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA/</guid><pubDate>Wed, 18 Nov 2020 17:43:57 GMT</pubDate><content:encoded>&lt;p&gt;在 Git 中整合来自不同分支的修改主要有两种方法：&lt;code&gt;merge&lt;/code&gt; 以及 &lt;code&gt;rebase&lt;/code&gt;。 在本节中我们将学习什么是“变基”，怎样使用“变基”，并将展示该操作的惊艳之处，以及指出在何种情况下你应避免使用它。&lt;/p&gt;
&lt;h2&gt;变基的基本操作&lt;/h2&gt;
&lt;p&gt;请回顾之前在 &lt;a href=&quot;https://git-scm.com/book/zh/v2/ch00/_basic_merging&quot;&gt;分支的合并&lt;/a&gt; 中的一个例子，你会看到开发任务分叉到两个不同分支，又各自提交了更新。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/basic-rebase-1.png&quot; alt=&quot;分叉的提交历史。&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&quot;center&quot;&amp;gt;图0.   分叉的提交历史 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;之前介绍过，整合分支最容易的方法是 &lt;code&gt;merge&lt;/code&gt; 命令。 它会把两个分支的最新快照（&lt;code&gt;C3&lt;/code&gt; 和 &lt;code&gt;C4&lt;/code&gt;）以及二者最近的共同祖先（&lt;code&gt;C2&lt;/code&gt;）进行&lt;strong&gt;三方合并&lt;/strong&gt;，合并的结果是生成一个新的快照（并提交）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/basic-rebase-2.png&quot; alt=&quot;通过合并操作来整合分叉了的历史。&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&quot;center&quot;&amp;gt;图1.   通过合并操作来整合分叉的历史 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;h3&gt;概念&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;变基就是：将某一分支上的所有修改复制到另一分支上&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;除了&lt;code&gt;merge&lt;/code&gt;，还有一种方法：你可以提取在 &lt;code&gt;C4&lt;/code&gt; 中引入的补丁和修改，然后在 &lt;code&gt;C3&lt;/code&gt; 的基础上应用一次。 在 Git 中，这种操作就叫做 &lt;strong&gt;变基（rebase）&lt;/strong&gt;。 你可以使用 &lt;code&gt;rebase&lt;/code&gt; 命令将提交到某一分支上的所有修改都移到另一分支上，就好像“重新播放”一样。&lt;/p&gt;
&lt;p&gt;在这个例子中，你可以检出 &lt;code&gt;experiment&lt;/code&gt; 分支，然后将它变基到 &lt;code&gt;master&lt;/code&gt; 分支上：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git checkout experiment
$ git rebase master # 将experiment上的修改变基到master分支上（将experiment的提交移动到master上。）
First, rewinding head to replay your work on top of it...
Applying: added staged command
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它的原理是首先找到这两个分支（即当前分支 &lt;code&gt;experiment&lt;/code&gt;、变基操作的目标基底分支 &lt;code&gt;master&lt;/code&gt;） 的最近共同祖先 &lt;code&gt;C2&lt;/code&gt;，然后对比当前分支相对于该祖先的历次提交，提取相应的修改并存为临时文件， 然后将当前分支指向目标基底 &lt;code&gt;C3&lt;/code&gt;, 最后以此将之前另存为临时文件的修改依序应用。 （译注：写明了 commit id，以便理解，下同）&lt;/p&gt;
&lt;h3&gt;原理&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;找到当前分支和目标分支的最近共同祖先&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;对比当前分支相对于该共同祖先的历次提交&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提取相应的修改并存为临时文件&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;将当前分支指向目标分支&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;将之前临时文件的修改依序应用&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/basic-rebase-3.png&quot; alt=&quot;将  中的修改变基到  上。&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&quot;center&quot;&amp;gt;图2.将 C4 中的修改变基到 C3 上 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;现在回到 &lt;code&gt;master&lt;/code&gt; 分支，进行一次快进合并。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout master
git merge experiment
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/basic-rebase-4.png&quot; alt=&quot; 分支的快进合并。&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&quot;center&quot;&amp;gt;图3.master 分支的快进合并 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;h3&gt;步骤&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;先检出源分支，将源分支的修改变基到目标分支。切回目标分支，进行一次快进合并&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 示意：
git checkout &amp;lt;源分支&amp;gt;
git (源分支的修改)rebase(到) &amp;lt;目标分支&amp;gt;
git checkout &amp;lt;目标分支&amp;gt;
git merge &amp;lt;源分支&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时，&lt;code&gt;C4&apos;&lt;/code&gt; 指向的快照就和 &lt;a href=&quot;https://git-scm.com/book/zh/v2/ch00/ebasing-merging-example&quot;&gt;the merge example&lt;/a&gt; 中 &lt;code&gt;C5&lt;/code&gt; 指向的快照一模一样了。 这两种整合方法的最终结果没有任何区别，但是 &lt;strong&gt;变基使得提交历史更加整洁&lt;/strong&gt;。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的， 但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。&lt;/p&gt;
&lt;p&gt;一般我们这样做的目的是为了确保在向远程分支推送时能保持提交历史的整洁——&lt;strong&gt;例如向某个其他人维护的项目贡献代码时。 在这种情况下，你首先在自己的分支里进行开发，当开发完成时你需要先将你的代码变基到 &lt;code&gt;origin/master&lt;/code&gt; 上，然后再向主项目提交修改&lt;/strong&gt;。 这样的话，该项目的维护者就不再需要进行整合工作，只需要快进合并便可。&lt;/p&gt;
&lt;p&gt;请注意，无论是通过变基，还是通过三方合并，整合的最终结果所指向的快照始终是一样的，只不过提交历史不同罢了。 变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。&lt;/p&gt;
&lt;h3&gt;优点&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;变基的优点： 使提交记录更加整洁。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;更有趣的变基例子&lt;/h2&gt;
&lt;p&gt;在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 &lt;a href=&quot;https://git-scm.com/book/zh/v2/ch00/bdiag_e&quot;&gt;从一个主题分支里再分出一个主题分支的提交历史&lt;/a&gt; 中的例子那样。 你创建了一个主题分支 &lt;code&gt;server&lt;/code&gt;，为服务端添加了一些功能，提交了 &lt;code&gt;C3&lt;/code&gt; 和 &lt;code&gt;C4&lt;/code&gt;。 然后从 &lt;code&gt;C3&lt;/code&gt; 上创建了主题分支 &lt;code&gt;client&lt;/code&gt;，为客户端添加了一些功能，提交了 &lt;code&gt;C8&lt;/code&gt; 和 &lt;code&gt;C9&lt;/code&gt;。 最后，你回到 &lt;code&gt;server&lt;/code&gt; 分支，又提交了 &lt;code&gt;C10&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;更有趣的变基例子&lt;/h3&gt;
&lt;p&gt;在对两个分支进行变基时，所生成的“重放”并不一定要在目标分支上应用，你也可以指定另外的一个分支进行应用。 就像 &lt;a href=&quot;https://git-scm.com/book/zh/v2/ch00/bdiag_e&quot;&gt;从一个主题分支里再分出一个主题分支的提交历史&lt;/a&gt; 中的例子那样。 你创建了一个主题分支 &lt;code&gt;server&lt;/code&gt;，为服务端添加了一些功能，提交了 &lt;code&gt;C3&lt;/code&gt; 和 &lt;code&gt;C4&lt;/code&gt;。 然后从 &lt;code&gt;C3&lt;/code&gt; 上创建了主题分支 &lt;code&gt;client&lt;/code&gt;，为客户端添加了一些功能，提交了 &lt;code&gt;C8&lt;/code&gt; 和 &lt;code&gt;C9&lt;/code&gt;。 最后，你回到 &lt;code&gt;server&lt;/code&gt; 分支，又提交了 &lt;code&gt;C10&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/interesting-rebase-1.png&quot; alt=&quot;从一个主题分支里再分出一个主题分支的提交历史。&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&quot;center&quot;&amp;gt;图4.从一个主题分支里再分出一个主题分支的提交历史 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;假设你希望将 &lt;code&gt;client&lt;/code&gt; 中的修改合并到主分支并发布，但暂时并不想合并 &lt;code&gt;server&lt;/code&gt; 中的修改， 因为它们还需要经过更全面的测试。这时，你就可以使用 &lt;code&gt;git rebase&lt;/code&gt; 命令的 &lt;strong&gt;&lt;code&gt;--onto&lt;/code&gt; 选项， 选中在 &lt;code&gt;client&lt;/code&gt; 分支里但不在 &lt;code&gt;server&lt;/code&gt; 分支里的修改（即 &lt;code&gt;C8&lt;/code&gt; 和 &lt;code&gt;C9&lt;/code&gt;），将它们在 &lt;code&gt;master&lt;/code&gt; 分支上重放&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git rebase --onto master server client
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上命令的意思是：“取出 &lt;code&gt;client&lt;/code&gt; 分支，找出它从 &lt;code&gt;server&lt;/code&gt; 分支分歧之后的补丁， 然后把这些补丁在 &lt;code&gt;master&lt;/code&gt; 分支上重放一遍，让 &lt;code&gt;client&lt;/code&gt; 看起来像直接基于 &lt;code&gt;master&lt;/code&gt; 修改一样”。这理解起来有一点复杂，不过效果非常酷。&lt;/p&gt;
&lt;h3&gt;--onto选项&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;选中C分支中的但不在B分支里的修改，应用到A分支。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/interesting-rebase-2.png&quot; alt=&quot;截取主题分支上的另一个主题分支，然后变基到其他分支。&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&quot;center&quot;&amp;gt;图5.截取主题分支上的另一个主题分支，然后变基到其他分支 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;现在可以快进合并 &lt;code&gt;master&lt;/code&gt; 分支了。（如图 &lt;a href=&quot;https://git-scm.com/book/zh/v2/ch00/bdiag_g&quot;&gt;快进合并 &lt;code&gt;master&lt;/code&gt; 分支，使之包含来自 &lt;code&gt;client&lt;/code&gt; 分支的修改&lt;/a&gt;）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout master
git merge client
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/interesting-rebase-3.png&quot; alt=&quot;快进合并  分支，使之包含来自  分支的修改。&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&quot;center&quot;&amp;gt;图6.快进合并 &lt;code&gt;master&lt;/code&gt; 分支，使之包含来自 &lt;code&gt;client&lt;/code&gt; 分支的修改 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;h3&gt;省去先切换到源分支的步骤&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git rebase &amp;lt;目标(当前)分支&amp;gt; &amp;lt;源分支&amp;gt; # 将源分支变基到目标分支。执行此命令后会自动切换到源分支
git checkout &amp;lt;目标分支&amp;gt;
git merge &amp;lt;源分支&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：使用这个方法要确保源分支上的代码是最新的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;接下来你决定将 &lt;code&gt;server&lt;/code&gt; 分支中的修改也整合进来。 使用 &lt;code&gt;git rebase &amp;lt;basebranch&amp;gt; &amp;lt;topicbranch&amp;gt;&lt;/code&gt; 命令可以直接将主题分支 （即本例中的 &lt;code&gt;server&lt;/code&gt;）变基到目标分支（即 &lt;code&gt;master&lt;/code&gt;）上。 这样做能省去你先切换到 &lt;code&gt;server&lt;/code&gt; 分支，再对其执行变基命令的多个步骤。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git rebase master server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如图 &lt;a href=&quot;https://git-scm.com/book/zh/v2/ch00/bdiag_h&quot;&gt;将 &lt;code&gt;server&lt;/code&gt; 中的修改变基到 &lt;code&gt;master&lt;/code&gt; 上&lt;/a&gt; 所示，&lt;code&gt;server&lt;/code&gt; 中的代码被“续”到了 &lt;code&gt;master&lt;/code&gt; 后面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/interesting-rebase-4.png&quot; alt=&quot;将  中的修改变基到  上。&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&quot;center&quot;&amp;gt;图7.将 &lt;code&gt;server&lt;/code&gt; 中的修改变基到 &lt;code&gt;master&lt;/code&gt; 上 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;然后就可以快进合并主分支 &lt;code&gt;master&lt;/code&gt; 了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout master
git merge server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此，&lt;code&gt;client&lt;/code&gt; 和 &lt;code&gt;server&lt;/code&gt; 分支中的修改都已经整合到主分支里了， 你可以删除这两个分支，最终提交历史会变成图 &lt;a href=&quot;https://git-scm.com/book/zh/v2/ch00/bdiag_i&quot;&gt;最终的提交历史&lt;/a&gt; 中的样子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git branch -d client
git branch -d server
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/interesting-rebase-5.png&quot; alt=&quot;最终的提交历史。&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&quot;center&quot;&amp;gt;图8. 最终的提交历史 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;h2&gt;变基的风险&lt;/h2&gt;
&lt;h3&gt;金科玉律&lt;/h3&gt;
&lt;p&gt;呃，奇妙的变基也并非完美无缺，要用它得遵守一条准则：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。&lt;/p&gt;
&lt;p&gt;::: tip&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;例如：几个人同时在一个主题分支上进行开发和提交时，你不要中途执行变基，只有在大家都完成工作之后才可以执行变基。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
&lt;h3&gt;变基的实质&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。&lt;/strong&gt; 如果你已经将提交推送至某个仓库，而其他人也已经从该仓库拉取提交并进行了后续工作，此时，如果你用 &lt;code&gt;git rebase&lt;/code&gt; 命令重新整理了提交并再次推送，你的同伴因此将不得不再次将他们手头的工作与你的提交进行整合，如果接下来你还要拉取并整合他们修改过的提交，事情就会变得一团糟。&lt;/p&gt;
&lt;p&gt;让我们来看一个在公开的仓库上执行变基操作所带来的问题。 假设你从一个中央服务器克隆然后在它的基础上进行了一些开发。 你的提交历史如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/perils-of-rebasing-1.png&quot; alt=&quot;克隆一个仓库，然后在它的基础上进行了一些开发。&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&quot;center&quot;&amp;gt;图9. 克隆一个仓库，然后在它的基础上进行了一些开发 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;然后，某人又向中央服务器提交了一些修改，其中还包括一次合并。 你抓取了这些在远程分支上的修改，并将其合并到你本地的开发分支，然后你的提交历史就会变成这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/perils-of-rebasing-2.png&quot; alt=&quot;抓取别人的提交，合并到自己的开发分支。&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&quot;center&quot;&amp;gt;图10. 抓取别人的提交，合并到自己的开发分支 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;接下来，这个人又决定把合并操作回滚，改用变基；继而又用 &lt;code&gt;git push --force&lt;/code&gt; 命令覆盖了服务器上的提交历史。 之后你从服务器抓取更新，会发现多出来一些新的提交。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/perils-of-rebasing-3.png&quot; alt=&quot;有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交。&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&quot;center&quot;&amp;gt;图11. 有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;结果就是你们两人的处境都十分尴尬。 如果你执行 &lt;code&gt;git pull&lt;/code&gt; 命令，你将合并来自两条提交历史的内容，生成一个新的合并提交，最终仓库会如图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/perils-of-rebasing-4.png&quot; alt=&quot;你将相同的内容又合并了一次，生成了一个新的提交。&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&quot;center&quot;&amp;gt;图12. 你将相同的内容又合并了一次，生成了一个新的提交 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;此时如果你执行 &lt;code&gt;git log&lt;/code&gt; 命令，你会发现有两个提交的作者、日期、日志居然是一样的，这会令人感到混乱。 此外，如果你将这一堆又推送到服务器上，你实际上是将那些已经被变基抛弃的提交又找了回来，这会令人感到更加混乱。 很明显对方并不想在提交历史中看到 &lt;code&gt;C4&lt;/code&gt; 和 &lt;code&gt;C6&lt;/code&gt;，因为之前就是他把这两个提交通过变基丢弃的。&lt;/p&gt;
&lt;h2&gt;用变基解决变基&lt;/h2&gt;
&lt;p&gt;如果你 &lt;strong&gt;真的&lt;/strong&gt; 遭遇了类似的处境，Git 还有一些高级魔法可以帮到你。 如果团队中的某人强制推送并覆盖了一些你所基于的提交，你需要做的就是检查你做了哪些修改，以及他们覆盖了哪些修改。&lt;/p&gt;
&lt;p&gt;实际上，Git 除了对整个提交计算 SHA-1 校验和以外，也对本次提交所引入的修改计算了校验和——即 “patch-id”。&lt;/p&gt;
&lt;p&gt;如果你拉取被覆盖过的更新并将你手头的工作基于此进行变基的话，一般情况下 Git 都能成功分辨出哪些是你的修改，并把它们应用到新分支上。&lt;/p&gt;
&lt;p&gt;举个例子，如果遇到前面提到的 &lt;a href=&quot;https://git-scm.com/book/zh/v2/ch00/_pre_merge_rebase_work&quot;&gt;有人推送了经过变基的提交，并丢弃了你的本地开发所基于的一些提交&lt;/a&gt; 那种情境，如果我们不是执行合并，而是执行 &lt;code&gt;git rebase teamone/master&lt;/code&gt;, Git 将会：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;检查哪些提交是我们的分支上独有的（C2，C3，C4，C6，C7）&lt;/li&gt;
&lt;li&gt;检查其中哪些提交不是合并操作的结果（C2，C3，C4）&lt;/li&gt;
&lt;li&gt;检查哪些提交在对方覆盖更新时并没有被纳入目标分支（只有 C2 和 C3，因为 C4 其实就是 C4&apos;）&lt;/li&gt;
&lt;li&gt;把查到的这些提交应用在 &lt;code&gt;teamone/master&lt;/code&gt; 上面&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从而我们将得到与 &lt;a href=&quot;https://git-scm.com/book/zh/v2/ch00/_merge_rebase_work&quot;&gt;你将相同的内容又合并了一次，生成了一个新的提交&lt;/a&gt; 中不同的结果，如图 &lt;a href=&quot;https://git-scm.com/book/zh/v2/ch00/_rebase_rebase_work&quot;&gt;在一个被变基然后强制推送的分支上再次执行变基&lt;/a&gt; 所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/perils-of-rebasing-5.png&quot; alt=&quot;在一个被变基然后强制推送的分支上再次执行变基。&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;p align=&quot;center&quot;&amp;gt;图13. 在一个被变基然后强制推送的分支上再次执行变基 ▲&amp;lt;/p&amp;gt;&lt;/p&gt;
&lt;p&gt;要想上述方案有效，还需要对方在变基时确保 &lt;code&gt;C4&apos;&lt;/code&gt; 和 &lt;code&gt;C4&lt;/code&gt; 是几乎一样的。 否则变基操作将无法识别，并新建另一个类似 &lt;code&gt;C4&lt;/code&gt; 的补丁（而这个补丁很可能无法整洁的整合入历史，因为补丁中的修改已经存在于某个地方了）。&lt;/p&gt;
&lt;p&gt;在本例中另一种简单的方法是使用 &lt;code&gt;git pull --rebase&lt;/code&gt; 命令而不是直接 &lt;code&gt;git pull&lt;/code&gt;。 又或者你可以自己手动完成这个过程，先 &lt;code&gt;git fetch&lt;/code&gt;，再 &lt;code&gt;git rebase teamone/master&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果你习惯使用 &lt;code&gt;git pull&lt;/code&gt; ，同时又希望默认使用选项 &lt;code&gt;--rebase&lt;/code&gt;，你可以执行这条语句 &lt;code&gt;git config --global pull.rebase true&lt;/code&gt; 来更改 &lt;code&gt;pull.rebase&lt;/code&gt; 的默认配置。&lt;/p&gt;
&lt;p&gt;如果你只对不会离开你电脑的提交执行变基，那就不会有事。 如果你对已经推送过的提交执行变基，但别人没有基于它的提交，那么也不会有事。 如果你对已经推送至共用仓库的提交上执行变基命令，并因此丢失了一些别人的开发所基于的提交， 那你就有大麻烦了，你的同事也会因此鄙视你。&lt;/p&gt;
&lt;p&gt;如果你或你的同事在某些情形下决意要这么做，请一定要通知每个人执行 &lt;code&gt;git pull --rebase&lt;/code&gt; 命令，这样尽管不能避免伤痛，但能有所缓解。&lt;/p&gt;
&lt;h2&gt;变基 vs. 合并&lt;/h2&gt;
&lt;p&gt;至此，你已在实战中学习了变基和合并的用法，你一定会想问，到底哪种方式更好。 在回答这个问题之前，让我们退后一步，想讨论一下提交历史到底意味着什么。&lt;/p&gt;
&lt;p&gt;有一种观点认为，仓库的提交历史即是 &lt;strong&gt;记录实际发生过什么&lt;/strong&gt;。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用 &lt;em&gt;谎言&lt;/em&gt; 掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。&lt;/p&gt;
&lt;p&gt;另一种观点则正好相反，他们认为提交历史是 &lt;strong&gt;项目过程中发生的事&lt;/strong&gt;。 没人会出版一本书的第一版草稿，软件维护手册也是需要反复修订才能方便使用。 持这一观点的人会使用 &lt;code&gt;rebase&lt;/code&gt; 及 &lt;code&gt;filter-branch&lt;/code&gt; 等工具来编写故事，怎么方便后来的读者就怎么写。&lt;/p&gt;
&lt;p&gt;现在，让我们回到之前的问题上来，到底合并还是变基好？希望你能明白，这并没有一个简单的答案。 Git 是一个非常强大的工具，它允许你对提交历史做许多事情，但每个团队、每个项目对此的需求并不相同。 既然你已经分别学习了两者的用法，相信你能够根据实际情况作出明智的选择。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;总的原则是，只对尚未推送或分享给别人的本地修改执行变基操作清理历史， 从不对已推送至别处的提交执行变基操作，这样，你才能享受到两种方式带来的便利。&lt;/strong&gt;&lt;/p&gt;
</content:encoded></item><item><title>Git工具-查看修订版本</title><link>https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/80git%E5%B7%A5%E5%85%B7-%E6%9F%A5%E7%9C%8B%E4%BF%AE%E8%AE%A2%E7%89%88%E6%9C%AC/</link><guid isPermaLink="true">https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/80git%E5%B7%A5%E5%85%B7-%E6%9F%A5%E7%9C%8B%E4%BF%AE%E8%AE%A2%E7%89%88%E6%9C%AC/</guid><pubDate>Wed, 18 Nov 2020 17:43:57 GMT</pubDate><content:encoded>&lt;p&gt;Git 能够以多种方式来指定单个提交、一组提交、或者一定范围内的提交。 了解它们并不是必需的，但是了解一下总没坏处。&lt;/p&gt;
&lt;p&gt;修订版本指的是：&lt;strong&gt;提交&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;单个修订版本&lt;/h2&gt;
&lt;p&gt;你可以通过任意一个提交的 40 个字符的完整 SHA-1 散列值来指定它， 不过还有很多更人性化的方式来做同样的事情。本节将会介绍获取单个提交的多种方法。&lt;/p&gt;
&lt;h2&gt;简短的 SHA-1&lt;/h2&gt;
&lt;p&gt;Git 十分智能，你只需要提供 SHA-1 的前几个字符就可以获得对应的那次提交， 当然你提供的 SHA-1 字符数量&lt;strong&gt;不得少于 4 个&lt;/strong&gt;，并且没有歧义——也就是说， 当前对象数据库中没有其它对象以这段 SHA-1 开头。&lt;/p&gt;
&lt;p&gt;例如，要查看你知道其中添加了某个功能的提交，首先运行 &lt;code&gt;git log&lt;/code&gt; 命令来定位该提交：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log
commit 734713bc047d87bf7eac9674765ae793478c50d3
Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit &apos;phedders/rdocs&apos;

commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;查看给定SHA-1值的提交&lt;/h3&gt;
&lt;p&gt;在本例中，假设你想要的提交其 SHA-1 以 &lt;code&gt;1c002dd....&lt;/code&gt; 开头， 那么你可以用如下几种 &lt;code&gt;git show&lt;/code&gt; 的变体来检视该提交（假设简短的版本没有歧义）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b
git show 1c002dd4b536e7479f
git show 1c002d
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Git 可以为 SHA-1 值生成出简短且唯一的缩写。 如果你在 &lt;code&gt;git log&lt;/code&gt; 后加上 &lt;code&gt;--abbrev-commit&lt;/code&gt; 参数，输出结果里就会显示简短且唯一的值； 默认使用七个字符，不过有时为了避免 SHA-1 的歧义，会增加字符数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log --abbrev-commit --pretty=oneline
ca82a6d changed the version number
085bb3b removed unnecessary test code
a11bef0 first commit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通常 8 到 10 个字符就已经足够在一个项目中避免 SHA-1 的歧义。 例如，到 2019 年 2 月为止，Linux 内核这个相当大的 Git 项目， 其对象数据库中有超过 875,000 个提交，包含七百万个对象，也只需要前 12 个字符就能保证唯一性。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Note&lt;/th&gt;
&lt;th&gt;关于 SHA-1 的简短说明许多人觉得他们的仓库里有可能出现两个不同的对象其 SHA-1 值相同。 然后呢？如果你真的向仓库里提交了一个对象，它跟之前的某个 &lt;strong&gt;不同&lt;/strong&gt; 对象的 SHA-1 值相同， Git 会发现该对象的散列值已经存在于仓库里了，于是就会认为该对象被写入，然后直接使用它。 如果之后你想检出那个对象时，你将得到先前那个对象的数据。但是这种情况发生的概率十分渺小。 SHA-1 摘要长度是 20 字节，也就是 160 位。 2^80 个随机哈希对象才有 50% 的概率出现一次冲突 （计算冲突机率的公式是 &lt;code&gt;p = (n(n-1)/2) * (1/2^160))&lt;/code&gt; ）。 2^80 是 1.2 x 10^24，也就是一亿亿亿，这是地球上沙粒总数的 1200 倍。举例说一下怎样才能产生一次 SHA-1 冲突。 如果地球上 65 亿个人类都在编程，每人每秒都在产生等价于整个 Linux 内核历史（650 万个 Git 对象）的代码， 并将之提交到一个巨大的 Git 仓库里面，这样持续两年的时间才会产生足够的对象， 使其拥有 50% 的概率产生一次 SHA-1 对象冲突， 这比你编程团队的成员同一个晚上在互不相干的意外中被狼袭击并杀死的机率还要小。&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;分支引用&lt;/h2&gt;
&lt;p&gt;引用特定提交的一种直接方法是，若它是一个分支的顶端的提交， 那么可以在任何需要引用该提交的 Git 命令中直接使用该分支的名称。&lt;/p&gt;
&lt;h3&gt;查看最后一次提交&lt;/h3&gt;
&lt;p&gt;例如，你想要查看一个分支的最后一次提交的对象，假设 &lt;code&gt;topic1&lt;/code&gt; 分支指向提交 &lt;code&gt;ca82a6d...&lt;/code&gt; ， 那么以下的命令是等价的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git show ca82a6dff817ec66f44342007202690a93763949
git show topic1  # topic1是分支名
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你想知道某个分支指向哪个特定的 SHA-1，或者想看任何一个例子中被简写的 SHA-1， 你可以使用一个叫做 &lt;code&gt;rev-parse&lt;/code&gt; 的 Git 探测工具。 你可以在 &lt;a href=&quot;https://git-scm.com/book/zh/v2/ch00/ch10-git-internals&quot;&gt;Git 内部原理&lt;/a&gt; 中查看更多关于探测工具的信息。 简单来说，&lt;code&gt;rev-parse&lt;/code&gt; 是为了底层操作而不是日常操作设计的。 不过，有时你想看 Git 现在到底处于什么状态时，它可能会很有用。 你可以在你的分支上执行 &lt;code&gt;rev-parse&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git rev-parse topic1
ca82a6dff817ec66f44342007202690a93763949
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;引用日志&lt;/h2&gt;
&lt;h3&gt;HEAD的指向历史&lt;/h3&gt;
&lt;p&gt;当你在工作时， Git 会在后台保存一个引用日志（reflog）， 引用日志记录了最近几个月你的 HEAD 和分支引用所指向的历史。&lt;/p&gt;
&lt;p&gt;你可以使用 &lt;code&gt;git reflog&lt;/code&gt; 来查看引用日志&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git reflog
734713b HEAD@{0}: commit: fixed refs handling, added gc auto, updated
d921970 HEAD@{1}: merge phedders/rdocs: Merge made by the &apos;recursive&apos; strategy.
1c002dd HEAD@{2}: commit: added some blame and merge stuff
1c36188 HEAD@{3}: rebase -i (squash): updating HEAD
95df984 HEAD@{4}: commit: # This is a combination of two commits.
1c36188 HEAD@{5}: rebase -i (squash): updating HEAD
7e05da5 HEAD@{6}: rebase -i (pick): updating HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每当你的 HEAD 所指向的位置发生了变化，Git 就会将这个信息存储到引用日志这个历史记录里。 你也可以通过 reflog 数据来获取之前的提交历史。 如果你想查看仓库中 HEAD 在五次前的所指向的提交，你可以使用 &lt;code&gt;@{n}&lt;/code&gt; 来引用 reflog 中输出的提交记录。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git show HEAD@{5}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你同样可以使用这个语法来查看某个分支在一定时间前的位置。 例如，查看你的 &lt;code&gt;master&lt;/code&gt; 分支在昨天的时候指向了哪个提交，你可以输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git show master@{yesterday}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;就会显示昨天 &lt;code&gt;master&lt;/code&gt; 分支的顶端指向了哪个提交。 这个方法只对还在你引用日志里的数据有用，所以不能用来查好几个月之前的提交。&lt;/p&gt;
&lt;p&gt;可以运行 &lt;code&gt;git log -g&lt;/code&gt; 来查看类似于 &lt;code&gt;git log&lt;/code&gt; 输出格式的引用日志信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log -g master
commit 734713bc047d87bf7eac9674765ae793478c50d3
Reflog: master@{0} (Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;)
Reflog message: commit: fixed refs handling, added gc auto, updated
Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;
Date:   Fri Jan 2 18:32:33 2009 -0800

    fixed refs handling, added gc auto, updated tests

commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Reflog: master@{1} (Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;)
Reflog message: merge phedders/rdocs: Merge made by recursive.
Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit &apos;phedders/rdocs&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;值得注意的是，&lt;strong&gt;引用日志只存在于本地仓库，它只是一个记录你在 自己 的仓库里做过什么的日志&lt;/strong&gt;。 其他人拷贝的仓库里的引用日志不会和你的相同，而你新克隆一个仓库的时候，引用日志是空的，因为你在仓库里还没有操作。 &lt;code&gt;git show HEAD@{2.months.ago}&lt;/code&gt; 这条命令只有在你克隆了一个项目至少两个月时才会显示匹配的提交—— 如果你刚刚克隆了仓库，那么它将不会有任何结果返回。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Tip&lt;/th&gt;
&lt;th&gt;将引用日志想作 Git 版的 shell 历史记录如果你有 UNIX 或者 Linux 的背景，不妨将引用日志想作 Git 版的 shell 历史记录， 重点在于仅与你和你的会话相关，而与他人无关。&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;祖先引用&lt;/h2&gt;
&lt;p&gt;祖先引用是另一种指明一个提交的方式。 如果你在引用的尾部加上一个 &lt;code&gt;^&lt;/code&gt;（脱字符）， Git 会将其解析为该引用的上一个提交。 假设你的提交历史是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log --pretty=format:&apos;%h %s&apos; --graph
* 734713b fixed refs handling, added gc auto, updated tests
*   d921970 Merge commit &apos;phedders/rdocs&apos;
|\
| * 35cfb2b Some rdoc changes
* | 1c002dd added some blame and merge stuff
|/
* 1c36188 ignore *.gem
* 9b29157 add open3_detach to gemspec file list
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你可以使用 &lt;code&gt;HEAD^&lt;/code&gt; 来查看上一个提交，也就是 “&lt;strong&gt;HEAD 的父提交&lt;/strong&gt;”：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git show HEAD^
commit d921970aadf03b3cf0e71becdaab3147ba71cdef
Merge: 1c002dd... 35cfb2b...
Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;
Date:   Thu Dec 11 15:08:43 2008 -0800

    Merge commit &apos;phedders/rdocs&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Note&lt;/th&gt;
&lt;th&gt;在 Windows 上转义脱字符在 Windows 的 &lt;code&gt;cmd.exe&lt;/code&gt; 中，&lt;code&gt;^&lt;/code&gt; 是一个特殊字符，因此需要区别对待。 你可以双写它或者将提交引用放在引号中：&lt;code&gt;$ git show HEAD^     # 在 Windows 上无法工作 $ git show HEAD^^    # 可以 $ git show &quot;HEAD^&quot;   # 可以&lt;/code&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;你也可以在 &lt;code&gt;^&lt;/code&gt; 后面添加一个数字来指明想要 &lt;strong&gt;哪一个&lt;/strong&gt; 父提交——例如 &lt;code&gt;d921970^2&lt;/code&gt; 代表 “d921970 的第二父提交” 这个语法只适用于合并的提交，因为合并提交会有多个父提交。 合并提交的第一父提交是你合并时所在分支（通常为 &lt;code&gt;master&lt;/code&gt;），而第二父提交是你所合并的分支（例如 &lt;code&gt;topic&lt;/code&gt;）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git show d921970^
commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
Author: Scott Chacon &amp;lt;schacon@gmail.com&amp;gt;
Date:   Thu Dec 11 14:58:32 2008 -0800

    added some blame and merge stuff

$ git show d921970^2
commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548
Author: Paul Hedderly &amp;lt;paul+git@mjr.org&amp;gt;
Date:   Wed Dec 10 22:22:03 2008 +0000

    Some rdoc changes
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另一种指明祖先提交的方法是 &lt;code&gt;~&lt;/code&gt;（波浪号）。 同样是指向第一父提交，因此 &lt;code&gt;HEAD~&lt;/code&gt; 和 &lt;code&gt;HEAD^&lt;/code&gt; 是等价的。 而区别在于你在后面加数字的时候。 &lt;code&gt;HEAD~2&lt;/code&gt; 代表“第一父提交的第一父提交”，也就是“祖父提交”——Git 会根据你指定的次数获取对应的第一父提交。 例如，在之前的列出的提交历史中，&lt;code&gt;HEAD~3&lt;/code&gt; 就是&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git show HEAD~3
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner &amp;lt;tom@mojombo.com&amp;gt;
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以写成 &lt;code&gt;HEAD~~~&lt;/code&gt;，也是第一父提交的第一父提交的第一父提交：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git show HEAD~~~
commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
Author: Tom Preston-Werner &amp;lt;tom@mojombo.com&amp;gt;
Date:   Fri Nov 7 13:47:59 2008 -0500

    ignore *.gem
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你也可以组合使用这两个语法——你可以通过 &lt;code&gt;HEAD~3^2&lt;/code&gt; 来取得之前引用的第二父提交（假设它是一个合并提交）。&lt;/p&gt;
&lt;h2&gt;提交区间&lt;/h2&gt;
&lt;p&gt;你已经学会如何单次的提交，现在来看看如何指明一定区间的提交。 当你有很多分支时，这对管理你的分支时十分有用， 你可以用提交区间来解决“这个分支还有哪些提交尚未合并到主分支？”的问题&lt;/p&gt;
&lt;h3&gt;双点&lt;/h3&gt;
&lt;p&gt;最常用的指明提交区间语法是双点。 这种语法可以让 Git 选出在一个分支中而不在另一个分支中的提交。 例如，你有如下的提交历史 &lt;a href=&quot;https://git-scm.com/book/zh/v2/ch00/double_dot&quot;&gt;Example history for range selection.&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://git-scm.com/book/en/v2/images/double-dot.png&quot; alt=&quot;Example history for range selection.&quot; /&gt;&lt;/p&gt;
&lt;p&gt;Figure 137. Example history for range selection.&lt;/p&gt;
&lt;p&gt;你想要查看 experiment 分支中还有哪些提交尚未被合并入 master 分支。 你可以使用 &lt;code&gt;master..experiment&lt;/code&gt; 来让 Git 显示这些提交。也就是“在 experiment 分支中而不在 master 分支中的提交”。 为了使例子简单明了，我使用了示意图中提交对象的字母来代替真实日志的输出，所以会显示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log master..experiment
D
C
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;反过来，如果你想查看在 &lt;code&gt;master&lt;/code&gt; 分支中而不在 &lt;code&gt;experiment&lt;/code&gt; 分支中的提交，你只要交换分支名即可。 &lt;code&gt;experiment..master&lt;/code&gt; 会显示在 &lt;code&gt;master&lt;/code&gt; 分支中而不在 &lt;code&gt;experiment&lt;/code&gt; 分支中的提交：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log experiment..master
F
E
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;查看即将推送到远端的内容&lt;/h4&gt;
&lt;p&gt;这可以让你保持 &lt;code&gt;experiment&lt;/code&gt; 分支跟随最新的进度以及查看你即将合并的内容。 另一个常用的场景是查看你即将推送到远端的内容：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git log origin/master..HEAD
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令会输出在你当前分支中而不在远程 &lt;code&gt;origin&lt;/code&gt; 中的提交。 如果你执行 &lt;code&gt;git push&lt;/code&gt; 并且你的当前分支正在跟踪 &lt;code&gt;origin/master&lt;/code&gt;，由 &lt;code&gt;git log origin/master..HEAD&lt;/code&gt; 所输出的提交就是会被传输到远端服务器的提交。如果你留空了其中的一边， Git 会默认为 &lt;code&gt;HEAD&lt;/code&gt;。 例如， &lt;code&gt;git log origin/master..&lt;/code&gt; 将会输出与之前例子相同的结果 —— Git 使用 HEAD 来代替留空的一边。&lt;/p&gt;
&lt;h3&gt;多点&lt;/h3&gt;
&lt;p&gt;双点语法很好用，但有时候你可能需要两个以上的分支才能确定你所需要的修订， 比如查看哪些提交是被包含在某些分支中的一个，但是不在你当前的分支上。 Git 允许你在任意引用前加上 &lt;code&gt;^&lt;/code&gt; 字符或者 &lt;code&gt;--not&lt;/code&gt; 来指明你不希望提交被包含其中的分支。 因此下列三个命令是等价的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git log refA..refB
git log ^refA refB
git log refB --not refA
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个语法很好用，因为你可以在查询中指定超过两个的引用，这是双点语法无法实现的。 比如，你想查看所有被 &lt;code&gt;refA&lt;/code&gt; 或 &lt;code&gt;refB&lt;/code&gt; 包含的但是不被 &lt;code&gt;refC&lt;/code&gt; 包含的提交，你可以使用以下任意一个命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git log refA refB ^refC
git log refA refB --not refC
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这就构成了一个十分强大的修订查询系统，你可以通过它来查看你的分支里包含了哪些东西。&lt;/p&gt;
&lt;h3&gt;三点&lt;/h3&gt;
&lt;p&gt;最后一种主要的区间选择语法是三点，这个语法可以选择出被两个引用 &lt;strong&gt;之一&lt;/strong&gt; 包含但又不被两者同时包含的提交。 再看看之前双点例子中的提交历史。 如果你想看 &lt;code&gt;master&lt;/code&gt; 或者 &lt;code&gt;experiment&lt;/code&gt; 中包含的但不是两者共有的提交，你可以执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log master...experiment
F
E
D
C
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这和通常 &lt;code&gt;log&lt;/code&gt; 按日期排序的输出一样，仅仅给出了4个提交的信息。&lt;/p&gt;
&lt;p&gt;这种情形下，&lt;code&gt;log&lt;/code&gt; 命令的一个常用参数是 &lt;code&gt;--left-right&lt;/code&gt;，它会显示每个提交到底处于哪一侧的分支。 这会让输出数据更加清晰。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log --left-right master...experiment
&amp;lt; F
&amp;lt; E
&amp;gt; D
&amp;gt; C
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有了这些工具，你就可以十分方便地查看你 Git 仓库中的提交。&lt;/p&gt;
</content:encoded></item><item><title>Git工具-交互式暂存</title><link>https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/90git%E5%B7%A5%E5%85%B7-%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%9A%82%E5%AD%98/</link><guid isPermaLink="true">https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/90git%E5%B7%A5%E5%85%B7-%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%9A%82%E5%AD%98/</guid><pubDate>Wed, 18 Nov 2020 17:43:57 GMT</pubDate><content:encoded>&lt;p&gt;本节中的几个交互式 Git 命令可以帮助你将文件的特定部分组合成提交。 当你在修改了大量文件后，希望这些改动能拆分为若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 &lt;code&gt;git add&lt;/code&gt; 时使用 &lt;code&gt;-i&lt;/code&gt; 或者 &lt;code&gt;--interactive&lt;/code&gt; 选项，Git 将会进入一个交互式终端模式，显示类似下面的东西：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git add -i
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb

*** Commands ***
  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked
  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp
What now&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到这个命令以和平时非常不同的视图显示了暂存区——基本上与 &lt;code&gt;git status&lt;/code&gt; 是相同的信息，但是更简明扼要一些。 它将暂存的修改列在左侧，未暂存的修改列在右侧。&lt;/p&gt;
&lt;p&gt;在这块区域后是“Commands”命令区域。 在这里你可以做一些工作，包括暂存文件、取消暂存文件、暂存文件的一部分、添加未被追踪的文件、显示暂存内容的区别。&lt;/p&gt;
&lt;h2&gt;暂存与取消暂存文件&lt;/h2&gt;
&lt;p&gt;如果在 &lt;code&gt;What now&amp;gt;&lt;/code&gt; 提示符后键入 &lt;code&gt;u&lt;/code&gt; 或 &lt;code&gt;2&lt;/code&gt;（更新），它会问你想要暂存哪个文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;What now&amp;gt; u
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Update&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要暂存 &lt;code&gt;TODO&lt;/code&gt; 和 &lt;code&gt;index.html&lt;/code&gt; 文件，可以输入数字：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Update&amp;gt;&amp;gt; 1,2
           staged     unstaged path
* 1:    unchanged        +0/-1 TODO
* 2:    unchanged        +1/-1 index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Update&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每个文件前面的 &lt;code&gt;*&lt;/code&gt; 意味着选中的文件将会被暂存。 如果在 &lt;code&gt;Update&amp;gt;&amp;gt;&lt;/code&gt; 提示符后不输入任何东西并直接按回车，Git 将会暂存之前选择的文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Update&amp;gt;&amp;gt;
updated 2 paths

*** Commands ***
  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked
  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp
What now&amp;gt; s
           staged     unstaged path
  1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在可以看到 &lt;code&gt;TODO&lt;/code&gt; 与 &lt;code&gt;index.html&lt;/code&gt; 文件已经被暂存而 &lt;code&gt;simplegit.rb&lt;/code&gt; 文件还未被暂存。 如果这时想要取消暂存 TODO 文件，使用 &lt;code&gt;r&lt;/code&gt; 或 &lt;code&gt;3&lt;/code&gt;（撤消）选项：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*** Commands ***
  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked
  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp
What now&amp;gt; r
           staged     unstaged path
  1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Revert&amp;gt;&amp;gt; 1
           staged     unstaged path
* 1:        +0/-1      nothing TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
Revert&amp;gt;&amp;gt; [enter]
reverted one path
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再次查看 Git 状态，可以看到已经取消暂存 &lt;code&gt;TODO&lt;/code&gt; 文件：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*** Commands ***
  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked
  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp
What now&amp;gt; s
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:        +1/-1      nothing index.html
  3:    unchanged        +5/-1 lib/simplegit.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果想要查看已暂存内容的区别，可以使用 &lt;code&gt;d&lt;/code&gt; 或 &lt;code&gt;6&lt;/code&gt;（区别）命令。 它会显示暂存文件的一个列表，可以从中选择想要查看的暂存区别。 这跟你在命令行指定 &lt;code&gt;git diff --cached&lt;/code&gt; 非常相似：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*** Commands ***
  1: [s]tatus     2: [u]pdate      3: [r]evert     4: [a]dd untracked
  5: [p]atch      6: [d]iff        7: [q]uit       8: [h]elp
What now&amp;gt; d
           staged     unstaged path
  1:        +1/-1      nothing index.html
Review diff&amp;gt;&amp;gt; 1
diff --git a/index.html b/index.html
index 4d07108..4335f49 100644
--- a/index.html
+++ b/index.html
@@ -16,7 +16,7 @@ Date Finder

 &amp;lt;p id=&quot;out&quot;&amp;gt;...&amp;lt;/p&amp;gt;

-&amp;lt;div id=&quot;footer&quot;&amp;gt;contact : support@github.com&amp;lt;/div&amp;gt;
+&amp;lt;div id=&quot;footer&quot;&amp;gt;contact : email.support@github.com&amp;lt;/div&amp;gt;

 &amp;lt;script type=&quot;text/javascript&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过这些基本命令，可以使用交互式添加模式来轻松地处理暂存区。&lt;/p&gt;
&lt;h2&gt;暂存补丁&lt;/h2&gt;
&lt;p&gt;Git 也可以暂存文件的特定部分。 例如，如果在 simplegit.rb 文件中做了两处修改，但只想要暂存其中的一个而不是另一个，Git 会帮你轻松地完成。 在和上一节一样的交互式提示符中，输入 &lt;code&gt;p&lt;/code&gt; 或 &lt;code&gt;5&lt;/code&gt;（补丁）。 Git 会询问你想要部分暂存哪些文件；然后，对已选择文件的每一个部分，它都会一个个地显示文件区别并询问你是否想要暂存它们：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;diff --git a/lib/simplegit.rb b/lib/simplegit.rb
index dd5ecc4..57399e0 100644
--- a/lib/simplegit.rb
+++ b/lib/simplegit.rb
@@ -22,7 +22,7 @@ class SimpleGit
   end

   def log(treeish = &apos;master&apos;)
-    command(&quot;git log -n 25 #{treeish}&quot;)
+    command(&quot;git log -n 30 #{treeish}&quot;)
   end

   def blame(path)
Stage this hunk [y,n,a,d,/,j,J,g,e,?]?
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时有很多选项。 输入 &lt;code&gt;?&lt;/code&gt; 显示所有可以使用的命令列表：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ?
y - stage this hunk
n - do not stage this hunk
a - stage this and all the remaining hunks in the file
d - do not stage this hunk nor any of the remaining hunks in the file
g - select a hunk to go to
/ - search for a hunk matching the given regex
j - leave this hunk undecided, see next undecided hunk
J - leave this hunk undecided, see next hunk
k - leave this hunk undecided, see previous undecided hunk
K - leave this hunk undecided, see previous hunk
s - split the current hunk into smaller hunks
e - manually edit the current hunk
? - print help
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通常情况下可以输入 &lt;code&gt;y&lt;/code&gt; 或 &lt;code&gt;n&lt;/code&gt; 来选择是否要暂存每一个区块， 当然，暂存特定文件中的所有部分或为之后的选择跳过一个区块也是非常有用的。 如果你只暂存文件的一部分，状态输出可能会像下面这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;What now&amp;gt; 1
           staged     unstaged path
  1:    unchanged        +0/-1 TODO
  2:        +1/-1      nothing index.html
  3:        +1/-1        +4/-0 lib/simplegit.rb
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;simplegit.rb&lt;/code&gt; 文件的状态很有趣。 它显示出若干行被暂存与若干行未被暂存。 已经部分地暂存了这个文件。 在这时，可以退出交互式添加脚本并且运行 &lt;code&gt;git commit&lt;/code&gt; 来提交部分暂存的文件。&lt;/p&gt;
&lt;p&gt;也可以不必在交互式添加模式中做部分文件暂存——可以在命令行中使用 &lt;code&gt;git add -p&lt;/code&gt; 或 &lt;code&gt;git add --patch&lt;/code&gt; 来启动同样的脚本。&lt;/p&gt;
&lt;p&gt;更进一步地，可以使用 &lt;code&gt;git reset --patch&lt;/code&gt; 命令的补丁模式来部分重置文件， 通过 &lt;code&gt;git checkout --patch&lt;/code&gt; 命令来部分检出文件与 &lt;code&gt;git stash save --patch&lt;/code&gt; 命令来部分暂存文件。 我们将会在接触这些命令的高级使用方法时了解更多详细信息。&lt;/p&gt;
</content:encoded></item><item><title>Git分支的新建与合并-分支操作</title><link>https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/30git%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6-%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C/</link><guid isPermaLink="true">https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/30git%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6-%E5%88%86%E6%94%AF%E6%93%8D%E4%BD%9C/</guid><pubDate>Wed, 18 Nov 2020 17:43:57 GMT</pubDate><content:encoded>&lt;p&gt;文档：&lt;a href=&quot;https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6&quot;&gt;Git 分支 - 分支的新建与合并&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;创建分支并切换&lt;/h3&gt;
&lt;p&gt;此时有一个需求需要在新的分支&lt;code&gt;iss53&lt;/code&gt;上工作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout -b iss53  # b表示branch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它是下面两条命令的简写：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git branch iss53
git checkout iss53
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;切换分支&lt;/h3&gt;
&lt;p&gt;突然有一个紧急问题要解决，需要在原来的&lt;code&gt;master&lt;/code&gt;分支进行修复：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在切换到&lt;code&gt;master&lt;/code&gt;之前，需要&lt;code&gt;iss53&lt;/code&gt;分支保持好一个干净的状态（修改都已提交）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：切换分支Git 会重置你的工作目录。&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;checkout&lt;/code&gt; 中文含义 “检出”，&lt;code&gt;checkout &amp;lt;branch&amp;gt;&lt;/code&gt; 检出分支 =&amp;gt; 检出指定分支的代码 =&amp;gt; 重置工作目录并切换分支。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来，你要修复这个紧急问题。 建立一个 &lt;code&gt;hotfix&lt;/code&gt; 分支，在该分支上工作直到问题解决：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git checkout -b hotfix

# 中间过程在hotfix上修改了代码并提交
$ echo &apos;test&apos; &amp;gt; ./hotfix.txt
$ git add .
$ git commit -m &apos;fixed&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;合并分支&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git checkout master # 首先切回master分支
git merge hotfix # 把 hotfix 分支合并过来
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;删除分支&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;$ git branch -d hotfix # d表示delete

# 然后切回iss53继续工作
$ git checkout iss53
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意删除分支是在 &lt;code&gt;branch&lt;/code&gt; 命令上&lt;/p&gt;
&lt;h3&gt;多次提交之后合并分支&lt;/h3&gt;
&lt;p&gt;假设你已经修正了 #53 问题，打算合并到&lt;code&gt;master&lt;/code&gt;分支：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git checkout master
git merga iss53
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这看似和之前的合并区别不大。此时你的开发历史从一个更早的地方开始分叉开来（diverged）。 因为，&lt;code&gt;master&lt;/code&gt; 分支所在提交并不是 &lt;code&gt;iss53&lt;/code&gt; 分支所在提交的直接祖先，Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照以及这两个分支的公共祖先，做一个简单的&lt;strong&gt;三方合并&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;和之前将分支指针向前推进所不同的是，&lt;strong&gt;Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它&lt;/strong&gt;。 这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。&lt;/p&gt;
&lt;h3&gt;遇到冲突时的分支合并&lt;/h3&gt;
&lt;p&gt;如果你在两个不同的分支中，&lt;strong&gt;对同一个文件的同一个部分进行了不同的修改&lt;/strong&gt;，Git 就没法干净的合并它们，就产生了冲突。&lt;/p&gt;
&lt;p&gt;合并过程中出现&lt;code&gt;CONFLICT&lt;/code&gt;提升，表示有冲突&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;git status&lt;/code&gt;查看未合并状态。&lt;/p&gt;
&lt;p&gt;任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。 &lt;strong&gt;Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。&lt;/strong&gt; 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD:index.html
&amp;lt;div id=&quot;footer&quot;&amp;gt;contact : email.support@github.com&amp;lt;/div&amp;gt;
=======
&amp;lt;div id=&quot;footer&quot;&amp;gt;
 please contact us at support@github.com
&amp;lt;/div&amp;gt;
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; iss53:index.html
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你需要&lt;strong&gt;手动解决冲突&lt;/strong&gt;，解决了所有文件里的冲突之后，对每个文件&lt;strong&gt;使用 &lt;code&gt;git add&lt;/code&gt; 命令&lt;/strong&gt;来将其标记为冲突已解决。 &lt;strong&gt;一旦暂存这些原本有冲突的文件，Git 就会将它们标记为冲突已解决&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 &lt;code&gt;git commit&lt;/code&gt; 来完成合并提交。&lt;/p&gt;
</content:encoded></item><item><title>Git基础与命令</title><link>https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/10git%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%91%BD%E4%BB%A4/</link><guid isPermaLink="true">https://newpower.pro/posts/git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%96%87%E6%A1%A3%E7%AC%94%E8%AE%B0/10git%E5%9F%BA%E7%A1%80%E4%B8%8E%E5%91%BD%E4%BB%A4/</guid><pubDate>Wed, 18 Nov 2020 17:43:57 GMT</pubDate><content:encoded>&lt;p&gt;官方文档（中文）：&lt;a href=&quot;https://git-scm.com/book/zh/v2&quot;&gt;https://git-scm.com/book/zh/v2&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文档是根据官方文档来编写的，以官方文档为准。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;Git基础&lt;/h2&gt;
&lt;h3&gt;全局配置&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git config --global user.name &apos;your name&apos;
git config --global user.email &apos;xxx@xx.com&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;自报家门&lt;/p&gt;
&lt;h3&gt;检查配置信息&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git config --list
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;获取帮助&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 获取全局帮助手册
git help

# 获取特定命令的详细版帮助手册 (两个命令是等价的)
git help &amp;lt;某个命令&amp;gt;
git &amp;lt;某个命令&amp;gt; --help # 两个横杠

# 获取特定命令的简明版帮助手册
git &amp;lt;某个命令&amp;gt; -h  # 一个横杠
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;初始化仓库&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 本地目录初始化仓库
git init
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果你是从远程仓库clone的项目，则该项目是已经初始化好的git仓库&lt;/p&gt;
&lt;h3&gt;克隆远程仓库&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 克隆
git clone &amp;lt;url&amp;gt;

# 克隆同时修改目录名
git clone &amp;lt;url&amp;gt; &amp;lt;name&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态，因为 Git 刚刚检出了它们， 而你尚未编辑过它们&lt;/p&gt;
&lt;h3&gt;检查文件状态&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 查看详细状态说明
git status

# 查看简明状态说明
git status -s  # -s 或 --short
 M README # 已修改，但未暂存 （M的位置靠右，红色）
MM Rakefile # 已修改，暂存后又作了修改（有暂存和未暂存）
A  lib/git.rb # 新添加到暂存区，未提交
M  lib/simplegit.rb # 已修改，已暂存 （M的位置靠左，绿色）
?? LICENSE.txt # 新添加，未跟踪
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;git目录中的文件状态包含：是否跟踪、是否修改、是否已存入暂存区&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数的&lt;strong&gt;一个横杠表示缩写，两个横杠表示全称。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;加入暂存区 (跟踪文件)&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 文件加入暂存区（跟踪指定文件)
git add &amp;lt;files&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;git add&lt;/code&gt; 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;add&lt;/code&gt; 命令是将文件&lt;strong&gt;加入&lt;/strong&gt;到&lt;strong&gt;暂存区&lt;/strong&gt;，&lt;code&gt;commit&lt;/code&gt; 命令的&lt;strong&gt;提交&lt;/strong&gt;到&lt;strong&gt;本地仓库&lt;/strong&gt;，&lt;code&gt;push&lt;/code&gt; 命令是&lt;strong&gt;推送&lt;/strong&gt;到&lt;strong&gt;远程仓库&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;忽略文件&lt;/h3&gt;
&lt;p&gt;添加一个名为 &lt;code&gt;.gitignore&lt;/code&gt; 的文件，列出要忽略的文件的模式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;*.[oa]  # 忽略以 .o 或 .a 结尾的文件（一般这类文件是编译过程出现）
*~      # 忽略以 ~ 结尾的文件（一般是文本编辑软件保存的副本）
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;文件 &lt;code&gt;.gitignore&lt;/code&gt; 的&lt;strong&gt;格式规范&lt;/strong&gt;如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;所有空行或者以 &lt;code&gt;#&lt;/code&gt; 开头的行都会被 Git 忽略（注释符号）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;glob 模式是指 shell 所使用的简化了的正则表达式&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;匹配模式可以以（&lt;code&gt;/&lt;/code&gt;）开头防止递归。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;匹配模式可以以（&lt;code&gt;/&lt;/code&gt;）结尾指定目录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;要忽略指定模式以外的文件或目录，可以在模式前加上叹号（&lt;code&gt;!&lt;/code&gt;）取反。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;ul&gt;
&lt;li&gt;星号（&lt;code&gt;*&lt;/code&gt;）匹配零个或多个任意字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[abc]&lt;/code&gt; 匹配任何一个列在方括号中的字符 （这个例子要么匹配一个 a，要么匹配一个 b，要么匹配一个 c）&lt;/li&gt;
&lt;li&gt;问号（&lt;code&gt;?&lt;/code&gt;）只匹配一个任意字符&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[0-9]&lt;/code&gt; 表示匹配所有 0 到 9 的数字。在方括号中使用短划线分隔两个字符， 表示所有在这两个字符范围内的都可以匹配&lt;/li&gt;
&lt;li&gt;使用两个星号（&lt;code&gt;**&lt;/code&gt;）表示匹配任意中间目录，比如 &lt;code&gt;a/**/z&lt;/code&gt; 可以匹配 &lt;code&gt;a/z&lt;/code&gt; 、 &lt;code&gt;a/b/z&lt;/code&gt; 或 &lt;code&gt;a/b/c/z&lt;/code&gt; 等。&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# 忽略所有的 .a 文件
*.a

# 但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件
!lib.a

# 只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO
/TODO

# 忽略任何目录下名为 build 的文件夹
build/

# 忽略 doc/notes.txt，但不忽略 doc/server/arch.txt
doc/*.txt

# 忽略 doc/ 目录及其所有子目录下的 .pdf 文件
doc/**/*.pdf
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;GitHub 有一个十分详细的针对数十种项目及语言的 &lt;code&gt;.gitignore&lt;/code&gt; 文件列表， 你可以在 &lt;a href=&quot;https://github.com/github/gitignore&quot;&gt;https://github.com/github/gitignore&lt;/a&gt; 找到它。&lt;/p&gt;
&lt;h3&gt;查看修改的具体内容&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git diff # 比较修改之后还没有暂存起来的变化内容。

git diff --staged # 查看已暂存的将要添加到下次提交里的内容
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;git status&lt;/code&gt; 只能查看文件变动的状态，并不能查看具体修改了哪些内容。使用&lt;code&gt;git diff&lt;/code&gt;可以看到具体变动的内容。&lt;/p&gt;
&lt;h3&gt;提交更新&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git commit # 未带参数的会打开默认文本编辑器让你输入提交说明

git commit -m &apos;提交说明&apos; # 带-m参数直接输入提交说明
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用&lt;code&gt;git commit&lt;/code&gt;提交更新，在此之前，务必确认所有变动已经被&lt;code&gt;git add&lt;/code&gt;添加到暂存区。&lt;/p&gt;
&lt;h3&gt;跳过使用暂存区域&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git commit -a -m &apos;提交说明&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加&lt;code&gt;-a&lt;/code&gt;选项可以跳过&lt;code&gt;git add&lt;/code&gt; 步骤，把已经跟踪过的文件一并提交。&lt;/p&gt;
&lt;p&gt;注意：这个操作&lt;strong&gt;无法提交未跟踪&lt;/strong&gt;的文件。&lt;/p&gt;
&lt;h2&gt;Git 基础 - 查看提交历史&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;git log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不传入任何参数的默认情况下，&lt;code&gt;git log&lt;/code&gt; 会按时间先后顺序列出所有的提交，最近的更新排在最上面。&lt;/p&gt;
&lt;p&gt;此命令打印的数据中有一项是一长串的 &lt;code&gt;SHA-1&lt;/code&gt; 校验码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;带入&lt;code&gt;-p&lt;/code&gt;或&lt;code&gt;--patch&lt;/code&gt;查看提交的具体差异：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git log -p -2 # -p显示差异  -2显示最近的提交次数
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;--stat&lt;/code&gt; 显示每次提交的差异统计&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git log --stat
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;--pretty&lt;/code&gt;  这个选项可以使用不同于默认格式的方式展示提交历史&lt;/p&gt;
&lt;p&gt;这个选项有一些内建的子选项供你使用。 比如 &lt;code&gt;oneline&lt;/code&gt; 会将每个提交放在一行显示，在浏览大量的提交时非常有用。 另外还有 &lt;code&gt;short&lt;/code&gt;，&lt;code&gt;full&lt;/code&gt; 和 &lt;code&gt;fuller&lt;/code&gt; 选项，它们展示信息的格式基本一致，但是详尽程度不一：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log --pretty=oneline
ca82a6dff817ec66f44342007202690a93763949 changed the version number
085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 removed unnecessary test
a11bef06a3f659402fe7563abf99ad00de2209e6 first commit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最有意思的是 &lt;code&gt;format&lt;/code&gt; ，可以定制记录的显示格式。 这样的输出对后期提取分析格外有用——因为你知道输出的格式不会随着 Git 的更新而发生改变：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log --pretty=format:&quot;%h - %an, %ar : %s&quot;
ca82a6d - Scott Chacon, 6 years ago : changed the version number
085bb3b - Scott Chacon, 6 years ago : removed unnecessary test
a11bef0 - Scott Chacon, 6 years ago : first commit
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://git-scm.com/book/zh/v2/ch00/pretty_format&quot;&gt;&lt;code&gt;git log --pretty=format&lt;/code&gt; 常用的选项&lt;/a&gt; 列出了 &lt;code&gt;format&lt;/code&gt; 接受的常用格式占位符的写法及其代表的意义。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当 &lt;code&gt;oneline&lt;/code&gt; 或 &lt;code&gt;format&lt;/code&gt; 与另一个 &lt;code&gt;log&lt;/code&gt; 选项 &lt;code&gt;--graph&lt;/code&gt; 结合使用时尤其有用。 这个选项添加了一些 ASCII 字符串来形象地展示你的分支、合并历史：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log --pretty=format:&quot;%h %s&quot; --graph
* 2d3acf9 ignore errors from SIGCHLD on trap
*  5e3ee11 Merge branch &apos;master&apos; of git://github.com/dustin/grit
|\
| * 420eac9 Added a method for getting the current branch.
* | 30e367c timeout code and tests
* | 5a09431 add timeout protection to grit
* | e1193f8 support for heads with slashes in them
|/
* d6016bc require time for xmlschema
*  11d191e Merge branch &apos;defunkt&apos; into local
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Git 基础 - 撤消操作&lt;/h2&gt;
&lt;p&gt;你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git commit -m &apos;initial commit&apos;
git add forgotten_file
git commit --amend # 重新提交，且只有一次提交记录
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最终你只会有一个提交——第二次提交将代替第一次提交的结果。&lt;/p&gt;
&lt;p&gt;更多撤销操作请了解 &lt;code&gt;reset&lt;/code&gt;命令。&lt;/p&gt;
&lt;h2&gt;Git 基础 - 远程仓库的使用&lt;/h2&gt;
&lt;h3&gt;查看远程仓库&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git remote # 仅显示远程仓库的名称
git remote -v # 显示远程仓库的名称 + 地址
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;添加远程仓库&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt; git remote add &amp;lt;远程仓库名&amp;gt; &amp;lt;url&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;从远程仓库中抓取与拉取&lt;/h3&gt;
&lt;p&gt;就如刚才所见，从远程仓库中获得数据，可以执行：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git fetch &amp;lt;remote&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。&lt;/p&gt;
&lt;p&gt;注意： &lt;code&gt;git fetch&lt;/code&gt; 命令只会将数据下载到你的本地仓库——&lt;strong&gt;它并不会自动合并或修改你当前的工作&lt;/strong&gt;。 当准备好时你必须手动将其合并入你的工作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git pull
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;用 &lt;code&gt;git pull&lt;/code&gt; 命令来自动抓取后合并该远程分支到当前分支。 这或许是个更加简单舒服的工作流程。默认情况下，&lt;code&gt;git clone&lt;/code&gt; 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 &lt;code&gt;master&lt;/code&gt; 分支（或其它名字的默认分支）。 &lt;strong&gt;运行 &lt;code&gt;git pull&lt;/code&gt; 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;推送到远程仓库&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git push &amp;lt;remote&amp;gt; &amp;lt;branch&amp;gt; # git push origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;查看某个远程仓库&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt; git remote show &amp;lt;remote&amp;gt; # git remote show origin
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看远程仓库的详细信息。这个命令列出了当你在特定的分支上执行 &lt;code&gt;git push&lt;/code&gt; 会自动地推送到哪一个远程分支&lt;/p&gt;
&lt;h3&gt;远程仓库的重命名与移除&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git remote rename &amp;lt;原名&amp;gt; &amp;lt;新名&amp;gt; # 重命名
git remote remove paul &amp;lt;remote&amp;gt;# 移除远程仓库
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Git 基础 - 打标签&lt;/h2&gt;
&lt;h3&gt;列出标签&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git tag # 完整标签列表
git tag -l &quot;v2.0*&quot; # 只显示包含 v2.0 的标签。 注意加星号(*)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;-l&lt;/code&gt; 或 &lt;code&gt;--list&lt;/code&gt; 都可以。&lt;/p&gt;
&lt;h3&gt;创建标签&lt;/h3&gt;
&lt;p&gt;Git 支持两种标签：&lt;strong&gt;轻量标签&lt;/strong&gt;（lightweight）与&lt;strong&gt;附注标签&lt;/strong&gt;（annotated）。&lt;/p&gt;
&lt;p&gt;轻量标签很像一个不会改变的分支——它&lt;strong&gt;只是某个特定提交的引用&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;而附注标签是存储在 Git 数据库中的一个完整对象， 它们是可以被校验的，其中&lt;strong&gt;包含打标签者的名字、电子邮件地址、日期时间， 此外还有一个标签信息&lt;/strong&gt;，并且可以使用 GNU Privacy Guard （GPG）签名并验证。 通常会建议创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。&lt;/p&gt;
&lt;h3&gt;附注标签&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git tag -a v1.4 -m &quot;my version 1.4&quot; # -a表示add， -m 表示附件信息
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过使用 &lt;code&gt;git show&lt;/code&gt; 命令可以看到标签信息和与之对应的提交信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git show v1.4
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;轻量标签&lt;/h3&gt;
&lt;p&gt;轻量标签本质上是将提交校验和存储到一个文件中——没有保存任何其他信息。 创建轻量标签，不需要使用 &lt;code&gt;-a&lt;/code&gt;、&lt;code&gt;-s&lt;/code&gt; 或 &lt;code&gt;-m&lt;/code&gt; 选项，只需要提供标签名字：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git tag v1.4-lw # 不需要添加选项
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这时，如果在标签上运行 &lt;code&gt;git show&lt;/code&gt;，你不会看到额外的标签信息。 命令只会显示出提交信息：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git show v1.4-lw
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Mon Mar 17 21:52:11 2008 -0700
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;后期打标签&lt;/h3&gt;
&lt;p&gt;你也可以对过去的提交打标签。 假设提交历史是这样的：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git log --pretty=oneline
166ae0c4d3f420721acbb115cc33848dfcc2121a started write support
9fceb02d0ae598e95dc970b74767f19372d61af8 updated rakefile
8a5cbc430f1a9c3d00faaeffd07798508422908a updated readme
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “updated rakefile” 提交。 你可以在之后补上标签。 要在那个提交上打标签，你需要在命令的末尾指定提交的校验和（或部分校验和）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git tag -a v1.2 9fceb02 # 打的标签属于附注标签
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;共享标签&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;git push&lt;/code&gt; 命令并不会传送标签到远程仓库服务器上。 在创建完标签后你必须显式地推送标签到共享服务器上。 这个过程就像共享远程分支一样——你可以运行 &lt;code&gt;git push origin &amp;lt;tagname&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git push origin v1.5 # 显式地推送标签到远程仓库
git push origin --tags # 一次性推送所有不在远程仓库上的标签
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在，当其他人从仓库中克隆或拉取，他们也能得到你的那些标签。&lt;/p&gt;
&lt;h3&gt;删除标签&lt;/h3&gt;
&lt;p&gt;要删除掉你本地仓库上的标签，可以使用命令 &lt;code&gt;git tag -d &amp;lt;tagname&amp;gt;&lt;/code&gt;。 例如，可以使用以下命令删除一个轻量标签：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git tag -d v1.4-lw
Deleted tag &apos;v1.4-lw&apos; (was e7d5add)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意上述命令并不会从任何远程仓库中移除这个标签，你必须用 &lt;code&gt;git push &amp;lt;remote&amp;gt; :refs/tags/&amp;lt;tagname&amp;gt;&lt;/code&gt; 来更新你的远程仓库：&lt;/p&gt;
&lt;p&gt;第一种变体是 &lt;code&gt;git push &amp;lt;remote&amp;gt; :refs/tags/&amp;lt;tagname&amp;gt;&lt;/code&gt; ：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git push origin :refs/tags/v1.4-lw
To /git@github.com:schacon/simplegit.git
 - [deleted]         v1.4-lw
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面这种操作的含义是，将冒号前面的空值推送到远程标签名，从而高效地删除它。&lt;/p&gt;
&lt;p&gt;第二种更直观的删除远程标签的方式是：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git push origin --delete &amp;lt;tagname&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;检出标签&lt;/h3&gt;
&lt;p&gt;如果你想查看某个标签所指向的文件版本，可以使用 &lt;code&gt;git checkout&lt;/code&gt; 命令， 虽然这会使你的仓库处于“分离头指针（detached HEAD）”的状态——这个状态有些不好的副作用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git checkout 2.0.0
Note: checking out &apos;2.0.0&apos;.

You are in &apos;detached HEAD&apos; state. You can look around, make experimental
changes and commit them, and you can discard any commits you make in this
state without impacting any branches by performing another checkout.

If you want to create a new branch to retain commits you create, you may
do so (now or later) by using -b with the checkout command again. Example:

  git checkout -b &amp;lt;new-branch&amp;gt;

HEAD is now at 99ada87... Merge pull request #89 from schacon/appendix-final

$ git checkout 2.0-beta-0.1
Previous HEAD position was 99ada87... Merge pull request #89 from schacon/appendix-final
HEAD is now at df3f601... add atlas.json and cover image
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在“分离头指针”状态下，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问，除非通过确切的提交哈希才能访问。 因此，如果你需要进行更改，比如你要修复旧版本中的错误，那么通常需要创建一个新分支：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git checkout -b version2 v2.0.0
Switched to a new branch &apos;version2&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果在这之后又进行了一次提交，&lt;code&gt;version2&lt;/code&gt; 分支就会因为这个改动向前移动， 此时它就会和 &lt;code&gt;v2.0.0&lt;/code&gt; 标签稍微有些不同，这时就要当心了。&lt;/p&gt;
&lt;h2&gt;Git 命令别名&lt;/h2&gt;
&lt;p&gt;Git 并不会在你输入部分命令时自动推断出你想要的命令。 如果不想每次都输入完整的 Git 命令，可以通过 &lt;code&gt;git config&lt;/code&gt; 文件来轻松地为每一个命令设置一个别名。 这里有一些例子你可以试试：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --global alias.co checkout
git config --global alias.br branch
git config --global alias.ci commit
git config --global alias.st status
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这意味着，当要输入 &lt;code&gt;git commit&lt;/code&gt; 时，只需要输入 &lt;code&gt;git ci&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;在创建你认为应该存在的命令时这个技术会很有用。 例如，为了解决取消暂存文件的易用性问题，可以向 Git 中添加你自己的取消暂存别名：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --global alias.unstage &apos;reset HEAD --&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这会使下面的两个命令等价：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git unstage fileA
git reset HEAD -- fileA
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样看起来更清楚一些。 通常也会添加一个 &lt;code&gt;last&lt;/code&gt; 命令，像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --global alias.last &apos;log -1 HEAD&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这样，可以轻松地看到最后一次提交：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git last
commit 66938dae3329c7aebe598c2246a8e6af90d04646
Author: Josh Goebel &amp;lt;dreamer3@example.com&amp;gt;
Date:   Tue Aug 26 19:48:51 2008 +0800

    test for current head

    Signed-off-by: Scott Chacon &amp;lt;schacon@example.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看出，Git 只是简单地将别名替换为对应的命令。 然而，你可能想要执行外部命令，而不是一个 Git 子命令。 如果是那样的话，可以在命令前面加入 &lt;code&gt;!&lt;/code&gt; 符号。 如果你自己要写一些与 Git 仓库协作的工具的话，那会很有用。 我们现在演示将 &lt;code&gt;git visual&lt;/code&gt; 定义为 &lt;code&gt;gitk&lt;/code&gt; 的别名：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --global alias.visual &apos;!gitk&apos;
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>笔记方法</title><link>https://newpower.pro/posts/%E5%AD%A6%E4%B9%A0/01%E7%AC%94%E8%AE%B0%E6%96%B9%E6%B3%95/</link><guid isPermaLink="true">https://newpower.pro/posts/%E5%AD%A6%E4%B9%A0/01%E7%AC%94%E8%AE%B0%E6%96%B9%E6%B3%95/</guid><pubDate>Thu, 16 Jul 2020 11:00:55 GMT</pubDate><content:encoded>&lt;p&gt;::: center&lt;/p&gt;
&lt;h2&gt;康奈尔笔记法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200716105752.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;思维导图法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200716105747.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;金三角笔记法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200716105753.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;曼陀罗九宫格笔记法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200716105748.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;记号记录法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200716105749.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;六色笔记法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200716105750.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;加工笔记法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200716105751.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;整理笔记要点1-科学标记重点&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200716105746.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;整理笔记要点2-修改不涂改&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200716105745.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;:::&lt;/p&gt;
</content:encoded></item><item><title>费曼学习法</title><link>https://newpower.pro/posts/%E5%AD%A6%E4%B9%A0/00%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/</link><guid isPermaLink="true">https://newpower.pro/posts/%E5%AD%A6%E4%B9%A0/00%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/</guid><pubDate>Thu, 16 Jul 2020 10:04:14 GMT</pubDate><content:encoded>&lt;p&gt;费曼学习法，我很喜欢的一个学习方法，简单来说，就是：通过向别人清楚的解说某一件事或是写一篇浅显易懂的教程文章，来确认自己是否真正弄懂了这件事。
可以说是在通过向别讲解过程中来对自身的 &lt;strong&gt;查缺补漏&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;步骤&lt;/h3&gt;
&lt;p&gt;费曼学习法分为4个步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;确定学习目标&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你想学习的概念、内容、主题是什么。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;模拟教学学习法&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你要模拟自己是一位老师，面对完全不懂这个领域的人，用自己的话，尽可能具体形象地讲诉。这样的讲诉有助于你活学活用，触类旁通，联系生活具体情境。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;回顾&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;反思第2步遇到的问题，哪些地方卡壳了，哪些地方对方没有真正听懂。找出问题的要害，把握关键环节。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;简化&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;把这些遇到问题的地方，重新梳理理解，尽可能了解更多背景和相关知识，再用尽可能简化的方式重新表达，设法看穿本质。然后，返回第2步。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/88209825&quot;&gt;《费曼学习法：为何被称为史上最牛的学习法，它的本质究竟是什么？》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/90be6a69528a&quot;&gt;《费曼学习法》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded></item><item><title>搜索引擎使用技巧</title><link>https://newpower.pro/posts/%E5%AD%A6%E4%B9%A0/10%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</link><guid isPermaLink="true">https://newpower.pro/posts/%E5%AD%A6%E4%B9%A0/10%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</guid><pubDate>Sun, 24 May 2020 11:44:19 GMT</pubDate><content:encoded>&lt;p&gt;搜索引擎相信大家经常在使用，但是有时候想搜某个信息时却搜出来一大堆不相关的（百度：你们都在看我干什么？）。下面我们来介绍几种搜索技巧，可以提升搜索效率，助你快速查资料，妈妈再也不担心我的学习了（&apos;妈~我真的是在找学习资料&apos;）&lt;/p&gt;
&lt;h3&gt;技巧1：排除干扰项&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;方式&lt;/strong&gt;：关键词1+空格+减号+关键词2，即 &lt;code&gt;关键词1 -关键词2&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：排除一些不想要的关键词&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;锤子 -锤子手机
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例中将在搜索结果排除与&lt;code&gt;锤子手机&lt;/code&gt;相关的，只显示&lt;code&gt;锤子&lt;/code&gt;本来的样子。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;经过百度搜索的测试，有的关键词能排除掉，有的并不好使&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;技巧2：精确搜索&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;方式&lt;/strong&gt;：给关键词加双引号，&lt;code&gt;&quot;关键词&quot;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：只搜索引号里的字，少一个字或者把字拆开都不行&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;达拉不崩吧&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意是英文的双引号&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;技巧3：指定网站内搜索&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;方式&lt;/strong&gt;：&lt;code&gt;site:域名 关键词&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：只搜索指定域名的内容&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;site:zhihu.com 前端
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有一些站内自带的搜索并不好用，可以尝试这个搜索技巧。&lt;/p&gt;
&lt;h3&gt;技巧4：指定文件格式&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;方式&lt;/strong&gt;：&lt;code&gt;filetype:文件格式 关键词&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;filetype:avi 你懂的
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;常见文件格式有&lt;code&gt;doc&lt;/code&gt;、&lt;code&gt;pdf&lt;/code&gt;、&lt;code&gt;ppt&lt;/code&gt;等&lt;/p&gt;
&lt;h3&gt;技巧5：指定在标题搜索&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;方式&lt;/strong&gt;：&lt;code&gt;intitle:关键词&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;功能&lt;/strong&gt;：搜索的关键词要出现在标题当中&lt;/p&gt;
&lt;h3&gt;技巧6：指定在内容中搜索&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;方式&lt;/strong&gt;：&lt;code&gt;intext:关键词&lt;/code&gt;、&lt;code&gt;allintext:关键词1 关键词2&lt;/code&gt;、&lt;code&gt;inurl:关键词2&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;技巧7：多种搜索技巧叠加使用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;示例&lt;/strong&gt;：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;site:zhihu.com 前端 intitle:js
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多种技巧和关键词叠加使用，中间空格隔开。&lt;/p&gt;
&lt;h3&gt;注意事项&lt;/h3&gt;
&lt;p&gt;以上搜索技巧使用的符号均是英文符号。&lt;/p&gt;
</content:encoded></item><item><title>提高学习效率的策略</title><link>https://newpower.pro/posts/%E5%AD%A6%E4%B9%A0/02%E6%8F%90%E9%AB%98%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87%E7%9A%84%E7%AD%96%E7%95%A5/</link><guid isPermaLink="true">https://newpower.pro/posts/%E5%AD%A6%E4%B9%A0/02%E6%8F%90%E9%AB%98%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87%E7%9A%84%E7%AD%96%E7%95%A5/</guid><pubDate>Sat, 04 Jan 2020 11:54:14 GMT</pubDate><content:encoded>&lt;p&gt;推荐一本关于学习方法的书《认知天性》，里面有讲到有一些简单实用的学习策略，能让大家学的更好、记得更牢，而且这些策略人人可用，时时可用。这些方法包括各种形式的&lt;strong&gt;检索练习&lt;/strong&gt;——例如小的测试和自测，&lt;strong&gt;间隔练习&lt;/strong&gt;、&lt;strong&gt;穿插&lt;/strong&gt;不同但相关科目或技能的练习（&lt;strong&gt;多样化练习&lt;/strong&gt;），在别人教给你解决方案前自己先试着解决问题，从不同类型问题中提取基本原理和规则。由于学习是反复的过程，需要复习早先学过的东西，持续更新已知，并把它们和新知识联系起来。&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- more --&amp;gt;&lt;/p&gt;
&lt;h3&gt;检索式学习&lt;/h3&gt;
&lt;p&gt;练习从记忆中检索新知识或新技能是有效的学习工具，也是保持长久记忆的有力武器。但凡需要大脑记忆、需要在将来回忆的东西，都可以用到它——对于事实、复杂的概念、解决问题的技巧、运动技能来说都适用。&lt;/p&gt;
&lt;p&gt;那么到底什么是检索式学习呢？说说我理解的检索式学习：在脑中检索知识，比如课后的一个小测试、对某个知识点用笔默写出来，甚至去参加面试，等等，都可以理解为检索式学习。&lt;/p&gt;
&lt;p&gt;努力检索有助于人们获得更好的学习效果，产生更持久的记忆。我们很容易相信，学东西时越轻松，学习效果越好，但研究表明，事实恰恰相反。只有当头脑被迫工作时，才会将所学的东西记得更牢靠。在检索时所付出的努力越大——只要真正做到这一点检索就会更好地强化你的所学。在第一次检测后，推迟后续检索练习要比立即练习更能强化记忆，因为延迟后再检索需要会费更大力气。&lt;/p&gt;
&lt;p&gt;反复检索不仅能让记忆更持久，还能让知识在更多变的环境中更容易被检索，而且可以解决更多的问题。&lt;/p&gt;
&lt;h3&gt;频繁的集中练习只会产生短期记忆&lt;/h3&gt;
&lt;p&gt;人们顽固地相信，自己把心思放在一件事上，拼命重复就能学得更好，认为这些观点经受住了时间的考验，而且“练习，练习，再练习”的明显收效再次证明了这种方法的好处。但是，科学家们把习得技能阶段的这种成绩称为“暂时的优势”，并把它同“潜在的习惯优势”区分开来。形成习惯优势有种种技巧，例如有间隔的练习、有穿插内容的练习，以及多样化练习，这些技巧恰恰会放缓有明显成果的学习进程，它们不会在练习中提高我们的表现。我们从表面上看不到成绩提高，也就没有付出努力的动力（大多数人的学习心理就是这样，在看不到成果的时候容易失去动力）。填鸭式练习是集中练习的一种形式，它一直被比作贪食症——吃得不少，但没过多久基本上都吐出来了。&lt;/p&gt;
&lt;h3&gt;间隔练习使知识存储更牢固&lt;/h3&gt;
&lt;p&gt;把学习与练习间隔开来分期进行，让两者之间隔上一定时间，这样做就能让学习成果更加显著、记忆更加牢固，能有效地形成习惯优势。&lt;strong&gt;间隔多长时间才够？答案很简单：从最低限度上说，间隔的时间足够出现一点儿遗忘就对了&lt;/strong&gt;。练习环节中间出现一点儿遗忘是好事，只要它能让人更加努力地练习就行。话说回来，你肯定不愿意忘掉太多东西，以至于检索最终变成了对资料的重新学习。间隔一段时间再练习能巩固记忆。睡眠似乎在巩固记忆的工作中扮演了重要角色，所以在两次练习间至少间隔一天应该是不错的做法。
要当心熟悉这个陷阱：你感觉自己明白了某样东西，觉得不再需要练习了。如果想走捷径，这种熟悉会让你在自测时受伤。道格拉斯·拉尔森说：“你必须自觉地说，好吧，我要强迫自己把这些全想起来，要是我想不起来，那我是忘掉了什么，我怎，么会不知道那个呢?’如果是教师出题测验，那就一下子变成你&lt;/p&gt;
&lt;h3&gt;穿插练习有助于长期记忆&lt;/h3&gt;
&lt;p&gt;穿插练习两样或更多的内容同样也提供了一种间隔。穿插内容练习有助于发展人们辨识不同问题的能力，也是在培养人们从不断增加的解决方案中寻找合适工具的能力。进行穿插内容练习，不能是完成一个科目的全部练习再跳到下一个科目。你需要在每个科目的练习完成前就跳到下一个科目。我们的一个朋友这样描述自己的经历，“我去上了一堂冰球课，学习滑冰、控球、射门。滑冰练习还没进行多长时间，自己刚刚有点儿上手的感觉，教练就转到控球练习上了，这让我感到非常沮丧。灰心地到家后，我说，‘为什么教练不让我们一次把技能练好呢？”其实他是遇上了少有的好教练。这位教练懂得分散精力练习不同技能要比下力气一次掌握一件事更有效果。球员感到沮丧是因为并没有在短时间内看到成果，但到下一周，无论是滑冰、控球，还是其他内容，他都会获得全面进步，效果会好于每次只专心练习一项技能。&lt;/p&gt;
&lt;h3&gt;多样化练习促进知识的活学活用&lt;/h3&gt;
&lt;p&gt;与穿插内容练习一样，多样化练习有助于学习者树立更开阔的心理模式。这是一种能力，掌握它的人可以评估不断变化的条件，并调整应对方式进行适应。可以说，穿插内容练习与多样化练习有助于学习者超越暂时性记忆，步入更高层次的概念性学习，并把它们应用到实际情景中，从而获得更全面、更深刻、更持久的学习效果。这些学习成果在运动技能中就表现为潜在的习惯优势。&lt;/p&gt;
&lt;h3&gt;小总结&lt;/h3&gt;
&lt;p&gt;有间隔、有内容穿插出现，以及内容多样化，其实就是我们生活的本来面貌。程序员每开发一个项目，都是一次测验，也是一次检索练习的锻炼。每次常规的拦车检查对于警察来说都是一次测验，而且每次检查都不一样，这会加强警察的外显记忆与内隐记忆。只要他上心，今后的工作就会更有效率。人们常说的一句话是“从经验中学习”。有些人似乎从来不学习，学与不学的一个区别可能就在于，人们是否培养了反思（总结）的习惯。反思（总结）是检索练习的一种形式（发生了什么？我是怎么做的？怎样才能有用？），而且辅以细化加强（下次我要采取别的什么方法？）&lt;/p&gt;
&lt;h3&gt;知识的“滚雪球”效应&lt;/h3&gt;
&lt;p&gt;学习的过程至少可以分成三步：最开始是对短期工作记忆中信息的&lt;strong&gt;编码&lt;/strong&gt;。这时信息还没有被巩固成长期记忆中坚实的知识表征。&lt;strong&gt;巩固&lt;/strong&gt;会辨识并稳定记忆线索，赋予其含义，把它们与过去的经验以及长期记忆中已经存储下来的其他知识联系起来。&lt;strong&gt;检索&lt;/strong&gt;会更新所学的东西，并让你做到学以致用。&lt;/p&gt;
&lt;p&gt;学习总是建立在已知基础之上。我们是通过与已知建立联系这种方式来解读事件和记忆事件的。&lt;/p&gt;
&lt;p&gt;长期记忆的容量基本上是无限的。你知道得越多，就越有可能为新知识建立联系。&lt;/p&gt;
&lt;p&gt;由于长期记忆的容量颇大，所以关键是要有一种能力，让你在需要的时候锁定并回忆已知。回忆所学知识的难易程度取决于对信息的重复使用（保持检索路径不会被忘却），也取决于你是否建立起了强大的检索线索，因为它能重新激活你的记忆。&lt;/p&gt;
&lt;p&gt;阶段性地检索所学，有助于强化记忆间的联系，也能强化回忆知识的线索，同时还能弱化连通冲突记忆的路径。检索练习若是没什么难度，那就不能强化所学的知识；练习难度越大，收效才越大。&lt;/p&gt;
&lt;p&gt;当你从短期记忆中回忆所学时，例如快速频繁地进行练习，是不需要花什么心思的，也不会有长期性的收效。但当你过一段时间再回忆时，当你对所学的东西有些遗忘时，你就不得不努力重建这一切。这种耗费心力的检索既能强化记忆，又能让所学再次具有可塑性，引发对所学知识的再巩固。再巩固可以用新信息更新你的记忆，同时可以将它们与最近学到的东西联系起来。&lt;/p&gt;
&lt;p&gt;重复进行费力的回忆或是练习，有助于把所学的知识整合成心智模型。在心智模型中，一套彼此相关的概念或一系列运动技能被融会贯通，形成一个有意义的整体。它能适应随后的各种环境，并发挥作用。开车时的感知和操控就是一个例子。在面对弧线球时知道如何打出全垒打也是同一个道理。&lt;/p&gt;
&lt;p&gt;练习的条件如果发生了变化，或是在检索中穿插安排了对其他资料的练习，我们就能强化自己的辨析与归纳能力，凭借全面发展，我们还能把所学的知识用在以后的新环境中。穿插与多样化建立了新的联系，拓展并进一步深化了记忆中的知识，同时增加了检索线索的数量。、&lt;/p&gt;
&lt;p&gt;试着自己想出答案，而不是坐等别人给你答案，或是在拿到解决方案前自行尝试解决一个问题，会产生更好的学习效果，也能让你把正确的答案或解决方案记得更持久。即便有时你会犯错，只要有纠正性反馈就没问题。&lt;/p&gt;
&lt;p&gt;——以上内容摘自《认知天性》，结合本人的个人理解，更多内容请查看该书籍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200103144032.png&quot; alt=&quot;认知天性&quot; title=&quot;认知天性&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>处理问题的思路</title><link>https://newpower.pro/posts/%E5%AD%A6%E4%B9%A0/05%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF/</link><guid isPermaLink="true">https://newpower.pro/posts/%E5%AD%A6%E4%B9%A0/05%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF/</guid><pubDate>Fri, 03 Jan 2020 14:36:02 GMT</pubDate><content:encoded>&lt;h2&gt;工作中遇到问题？&lt;/h2&gt;
&lt;p&gt;遇到问题卡住了，可以先休息一会儿，调整一下状态，喝杯水走走放松放松，然后想想有没有遗漏的地方，或者其他的解决方案呢&lt;/p&gt;
&lt;h2&gt;这个问题我该怎么解决呢？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;学会搜索&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;关键词&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多关键词&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加入时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加入特定的社区&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;site用法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;高阶搜索方法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;英文搜索（必应搜索、google搜索，很多英文文档或文章相对来说层数结构很清晰）&lt;/li&gt;
&lt;li&gt;视频站搜索（&lt;a href=&quot;http://www.youtube.com/&quot;&gt;http://www.youtube.com/&lt;/a&gt;、&lt;a href=&quot;http://egghead.io&quot;&gt;http://egghead.io&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;百度盘搜索&lt;/li&gt;
&lt;li&gt;指定文件后缀&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;寻求帮助&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;找同学&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找同事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找朋友&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://xugaoyi.com/pages/2e9ba3fa6e1ed0e9/#%E7%A4%BE%E5%8C%BA%E7%B1%BB&quot;&gt;找社区&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;开拓思路——发散性解决问题&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;去问问原作者？&lt;/li&gt;
&lt;li&gt;去发个邮件/twitter/facebook?&lt;/li&gt;
&lt;li&gt;去找Boss要资源？&lt;/li&gt;
&lt;li&gt;加入公共社区参与讨论?&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content:encoded></item><item><title>自律小建议</title><link>https://newpower.pro/posts/%E5%AD%A6%E4%B9%A0/04%E8%87%AA%E5%BE%8B%E5%B0%8F%E5%BB%BA%E8%AE%AE/</link><guid isPermaLink="true">https://newpower.pro/posts/%E5%AD%A6%E4%B9%A0/04%E8%87%AA%E5%BE%8B%E5%B0%8F%E5%BB%BA%E8%AE%AE/</guid><pubDate>Fri, 03 Jan 2020 14:35:18 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;培养专注&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;练习冥想、瑜伽等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;排除外界干扰&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;手机调到勿扰，在图书馆学习等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lt;!-- more --&amp;gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;规定学习时间&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95/6353502?fr=aladdin&quot;&gt;&lt;strong&gt;番茄时间管理&lt;/strong&gt;&lt;/a&gt;——使用番茄时间管理法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;人的大脑在记忆一个东西的时候，有短期记忆和长期记忆之分。大脑编码内容进行长期记忆，需要一个过程的，可能是几个小时或几天，集中练习就给不了这个过程，所以集中练习带来的效果是短期记忆，而进行间隔练习，大脑则有时间进行充分的编码，学习到的知识就会储存为长期记忆。&lt;/p&gt;
&lt;p&gt;推荐几种间歇锻炼方法：体能训练、课间操、眼保操、拉伸训练...&lt;/p&gt;
&lt;p&gt;有好的身体可以使大脑更清醒哟~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;限制娱乐时间&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;减少使用娱乐app的时间（苹果手机可设定屏幕使用时间）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;推荐观看&amp;gt;&lt;a href=&quot;https://www.bilibili.com/video/av47180907&quot;&gt;B站某位UP主的视频《每天只看半小时手机，坚持一周后我有哪些变化？》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;戒网瘾（特别是游戏）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;除了手机、游戏以外，周围有很多美好的事物值得我们去关注。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;设定目标&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;想要更好的薪水和职位？多花点时间在学习上吧~&lt;/li&gt;
&lt;li&gt;潜意识暗示自己，建立信心，让自己变得更优秀，然后去挑战更高的目标&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;优秀的人仍在不断努力&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;且看大神 &lt;a href=&quot;https://github.com/ruanyf&quot;&gt;阮一峰github&lt;/a&gt; 提交记录&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>提高记忆的技巧</title><link>https://newpower.pro/posts/%E5%AD%A6%E4%B9%A0/03%E6%8F%90%E9%AB%98%E8%AE%B0%E5%BF%86%E7%9A%84%E6%8A%80%E5%B7%A7/</link><guid isPermaLink="true">https://newpower.pro/posts/%E5%AD%A6%E4%B9%A0/03%E6%8F%90%E9%AB%98%E8%AE%B0%E5%BF%86%E7%9A%84%E6%8A%80%E5%B7%A7/</guid><pubDate>Fri, 03 Jan 2020 14:34:48 GMT</pubDate><content:encoded>&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;多个感官并用&lt;/strong&gt;
记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;lt;!-- more --&amp;gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;重复记忆&lt;/strong&gt;
每天留出半个到一个小时，梳理总结今天所学的内容。每一章复习完成后做系统的知识整理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;建立关联&lt;/strong&gt;
把你所学的新知识与已有的认知建立联系，对于记忆事半功倍。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;场景记忆&lt;/strong&gt;
把知识具象化为一个场景，想象自己在何时何地能用这些知识，与自身发生联系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提出问题&lt;/strong&gt;
每学习一个知识点，试着提问，然后给出答案。用了就记住了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content:encoded></item></channel></rss>