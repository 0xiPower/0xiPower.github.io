<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>☯️xPower</title><description>Life is a fxxking movie.</description><link>https://newpower.pro/</link><language>zh_CN</language><item><title>震惊！这门国产编程语言竟能一招搞定全场景！开发者：学不会就OUT了！！</title><link>https://newpower.pro/posts/document/%E4%BB%93%E9%A2%89%E8%AF%AD%E6%B3%95%E5%B0%8F%E6%89%8B%E5%86%8C/</link><guid isPermaLink="true">https://newpower.pro/posts/document/%E4%BB%93%E9%A2%89%E8%AF%AD%E6%B3%95%E5%B0%8F%E6%89%8B%E5%86%8C/</guid><description>仓颉编程语言是一款面向全场景智能的新一代编程语言，主打原生智能化、天生全场景、高性能、强安全。融入鸿蒙生态，为开发者提供良好的编程体验。全方位的编译优化和运行时实现、以及开箱即用的 IDE 工具链支持，为开发者打造友好开发体验和卓越程序性能。</description><pubDate>Mon, 12 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;我是一名仓颉编程语言的体验官, 从仓颉编程语言上线公测后, 一直有使用, 练习时长0.4*两年半。&lt;br /&gt;
正如标题所说, 仓颉编程语言是一款面向全场景智能的新一代编程语言, 主打原生智能化、天生全场景、高性能、强安全。融入鸿蒙生态，为开发者提供良好的编程体验。全方位的编译优化和运行时实现、以及开箱即用的 IDE 工具链支持，为开发者打造友好开发体验和卓越程序性能。&lt;br /&gt;
它汲取了C语言的简洁高效、Java的面向对象特性、Go语言的并发处理优势、Rust的内存安全机制以及Python的易读易写风格。&lt;br /&gt;
当然, 新编程语言的诞生总免不了遭到谩骂唾弃, 但这是一款国产编程语言, 纵使其目前还不太行, 但作为一名Cn Coder, 没有理由不支持不尝试。&lt;br /&gt;
是的, &quot;有剑不用&quot;和&quot;没有剑用&quot; 两者的背后深意很大, 纵使&quot;花厂&quot;在互联网上的名声可能不太好, 但起码这家伙确确实实在一步一步的抬高国内计算机技术的竞争力, 这一点不可否认。&lt;br /&gt;
在一定的极端情况下,  起码不受制于人。至于未来开不开源搞收费圈米, 那都另一回事了, 起码, 这是一个好兆头。&lt;/p&gt;
&lt;h2&gt;初识 &lt;code&gt;仓颉&lt;/code&gt; 编程语言&lt;/h2&gt;
&lt;p&gt;仓颉编程语言是一种面向全场景应用开发的编程语言, 可以兼顾开发效率和运行性能, 提供良好的编程体验。&lt;/p&gt;
&lt;p&gt;举个栗子:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from net import http.ServerBuilder, http.FuncHandler
main() {
    let server = ServerBuilder().addr(&quot;127.0.0.1&quot;).port(8080).build()
    server.distributor.register(&quot;/index&quot;, FuncHandler({httpContext =&amp;gt; 
        httpContext.responseBuilder.body(&quot;Hello, Cangjie!&quot;)
    }))
    server.serve()
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;仓颉编程语言特性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;语法简洁高效&lt;/li&gt;
&lt;li&gt;多范式编程&lt;/li&gt;
&lt;li&gt;类型安全&lt;/li&gt;
&lt;li&gt;内存安全&lt;/li&gt;
&lt;li&gt;高效并发&lt;/li&gt;
&lt;li&gt;兼容语言生态&lt;/li&gt;
&lt;li&gt;领域易拓展&lt;/li&gt;
&lt;li&gt;助力UI开发&lt;/li&gt;
&lt;li&gt;内置库功能丰富&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;环境配置及运行第一个仓颉程序&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;安装仓颉编程语言
&lt;ul&gt;
&lt;li&gt;访问 &lt;a href=&quot;https://cangjie-lang.cn/docs&quot;&gt;仓颉编程语言官网文档&lt;/a&gt; 下载最新版本的安装包。&lt;/li&gt;
&lt;li&gt;根据操作系统的不同，选择相应的安装方式进行安装。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;配置环境变量
&lt;ul&gt;
&lt;li&gt;将仓颉编程语言的安装目录添加到系统的环境变量中，以便在命令行中直接使用 &lt;code&gt;cjc&lt;/code&gt; 命令。&lt;/li&gt;
&lt;li&gt;在控制台中输入 &lt;code&gt;cjc -v&lt;/code&gt; 命令，检查是否安装成功。&lt;/li&gt;
&lt;li&gt;如果安装成功，控制台会输出仓颉编程语言的版本信息。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;创建第一个仓颉程序&lt;/h3&gt;
&lt;p&gt;首先, 请在适当目录下新建一个名为&lt;code&gt;hello.cj&lt;/code&gt;的文本文件, 并向文件中写入以下仓颉代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    println(&quot;Hello, Cangjie!&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后, 请在此目录下执行如下命令:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cjc hello.cj -o hello
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里仓颉编辑器会将&lt;code&gt;hello.cj&lt;/code&gt;中的源代码编译为此平台上的可执行文件&lt;code&gt;hello&lt;/code&gt;,在命令行环境中运行此文件, 您将看到程序输出了如下内容:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Hello, Cangjie!
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;温馨提示&lt;/strong&gt;&lt;br /&gt;
以上编译命令是针对Linux/macOS 平台的, 如果在 Windows 平台上使用仓颉编程语言, 请将 &lt;code&gt;hello&lt;/code&gt; 替换为 &lt;code&gt;hello.exe&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;标识符&lt;/h2&gt;
&lt;p&gt;仓颉编程语言的标识符由字母、数字和下划线组成，且必须以字母或下划线开头。标识符是区分大小写的, 标识符分为&lt;code&gt;普通标识符&lt;/code&gt;和&lt;code&gt;原始标识符&lt;/code&gt;两种类型, 它们分别遵从不同的命名规则。&lt;/p&gt;
&lt;h3&gt;普通标识符&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;普通标识符&lt;/code&gt;不能和仓颉关键字相同, 可以取自以下两类字符序列:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由英文字母开头, 后接零至多个英文字母、数字或下划线&lt;/li&gt;
&lt;li&gt;由一至多个下划线&lt;code&gt;_&lt;/code&gt;开头, 后接一个英文字母, 最后可接零至多个英文字母、数字或下划线&lt;code&gt;_&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;合法的普通标识符&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;abc
_abc
abc_
a1b2c3
a_b_c
a1_b2_c3
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;不合法的普通标识符&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;ab&amp;amp;c    // 使用了非法字符 &quot;&amp;amp;&quot;
_123    // 起始下划线 &quot;_&quot; 后不能接数字
3abc    // 数字不能出现在头部
while   // 不能使用仓颉关键字
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;原始标识符&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;原始标识符&lt;/code&gt;是以反引号` ` 开头和结尾的字符序列, 反引号内的字符序列可以包含任何字符, 但不能包含反引号本身。&lt;/p&gt;
&lt;h4&gt;合法的原始标识符&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;`abc`
`_abc`
`a1b2c3`
`if`
`while`
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;不合法的原始标识符&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;`ab&amp;amp;c`
`_123`
`3abc`
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;变量&lt;/h2&gt;
&lt;p&gt;在仓颉编程语言中, 一个变量由对应的变量名、数据(值)和若干属性构成, 开发者通过变量名访问变量对应的数据, 但访问操作需要遵从相关属性的约束(如数据类型、可变性和可见性等)&lt;/p&gt;
&lt;p&gt;变量定义的具体形式为: &lt;code&gt;修饰符&lt;/code&gt;  &lt;code&gt;变量名&lt;/code&gt;: &lt;code&gt;变量类型&lt;/code&gt; = &lt;code&gt;初始值&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;其中&lt;code&gt;修饰符&lt;/code&gt;用于设置变量的各类属性, 可以有一个或多个, 常用的修饰符包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可变性修饰符: let 或 var, 分别对应不可变和可变属性, 可变性决定了变量被初始化后其值还能否改变, 仓颉变量也由此分为不可变变量和可变变量两类。&lt;/li&gt;
&lt;li&gt;可见性修饰符: private 和 public 等, 影响全局变量和成员变量的可引用范围, 可见性修饰符决定了变量的作用域, 影响变量的可见性和访问权限。&lt;/li&gt;
&lt;li&gt;静态性修饰符: static, 影响成员变量的存储和引用方式, 静态变量在类加载时被初始化, 其生命周期与类的生命周期相同, 而非静态变量在每次实例化对象时被初始化, 其生命周期与对象的生命周期相同。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在定义仓颉变量时, 可变性修饰符是必要的, 在此基础上, 还可以根据需要添加其他修饰符&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;变量名&lt;/code&gt;应是一个合法的仓颉标识符。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;变量类型&lt;/code&gt;指定了变量所持有数据的类型。当初始值具有明确类型时, 可以省略变量类型标注, 此时编译器可以自动推断出变量类型。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;初始值&lt;/code&gt;是一个仓颉表达式, 用于初始化变量, 如果标注了变量类型, 需要保证初始值类型和变量类型一致。在定义全局变量或静态成员变量时, 必须指定初始值。在定义局部变量或实例成员变量时, 可以省略初始值, 但需要标注变量类型, 同时要在此变量被引用前完成初始化, 否则编译会错误。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;来看一个例子: 定义了两个Int64类型的不可变变量a和可变变量b,随后修改了变量b的值, 并调用printlc函数打印a与b的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    let a: Int64 = 20
    var b: Int64 = 12
    b = 23
    println(&quot;${a}${b}&quot;)                 // 2023
    println(&quot;a = ${a}&quot;, &quot;, b = ${b}&quot;)   // a = 20, b = 23
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果尝试修改不可变变量, 编译时会报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    let pi: Float64 = 3.14159265
    pi = 2.71828 // 错误: pi是不可变变量, 不能被修改
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当初始值具有明确类型时, 可以省略变量类型标注&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    let a: Int64 = 2023
    let b = a
    println(&quot;a - b = ${a - b}&quot;)
}
// result: a - b = 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中变量b的类型可以由其初值a的类型自动推断为Int64, 所以此程序也可以被正常编译和运行, 将输出&lt;code&gt;a - b = 0&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在定义局部变量时, 可以不进行初始化, 但一定要在变量被引用前赋予初值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    let text: String
    text = &quot;仓颉造字&quot; // Cangjie
    println(text)
}
// result: 仓颉造字
// TODO: 可能会出现乱码情况, 这是编码问题
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在定义全局变量和静态成员变量时必须初始化, 否则编译会报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// example.cj
let global: Int64 // Error, variable in top-level scope must be
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;if 表达式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;if&lt;/code&gt; 表达式的基本形式为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (条件 1) {
    分支 1
} else if (条件 2) {
    分支 2
} else {
    分支 3
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中&quot;条件&quot;是布尔类型表达式, &quot;分支 1&quot;和&quot;分支 2&quot;是两个代码块。&lt;code&gt;if&lt;/code&gt; 表达式将按如下规则执行&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算&quot;条件 1&quot;表达式, 如果值为&lt;code&gt;true&lt;/code&gt;则执行&quot;分支 1&quot;, 值为&lt;code&gt;false&lt;/code&gt;则跳到 else if 判断计算&quot;条件 2&quot;或 else 判断&lt;/li&gt;
&lt;li&gt;执行&quot;分支 x&quot;, 然后跳出&lt;code&gt;if&lt;/code&gt;表达式&lt;/li&gt;
&lt;li&gt;继续执行&lt;code&gt;if&lt;/code&gt;表达式后面的代码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在一些场景中, 我们可能只关注条件成立时该做些什么, 所以&lt;code&gt;else&lt;/code&gt;和对应的代码块是允许省略的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from std import random.*
main() {
    let number: Int8 = Random().nextInt8()
    println(number)
    if (number %2 == 0) {
        println(&quot;even&quot;)
    } else {
        println(&quot;odd&quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在这段程序中, 我们使用了仓颉标准库的&lt;code&gt;random&lt;/code&gt;包生成了一个随机数, 然后使用&lt;code&gt;if&lt;/code&gt;表达式判断这个整数是否能被2整除, 并在不同的条件分支中打印&quot;偶数&quot;或&quot;奇数&quot;&lt;/p&gt;
&lt;p&gt;仓颉编程语言是强类型的, &lt;code&gt;if&lt;/code&gt;表达式的条件只能是布尔类型, 不能使用整数或浮点数等类型, 和C语言不同, 仓颉不以条件取值是否为0作为分支选择依据, 否则会报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    let number = 1
    if (number) {           // error: mismatched types
        println(&quot;非零&quot;)
    } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在许多场景中, 当一个条件不成立时, 我们可能还要判断另一个或多个条件、在执行对应的动作, 仓颉允许在&lt;code&gt;else&lt;/code&gt; 之后跟随新的&lt;code&gt;if&lt;/code&gt;表达式, 由此支持多级条件判断和分支执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from std import random.*
main() {
    let speed = Random(). nextFloat64() * 20.0
    println(&quot;${speed} km/s&quot;)
    if (speed &amp;gt; 16.7) {
        println(&quot;第三宇宙速度, 鹊桥相会&quot;)
    } else if (speed &amp;gt; 11.2) {
        println(&quot;第二宇宙速度, 嫦娥奔月&quot;)
    } else if (speed &amp;gt; 7.9) {
        println(&quot;第一宇宙速度, 腾云驾雾&quot;)
    } else {
        println(&quot;脚踏实地, 仰望星空&quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;温馨提示&lt;/strong&gt;&lt;br /&gt;
下列print、println、eprint、eprintln函数默认为UTF-8编码, windows环境需要手动执行命令&lt;code&gt;chcp 65001&lt;/code&gt;(将cmd更改为UTF-8编码)。&lt;/p&gt;
&lt;h2&gt;while 表达式&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;while&lt;/code&gt; 表达式的基本形式为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while (条件) {
    循环体
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中&quot;条件&quot;是布尔类型表达式, &quot;循环体&quot;是一个代码块。&lt;code&gt;while&lt;/code&gt; 表达式将按如下规则执行&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算&quot;条件&quot;表达式, 如果值为&lt;code&gt;true&lt;/code&gt;则执行&quot;循环体&quot;, 值为&lt;code&gt;false&lt;/code&gt;则跳出&lt;code&gt;while&lt;/code&gt;表达式&lt;/li&gt;
&lt;li&gt;执行&quot;循环体&quot;, 然后跳回第1步&lt;/li&gt;
&lt;li&gt;继续执行&lt;code&gt;while&lt;/code&gt;表达式后面的代码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下程序使用&lt;code&gt;while&lt;/code&gt;表达式, 输出数字 0 到 10&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    var num: Int64 = 0
    while (num &amp;lt;= 10) {
        println(num)
        num++
    }
    println(&quot;while执行完毕&quot;)
}

## do-while 表达式
`do-while` 表达式的基本形式为

```Cangjie
do {
    循环体
} while (条件)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中&quot;条件&quot;是布尔类型表达式, &quot;循环体&quot;是一个代码块。&lt;code&gt;do-while&lt;/code&gt; 表达式将按如下规则执行&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;执行&quot;循环体&quot;, 转第2步&lt;/li&gt;
&lt;li&gt;计算&quot;条件&quot;表达式, 如果值为&lt;code&gt;true&lt;/code&gt;则跳回第1步, 值为&lt;code&gt;false&lt;/code&gt;则跳出&lt;code&gt;do-while&lt;/code&gt;表达式&lt;/li&gt;
&lt;li&gt;继续执行&lt;code&gt;do-while&lt;/code&gt;表达式后面的代码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以下程序使用&lt;code&gt;do-while&lt;/code&gt;表达式, 输出数字 0 到 10&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    var num: Int64 = 0
    do {
        println(num)
        num++
    } while (num &amp;lt;= 10)
    println(&quot;do-while执行完毕&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;for-in 表达式&lt;/h2&gt;
&lt;p&gt;for-in 表达式可以遍历那些扩展了迭代器接口iterable&amp;lt;T&amp;gt;的类型实例&lt;/p&gt;
&lt;p&gt;for-in 表达式的基本形式为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;for (迭代变量 in 序列) {
    循环体
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中&quot;循环体&quot;是一个代码块, &quot;迭代变量&quot;用于绑定每轮遍历中由迭代器指向的数据, 可以作为&quot;循环体&quot;中的局部变量使用。&quot;序列&quot;是一个表达式, 目前我们理解为一组数据, 例如&lt;code&gt;[&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]&lt;/code&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算&quot;序列&quot;表达式, 将其值作为遍历对象, 并初始化遍历对象的迭代器。&lt;/li&gt;
&lt;li&gt;更新迭代器, 如果迭代器终止, 转第4步, 否则转第3步&lt;/li&gt;
&lt;li&gt;将当前迭代器指向的数据与&quot;迭代变量&quot;绑定, 并执行&quot;循环体&quot;, 转第2步。&lt;/li&gt;
&lt;li&gt;结束循环, 继续执行for-in表达式后面的代码&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;        [开始]
          |
          v
       /       \
      /  遍历是  \
     /   否结束   \
    |             |
    | YES         | NO
    v             v
  [结束]       [print(i)]
                  |
                  ------------|
                              |
                              v
                         回到判断条件
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;main() {
    let userName = [&quot;张三&quot;, &quot;李四&quot;, &quot;王五&quot;]
    for (name in userName) {
        print(name)
    }
}
// result: 张三李四王五
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;遍历区间&lt;/h3&gt;
&lt;p&gt;for-in 表达式可以遍历区间类型实例
区间的格式是 &lt;code&gt;start..=end:step&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1..=100 // 表示从1~100的数字
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用for-in表达式完成从0+...100的数字和&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    var num = 0
    for (i in 1..=100) {
        sum += i
    }
    println(&quot;sum = ${sum}&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;迭代变量不可修改&lt;/h3&gt;
&lt;p&gt;在 for-in 表达式的循环体中, 不能修改迭代变量, 例如以下程序在编译时会报错:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    for (i in 0..5){
        i = i * 10 // error: cannot assign to immutable value
        println(i)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;where 条件&lt;/h3&gt;
&lt;p&gt;在部分循环遍历场景中, 对于特定取值的迭代变量, 我们可能需要直接跳过, 进入下一轮循环, 仓颉为此提供了更便捷的表达方式--可以在所遍历的&quot;序列&quot;之后用where关键字引导一个布尔表达式, 这样在每次将进入循环体执行前, 会先计算此表达式, 如果值为true则执行循环体, 反之直接进入下一轮循环&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    for (i in 0..8 where i % 2 == 1) {  // i 为奇数时才会执行循环体
        println(&quot;i = ${i}&quot;)
    }
}
// result: 1 3 5 7
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;break 与 continue 表达式&lt;/h2&gt;
&lt;p&gt;在循环结构的程序中, 有时我们需要根据特定条件提前结束循环或跳过本轮循环, 为此仓颉引入了&lt;code&gt;break&lt;/code&gt;与&lt;code&gt;continue&lt;/code&gt;表达式, 它们可以出现在循环表达式的循环体中, break用于终止当前循环表达式的执行、转去执行循环表达式后面的代码, continue用于跳过本轮循环, 直接转去执行下一轮循环&lt;/p&gt;
&lt;p&gt;例如, 以下程序使用for-in表达式和break表达式, 在给定的整数数组中, 找到第一个能被5整除的数字:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    let numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9]
    for (number in numbers) {
        if (number % 5 == 0) {
            println(&quot;第一个能被5整除的数字是: ${number}&quot;)
            break
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以下程序使用for-in表达式和continue表达式, 将给定的整数数组中的奇数打印出来:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    let numbers = [12, 18, 25, 36, 49, 55]
    for (number in numbers) {
        if (number % 2 == 0) {
            continue  // 如果是偶数, 跳过本轮循环
        }
        println(&quot;奇数: ${number}&quot;)
    }
}
// result: 奇数: 25 奇数: 49 奇数: 55
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;基本数据类型&lt;/h2&gt;
&lt;p&gt;仓颉中的基本数据类型, 包括: 整数类型、浮点类型、布尔类型、字符类型、字符串类型、&lt;code&gt;Unit&lt;/code&gt;类型、元组类型、区间类型、&lt;code&gt;Nothing&lt;/code&gt;类型&lt;/p&gt;
&lt;h3&gt;整数类型 Int&amp;amp;UInt&lt;/h3&gt;
&lt;p&gt;整数类型分为有符号 (signed) 整数类型和无符号 (unsigned) 整数类型&lt;br /&gt;
&lt;strong&gt;有符号整数类型&lt;/strong&gt;: &lt;code&gt;Int8&lt;/code&gt;、&lt;code&gt;Int16&lt;/code&gt;、&lt;code&gt;Int32&lt;/code&gt;、&lt;code&gt;Int64&lt;/code&gt;&lt;br /&gt;
&lt;strong&gt;无符号整数类型&lt;/strong&gt;: &lt;code&gt;UInt8&lt;/code&gt;、&lt;code&gt;UInt16&lt;/code&gt;、&lt;code&gt;UInt32&lt;/code&gt;、&lt;code&gt;UInt64&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;下表列出了所有整数类型的表示范围&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;表示范围&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Int8&lt;/td&gt;
&lt;td&gt;-2&amp;lt;sup&amp;gt;7&amp;lt;/sup&amp;gt; ~ 2&amp;lt;sup&amp;gt;7&amp;lt;/sup&amp;gt;-1 (-128 ~ 127)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Int16&lt;/td&gt;
&lt;td&gt;-2&amp;lt;sup&amp;gt;15&amp;lt;/sup&amp;gt; ~ 2&amp;lt;sup&amp;gt;15&amp;lt;/sup&amp;gt;-1 (-32,768 ~ 32,767)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Int32&lt;/td&gt;
&lt;td&gt;-2&amp;lt;sup&amp;gt;31&amp;lt;/sup&amp;gt; ~ 2&amp;lt;sup&amp;gt;31&amp;lt;/sup&amp;gt;-1 (-2,147,483,648 ~ 2,147,483,647)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Int64&lt;/td&gt;
&lt;td&gt;-2&amp;lt;sup&amp;gt;63&amp;lt;/sup&amp;gt; ~ 2&amp;lt;sup&amp;gt;63&amp;lt;/sup&amp;gt;-1 (-9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UInt8&lt;/td&gt;
&lt;td&gt;0 ~ 2&amp;lt;sup&amp;gt;8&amp;lt;/sup&amp;gt;-1 (0 ~ 255)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UInt16&lt;/td&gt;
&lt;td&gt;0 ~ 2&amp;lt;sup&amp;gt;16&amp;lt;/sup&amp;gt;-1 (0 ~ 65,535)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UInt32&lt;/td&gt;
&lt;td&gt;0 ~ 2&amp;lt;sup&amp;gt;32&amp;lt;/sup&amp;gt;-1 (0 ~ 4,294,967,295)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;UInt64&lt;/td&gt;
&lt;td&gt;0 ~ 2&amp;lt;sup&amp;gt;64&amp;lt;/sup&amp;gt;-1 (0 ~ 18,446,744,073,709,551,615)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;程序具体使用哪种整数类型, 取决于该程序中需要处理的整数的性质和范围。在&lt;code&gt;Int64&lt;/code&gt;类型适合的情况下, 首选&lt;code&gt;Int64&lt;/code&gt;类型, 因为&lt;code&gt;int64&lt;/code&gt;的表示范围足够大, 并且整数字面量在没有类型上下文的情况下默认推断为&lt;code&gt;Int64&lt;/code&gt;类型, 可以避免不必要的类型转换&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    let a = 100
    pring(a is Int64)
}
// result: true
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;整数类型字面量&lt;/h4&gt;
&lt;p&gt;整数类型字面量有 4 种进制表示形式: 二进制 (使用0b 或 0B 前缀)、八进制 (使用0o 或 0O 前缀)、十进制 (不使用前缀) 和十六进制 (使用0x 或 0X 前缀)。例如, 对于十进制数 24, 表示成二进制是 0b00011000 (或 0B00011000)、八进制是 0o30 (或 0O30)、十六进制是 0x18 (或 0X18)。&lt;br /&gt;
在使用整数类型时, 可以通过加入后缀来明确整数字面量的类型, 后缀于类型的对应为&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;后缀&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;后缀&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;u8&lt;/td&gt;
&lt;td&gt;UInt8&lt;/td&gt;
&lt;td&gt;i8&lt;/td&gt;
&lt;td&gt;Int8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;u16&lt;/td&gt;
&lt;td&gt;UInt16&lt;/td&gt;
&lt;td&gt;i16&lt;/td&gt;
&lt;td&gt;Int16&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;u32&lt;/td&gt;
&lt;td&gt;UInt32&lt;/td&gt;
&lt;td&gt;i32&lt;/td&gt;
&lt;td&gt;Int32&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;u64&lt;/td&gt;
&lt;td&gt;UInt64&lt;/td&gt;
&lt;td&gt;i64&lt;/td&gt;
&lt;td&gt;Int64&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;var x = 100i8   // x is 100 with type Int8
var y = 16u64   // y is 16 with type UInt64
var z = 282i32  // z is 282 with type Int32
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;浮点类型 Float&lt;/h3&gt;
&lt;p&gt;浮点类型包括 Float16、Float32 和 Float64&lt;/p&gt;
&lt;p&gt;Float64 的精度约为小数点后 15 位, Float32 的精度约为小数点后 6位, Float16 的精度约为小数点后 3 位。使用哪种浮点类型, 取决于代码中需要处理的浮点数的性质和范围。在多种浮点类型都适合的情况下, 首选精度高的浮点类型, 因为精度低的浮点类型的累计计算误差很容易扩散, 并且它能精确表示的整数范围也很有限&lt;/p&gt;
&lt;h4&gt;浮点类型字面量&lt;/h4&gt;
&lt;p&gt;浮点类型字面量有两种进制表示形式: 十进制、十六进制。在十进制表示中, 一个浮点字面量至少要包含一个整数部分或一个小数部分, 没有小数部分时必须包含指数部分 (以 e 或 E 为前缀, 底数为 10)。在十六进制表示中, 一个浮点字面量除了至少要包含一个整数部分或一个小数部分 (以 0x 或 0X 为前缀), 同时必须包含指数部分 (以 p 或 P 为前缀, 底数为 2)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a: Float32 = 3.14
let b: Float32 = 2e3
let c: Float32 = 2.4e-1
let d: Float32 = 0x1p2
let e: Float64 = 0x2p4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在使用浮点数时, 可以通过加入后缀来明确浮点字面量的类型, 后缀与类型的对应为&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;后缀&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;后缀&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;后缀&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;f16&lt;/td&gt;
&lt;td&gt;Float16&lt;/td&gt;
&lt;td&gt;f32&lt;/td&gt;
&lt;td&gt;Float32&lt;/td&gt;
&lt;td&gt;f64&lt;/td&gt;
&lt;td&gt;Float64&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;let a = 3.14f16     // a is 3.14 with type Float16
let b = 2e3f32      // b is 2e3 with type Float32
let c = 2.4e-1f64   // c is 2.4e-1 with type Float64
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;布尔类型 Bool&lt;/h3&gt;
&lt;p&gt;布尔类型使用&lt;code&gt;Bool&lt;/code&gt;表示, 用来表示逻辑中的真和假&lt;/p&gt;
&lt;h4&gt;布尔类型字面量&lt;/h4&gt;
&lt;p&gt;布尔类型字面量有两个: &lt;code&gt;true&lt;/code&gt; 和 &lt;code&gt;false&lt;/code&gt;。布尔类型的值可以通过逻辑运算符 (如与、或、非) 进行组合和计算&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a: Bool = true
let b: Bool = false
let c: Bool = a &amp;amp;&amp;amp; b
let d: Bool = a || b
let e: Bool = !a
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;回顾if表达式&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;from std import random.*
main() {
    let speed = Random(). nextFloat64() * 20.0
    println(&quot;${speed} km/s&quot;)
    println(speed &amp;gt; 16.7)               // true or false
    if (speed &amp;gt; 16.7) {
        println(&quot;第三宇宙速度, 鹊桥相会&quot;)
    } else if (speed &amp;gt; 11.2) {
        println(&quot;第二宇宙速度, 嫦娥奔月&quot;)
    } else if (speed &amp;gt; 7.9) {
        println(&quot;第一宇宙速度, 腾云驾雾&quot;)
    } else {
        println(&quot;脚踏实地, 仰望星空&quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;回顾while表达式&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;main() {
    var num: Int64 = 0
    while (num &amp;lt;= 10) {
        println(num)
        num++
        println(num &amp;lt;= 10)              // true or false
    }
    println(&quot;while执行完毕&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;字符类型 Rune&lt;/h3&gt;
&lt;p&gt;字符类型使用&lt;code&gt;Char&lt;/code&gt;表示, 可以表示 Unicode 字符集中的所有字符。&lt;br /&gt;
当前, 仓颉已经引入了&lt;code&gt;Rune&lt;/code&gt;, &lt;code&gt;Rune&lt;/code&gt;是&lt;code&gt;Char&lt;/code&gt;的类型别名, 定义为&lt;code&gt;type Rune = Char&lt;/code&gt;&lt;br /&gt;
&lt;code&gt;Rune&lt;/code&gt;的语义与&lt;code&gt;Char&lt;/code&gt;相同。目前&lt;code&gt;Rune&lt;/code&gt;与&lt;code&gt;Char&lt;/code&gt;短期共存, 但是将来&lt;code&gt;Char&lt;/code&gt;将会被删除, 建议需要使用字符类型的地方使用&lt;code&gt;Rune&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;温馨提示&lt;/strong&gt;&lt;br /&gt;
Unicode源于一个很简单的想法: 将全世界所有的字符包含在一个集合里, 计算机只要支持这一个字符集, 就能显示所有的字符, 再也不会有乱码了&lt;/p&gt;
&lt;h4&gt;字符类型字面量&lt;/h4&gt;
&lt;p&gt;字符类型字面量有三种形式: 单个字符、转义字符和通用字符, 它们均使用一对单引号定义&lt;/p&gt;
&lt;p&gt;&lt;code&gt;单个字符&lt;/code&gt;的字符字面量举例:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let a: Rune = &apos;a&apos;
let b: Rune = &apos;b&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;转义字符&lt;/code&gt;是指在一个字符序列中对后面的字符进行另一种解释的字符。转义字符使用转义符号&lt;code&gt;\&lt;/code&gt;开头, 后面加需要转义的字符。 举例如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let slash: Rune = &apos;\\&apos;
let newline: Rune = &apos;\n&apos;
let tab: Rune = &apos;\t&apos;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;通用字符&lt;/code&gt;以&lt;code&gt;\u&lt;/code&gt;开头, 后面加上定义在一对花括号&lt;code&gt;{}&lt;/code&gt;中的 1~8个十六进制数, 即可表示对应的 Unicode 值代表的字符。 举例如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    let a: Rune = &apos;\u{4E2D}&apos; // 中
    let b: Rune = &apos;\u{534E}&apos; // 华
    let c: Rune = &apos;\u{6C11}&apos; // 民
    let d: Rune = &apos;\u{65CF}&apos; // 族
    let result: String = String(a) + String(b) + String(c) + String(d)
    print(result)
}
// result: 中华民族
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;字符串类型 String&lt;/h3&gt;
&lt;p&gt;字符串类型使用&lt;code&gt;String&lt;/code&gt;表示, 用于表达文本数据, 由一串 Unicode 字符组合而成&lt;/p&gt;
&lt;h4&gt;字符串类型字面量&lt;/h4&gt;
&lt;p&gt;字符串字面量分为三类: 单行字符串字面量、多行字符串字面量、多行原始字符串字面量&lt;/p&gt;
&lt;p&gt;&lt;code&gt;单行字符串字面量&lt;/code&gt; 的内容定义在一对双引号之内&lt;code&gt;&quot;&quot;&lt;/code&gt;, 双引号中的内容可以是任意数量的 (除了非转义的双引号和单独出现的&lt;code&gt;\&lt;/code&gt;之外的) 任意字符。单行字符串字面量只能写在同一行,不能跨多行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let s1: String = &quot;&quot;
let s2 = &quot;Hello Cangjie Lang&quot;
let s3 = &quot;\&quot;Hello Cangjie Lang\&quot;&quot;
let s4 = &quot;Hello Cangjie Lang\n&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;多行字符串字面量&lt;/code&gt; 以三个双引号开头&lt;code&gt;&quot;&quot;&quot;&lt;/code&gt;, 并以三个双引号结尾&lt;code&gt;&quot;&quot;&quot;&lt;/code&gt;,并且开头的三个双引号之后需要换行(否则编译错误)。字面量的内容从开头的三个双引号换行后的第一行开始, 到结尾的三个双引号之前结束, 之前的内容可以是任意数量的(除单个出现的&lt;code&gt;\&lt;/code&gt;之外的) 任意字符。不同于单行字符串字面量, 多行字符串字面量可以跨多行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let s1: String = &quot;&quot;&quot;
&quot;&quot;&quot;
let s2 = &quot;&quot;&quot;
    Hello,
    Cangjie Lang&quot;&quot;&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;多行原始字符串字面量&lt;/code&gt; 以一个或多个井号&lt;code&gt;#&lt;/code&gt; 加上一个双引号开始, 并以一个双引号加上和开始相同个数的&lt;code&gt;#&lt;/code&gt;结束。开始的双引号和结束的双引号之间的内容可以是任意数量的任意合法字符。不同于 (普通) 多行字符串字面量, 多行原始字符串字面量中的内容会维持原样 (转义字符不会被转义, 如下例中 s2 中的 \n 不是换行符, 而是由 \ 和 n 组成的字符串 \n)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let s1: String = #&quot;&quot;#
let s2 = ##&quot;\n&quot;##
let s3 = ###&quot;
    Hello,
    Canjie
    Lang&quot;###
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;插值字符串&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;插值字符串&lt;/code&gt;是一种包含一个或多个插值表达式的字符串字面量 (不适用于多行原始字符串字面量), 通过将表达式插入到字符串中, 可以有效避免字符串拼接的问题。&lt;/p&gt;
&lt;p&gt;插值表达式必须用花括号&lt;code&gt;{}&lt;/code&gt;包起来, 并在花括号前加上美元符号&lt;code&gt;$&lt;/code&gt;, 例如&lt;code&gt;&quot;${expression}&quot;&lt;/code&gt;。&lt;code&gt;{}&lt;/code&gt;中可以包含一个或者多个声明或表达式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    let fruit = &quot;apples&quot;
    let count = 10
    let s = &quot;There are ${count * count} ${fruit}&quot;
    println(s)  // There are 100 apples
    
    let r = 2.4
    let area = &quot;There area of a circle with redius ${r} is ${let pi = 3.14; pi * r * r}&quot;
    println(area) // There area of a circle with redius 2.400000 is 18.086400
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;数组类型 Array&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;Array&lt;/code&gt;类型来构造单一元素类型, 有序序列的数据&lt;br /&gt;
仓颉使用Array&amp;lt;T&amp;gt;来表示Array类型。T 表示 Array 的元素类型, T 可以是任意类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a: Array&amp;lt;Int64&amp;gt; = ... // Array whose element type is Int64
var b: Array&amp;lt;String&amp;gt; = ... // Array whose element type is String
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;元素类型不相同的 Array 是不相同的类型, 所有它们之间不可以互相赋值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;b = a // Type mismatch error
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以使用字面量来初始化一个 Array, 只需使用方括号将逗号分隔的值列表括起来即可&lt;br /&gt;
编译器会根据上下文自动推断 Array 字面量的类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let b = [1, 2, 3, 4, 5]     // Array&amp;lt;Int64&amp;gt;
let c = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]     // Array&amp;lt;String&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以使用构造函数的方式构造一个指定元素类型的 Array&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let c = Array&amp;lt;Int64&amp;gt;(3, item: 0) // [0, 0, 0]
let d = Array&amp;lt;Int64&amp;gt;(3, {i =&amp;gt; i + 1}) // [1, 2, 3]

⬆ `3` 表示 Array 的长度, `item` 表示 Array 中的每个元素的初始值, 也可以使用闭包来初始化 Array 中的每个元素
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;访问 Array 成员&lt;/h4&gt;
&lt;p&gt;当需要对 Array 的所有元素进行访问时, 可以使用 for-in 表达式遍历 Array 的所有元素&lt;br /&gt;
Array 是按元素插入顺序排列的, 因此对 Array 遍历的顺序总是恒定的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    let arr = [0, 1, 2]
    for (i in arr) {
        println(&quot;The element is ${i}&quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当需要知道某个 Array 包含的元素个数时, 可以使用 size 属性来获取。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    let arr = [0, 1, 2]
    println(&quot;The size of the array is ${arr.size}&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意: &lt;s&gt;属性不用( )&lt;/s&gt;, 方法要用( )&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当需要访问 Array 中的某个元素时, 可以使用下标运算符&lt;code&gt;[]&lt;/code&gt;来访问&lt;br /&gt;
非空 Array 的第一个元素总是从位置 0 开始&lt;br /&gt;
索引值不能使用&lt;code&gt;负数&lt;/code&gt;或者大于等于 Array 的长度, 当编译器能检查出索引值非法时, 会在编译时报错, 否则会在运行时抛异常。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    let arr = [0, 1, 2]
    let a = arr[0]  // 0
    let b = arr[1]  // 1
    println(&quot;The first element is ${a}&quot;)
    println(&quot;The second element is ${b}&quot;)
    let c = arr[-1] // error: index out of range
    println(&quot;The last element is ${c}&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果想获取某一段 Array 的元素, 可以在下标中传入 Range 类型的值, 就可以一次性取得 Range 对应范围的一段 Array&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let arr1 = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
let arr2 = arr1[1..3]   // [20, 30]
let arr3 = arr1[4..=7]  // [50, 60, 70, 80]
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;修改 Array&lt;/h4&gt;
&lt;p&gt;Array 是一种长度不变的 Collection 类型, 因此 Array 没有提供添加和删除元素的成员函数&lt;br /&gt;
但 Array 允许对其中的元素进行修改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    let arr = [0, 1, 2]
    arr[0] = 10
    println(arr[0])  // 10
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Array 是引用类型, 因此 Array 在作为表达式使用时不会拷贝副本, 同一个 Array 实例的所有引用都会共享同样的数据。&lt;br /&gt;
因此对 Array 元素的修改会影响到该实例的所有引用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    let arr1 = [0, 1, 2]
    let arr2 = arr1
    arr2[0] = 10
    println(arr1) // [10, 1, 2]
    println(arr2) // [10, 1, 2]

    // ⬇ 值传递类型
    var msg1 = 100
    var msg2 = msg1
    msg1 = 200
    println(msg1) // 200
    println(msg2) // 100
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;值类型数组 VArray&lt;/h3&gt;
&lt;p&gt;仓颉编程语言引入了值类型数组 &lt;code&gt;VArray&amp;lt;T, $N&amp;gt;&lt;/code&gt;, 其中&lt;code&gt;T&lt;/code&gt;表示该值类型数组的元素类型, &lt;code&gt;$N&lt;/code&gt;是一个固定的语法, 通过&lt;code&gt;$&lt;/code&gt;加上一个数值字面量表示这个值类型数组的长度&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var a: VArray&amp;lt;Int64, $3&amp;gt; = [1, 2, 3]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同时, 它拥有两个构造函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// VArray&amp;lt;T, $N&amp;gt;(initElement: (Int64) -&amp;gt; T)
let b = VArray&amp;lt;Int64, $5&amp;gt;({ i =&amp;gt; i })   // [0, 1, 2, 3, 4]
println(b[3]) // 3
// VArray&amp;lt;T, $N&amp;gt;(item!: T)
let c = VArray&amp;lt;Int64, $5&amp;gt;(item: 0)      // [0, 0, 0, 0, 0]
println(c[3]) // 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除此之外, &lt;code&gt;VArray&amp;lt;T, $N&amp;gt;&lt;/code&gt;类型提供了两个成员方法&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用于下标访问和修改的&lt;code&gt;[]&lt;/code&gt;操作符方法:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;var a: VArray&amp;lt;Int64, $3&amp;gt; = [1, 2, 3]
let i = a[1]
a[2] = 4
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;用于获取&lt;code&gt;VArray&lt;/code&gt;长度的&lt;code&gt;size&lt;/code&gt;方法:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;var a: VArray&amp;lt;Int64, $3&amp;gt; = [1, 2, 3]
let s = a.size
println(s) // 3
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;区间类型 Range&lt;/h3&gt;
&lt;p&gt;区间类型用于表示拥有固定步长的序列, 使用&lt;code&gt;Range&amp;lt;T&amp;gt;&lt;/code&gt;表示。当&lt;code&gt;T&lt;/code&gt;被实例化不同的类型时, 会得到不同的区间类型, 如最常用的&lt;code&gt;Range&amp;lt;Int64&amp;gt;&lt;/code&gt;用于表示整数区间&lt;/p&gt;
&lt;p&gt;每个区间类型的实例都会包含&lt;code&gt;start&lt;/code&gt;(起始值)、&lt;code&gt;end&lt;/code&gt;(终止值)和&lt;code&gt;step&lt;/code&gt;(步长)三个属性, &lt;code&gt;start&lt;/code&gt;和&lt;code&gt;end&lt;/code&gt;的类型相同(即&lt;code&gt;T&lt;/code&gt;被实例化的类型), &lt;code&gt;step&lt;/code&gt;类型是&lt;code&gt;Int64&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;区间类型字面量&lt;/h4&gt;
&lt;p&gt;区间字面量有两种形式: &quot;左闭右开&quot;区间和&quot;左闭右闭&quot;区间。其中, &quot;左闭右开&quot;区间的格式是&lt;code&gt;start..end : step&lt;/code&gt;, 表示一个从&lt;code&gt;start&lt;/code&gt;开始, 以&lt;code&gt;step&lt;/code&gt;为步长, 到&lt;code&gt;end&lt;/code&gt;(不包含&lt;code&gt;end&lt;/code&gt;)为止的区间; &quot;左闭右闭&quot;区间的格式是&lt;code&gt;start..=end : step&lt;/code&gt;, 表示一个从&lt;code&gt;start&lt;/code&gt;开始, 以&lt;code&gt;step&lt;/code&gt;为步长, 到&lt;code&gt;end&lt;/code&gt;(包含&lt;code&gt;end&lt;/code&gt;)为止的区间&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let n = 10
let r1 = 0..10:1    // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
let r2 = 0..=n:1    // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10
let r3 = n..0:-2    // 10, 8, 6, 4, 2
let r4 = n..=0:-2   // 10, 8, 6, 4, 2, 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;区间字面量中, 可以不写&lt;code&gt;step&lt;/code&gt;, 此时&lt;code&gt;step&lt;/code&gt;默认等于&lt;code&gt;1&lt;/code&gt;。&lt;br /&gt;
注意: &lt;code&gt;step&lt;/code&gt;不能为0, 另外区间也有可能是空的(即不包含任何元素的空序列)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let r5 = 0..10      // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9
let r6 = 0..=10:0   // error: step cannot be 0

let r7 = 10..0:1    // empty ranges
let r8 = 0..10:-1   // empty ranges
let r9 = 10..=0:1   // empty ranges
let r10 = 0..=10:-1 // empty ranges
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;&lt;br /&gt;
表达式&lt;code&gt;start..end:step&lt;/code&gt;中, 当&lt;code&gt;step &amp;gt; 0&lt;/code&gt;且&lt;code&gt;start &amp;gt;= end&lt;/code&gt;, 或者&lt;code&gt;step &amp;lt; 0&lt;/code&gt;且&lt;code&gt;start &amp;lt;= end&lt;/code&gt;时, &lt;code&gt;start..end:step&lt;/code&gt;是一个空区间; 表达式&lt;code&gt;start..=end:step&lt;/code&gt;中, 当&lt;code&gt;step &amp;gt; 0&lt;/code&gt;且&lt;code&gt;start &amp;gt; end&lt;/code&gt;, 或者&lt;code&gt;step &amp;lt; 0&lt;/code&gt;且&lt;code&gt;start &amp;lt; end&lt;/code&gt;时, &lt;code&gt;start..=end:step&lt;/code&gt;是一个空区间&lt;/p&gt;
&lt;h3&gt;元组类型 Tuple&lt;/h3&gt;
&lt;p&gt;元组(Tuple)可以将多个不同的类型组合在一起, 成为一个新的类型。元组类型使用(T1, T2, ..., Tn)表示, 其中T1~Tn可以是任意类型, 不同类型间使用逗号&lt;code&gt;,&lt;/code&gt;链接。元组至少是二元以上, 例如, &lt;code&gt;(Int64, Float64)&lt;/code&gt;表示一个二元组类型, &lt;code&gt;(Int64, Float64, String)&lt;/code&gt;表示一个三元组类型&lt;/p&gt;
&lt;p&gt;元组的长度是固定的, 即一旦定义了一个元组类型的实例, 它的长度不能再更改&lt;/p&gt;
&lt;p&gt;元组支持通过&lt;code&gt;t[index]&lt;/code&gt;的方式访问某个具体位置的元素, 其中&lt;code&gt;t&lt;/code&gt;是一个元组, &lt;code&gt;index&lt;/code&gt;是下标, 并且&lt;code&gt;index&lt;/code&gt;只能是从&lt;code&gt;0&lt;/code&gt;开始且小于元组元素个数的整数类型字面量, 否则, 编译报错。&lt;br /&gt;
下面的例子中, 使用&lt;code&gt;pi[0]&lt;/code&gt;和&lt;code&gt;pi[1]&lt;/code&gt;可以分别访问二元组&lt;code&gt;pi&lt;/code&gt;的第一个和第二个元素:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    vat pi = (3.14, &quot;PI&quot;)
    println(pi[0])  // 3.14
    println(pi[1])  // PI
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;元组类型是不可变类型, 即一旦定义一个元组类型的实例, 内容不再被更新&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var tuple = (true, false)
tuple[0] = false         // error: cannot assign to immutable value
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;元组类型的字面量&lt;/h4&gt;
&lt;p&gt;元组类型的字面量使用&lt;code&gt;(E1, E2, ..., En)&lt;/code&gt;表示, 其中E1~En是表达式, 多个表达式之间使用逗号分隔。&lt;/p&gt;
&lt;p&gt;下面的例子中, 分别定义了一个&lt;code&gt;(Int64, Float64)&lt;/code&gt;类型的变量x, 以及一个&lt;code&gt;(Int64, Float64, String)&lt;/code&gt;类型的变量y, 并且使用元组类型的字面量初始化:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let x: (Int64, Float64) = (2, 3.14159)
let y: (Int64, Float64, String) = (2, 3.14159, &quot;PI&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;元组类型的类型参数&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;let tuple: (name: String, age: Int64) = (&quot;apple&quot;, 18)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于一个元组类型, 只允许统一写类型参数名, 或者统一不写类型参数名, 不能部分写类型参数名, 否则编译报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let tuple: (String, age: Int64) = (&quot;apple&quot;, 18) // error: type parameter name mismatch
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;其他类型&lt;/h3&gt;
&lt;h4&gt;Unit 类型&lt;/h4&gt;
&lt;p&gt;对于那些只关心副作用而不关心值得表达式, 它们的类型是&lt;code&gt;Unit&lt;/code&gt;。&lt;br /&gt;
例如, &lt;code&gt;print&lt;/code&gt;函数、赋值表达式、复合赋值表达式、自增和自减表达式、循环表达式, 它们的类型都是&lt;code&gt;Unit&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Unit&lt;/code&gt;类型只有一个值, 也就是它的字面量&lt;code&gt;()&lt;/code&gt;。除了赋值、判等和判不等外, &lt;code&gt;Unit&lt;/code&gt;类型不支持其它操作&lt;/p&gt;
&lt;h4&gt;Nothing 类型&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Nothing&lt;/code&gt;是一种特殊的类型, 它不包含任何值, 并且&lt;code&gt;Nothing&lt;/code&gt;类型是所有类型的子类型&lt;/p&gt;
&lt;p&gt;&lt;code&gt;break&lt;/code&gt;、&lt;code&gt;continue&lt;/code&gt;、&lt;code&gt;return&lt;/code&gt;、&lt;code&gt;throw&lt;/code&gt;表达式的类型是&lt;code&gt;Nothing&lt;/code&gt;, 程序执行到这些表达式时, 它们之后的代码将不会被执行。其中&lt;code&gt;break&lt;/code&gt;、&lt;code&gt;continue&lt;/code&gt;只能在循环体中使用, &lt;code&gt;return&lt;/code&gt;只能在函数体中使用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;&lt;br /&gt;
目前编译器还不允许在使用类型的地方显式使用&lt;code&gt;Nothing&lt;/code&gt;类型, 例如: &lt;code&gt;let a: Nothing = ()&lt;/code&gt;会报错, 但是可以在函数返回值的地方使用&lt;code&gt;Nothing&lt;/code&gt;类型, 例如: &lt;code&gt;return break&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;运算符&lt;/h2&gt;
&lt;h3&gt;算术运算符&lt;/h3&gt;
&lt;p&gt;算术运算符包含&quot;加、减、乘、除、取余、自增和自减&quot;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    var add: Int64
    var x = 10
    var y = 20
    add = x + y
    println(&quot;x + y = ${add}&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;余数运算符&lt;/h4&gt;
&lt;p&gt;余数运算符是比较常用的, 因为在逻辑思维上寻找规律, 余数运算符是很好用的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    var result: Int64
    var x = 101
    var y = 5
    result = x % y
    println(&quot;x % y = ${result}&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;自增和自减运算符&lt;/h4&gt;
&lt;p&gt;自增和自减运算符, 是一元运算符, 只需一个运算子。它们的作用是将运算子首先转为数值, 然后加上1或减去1&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    var x = 10
    var y = 20
    x++
    y--
    println(&quot;x++ = ${x}&quot;) // 11
    println(&quot;y-- = ${y}&quot;) // 19
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;赋值运算符&lt;/h3&gt;
&lt;p&gt;赋值运算符(Assignment Operators)用于给变量赋值&lt;/p&gt;
&lt;p&gt;最常见的赋值运算符, 是&lt;code&gt;=&lt;/code&gt;运算符, 它将右侧的值赋给左侧的变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main() {
    var x = 10
    var y = x
    println(&quot;y = ${y}&quot;)  // 10
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;复合赋值运算符&lt;/h4&gt;
&lt;p&gt;赋值运算符还可以与其他运算符结合, 形成变体。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x += 1      // x = x + 1
x -= 1      // x = x - 1
x *= 2      // x = x * 2
x /= 2      // x = x / 2
x %= 2      // x = x % 2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;比较运算符&lt;/h3&gt;
&lt;p&gt;比较运算符用于比较两个值的大小, 返回布尔值&lt;code&gt;true&lt;/code&gt;或&lt;code&gt;false&lt;/code&gt;, 表示是否满足指定的条件&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;比较运算符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;&lt;/td&gt;
&lt;td&gt;小于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;gt;&lt;/td&gt;
&lt;td&gt;大于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;lt;=&lt;/td&gt;
&lt;td&gt;小于等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&amp;gt;=&lt;/td&gt;
&lt;td&gt;大于等于&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;==&lt;/td&gt;
&lt;td&gt;判等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;!=&lt;/td&gt;
&lt;td&gt;判不等&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;pre&gt;&lt;code&gt;from std import random.*
main() {
    let number: Int8 = Random().nextInt8()
    if (number % 2 == 0){
        println(&quot;even&quot;)
    } else {
        println(&quot;odd&quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;布尔运算符&lt;/h3&gt;
&lt;p&gt;常用的布尔运算符有&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;(与)、&lt;code&gt;||&lt;/code&gt;(或)、&lt;code&gt;!&lt;/code&gt;(非)&lt;/p&gt;
&lt;h4&gt;取反运算符 (&lt;code&gt;!&lt;/code&gt;)&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;!true // false
!false // true
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;与运算符 (&lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt;)&lt;/h4&gt;
&lt;p&gt;多个条件都要满足&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (10 &amp;lt; 20 &amp;amp;&amp;amp; 10 &amp;gt; 5) {
    println(&quot;Yes&quot;)
} else {
    println(&quot;No&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;或运算符 (&lt;code&gt;||&lt;/code&gt;)&lt;/h4&gt;
&lt;p&gt;只要有一个条件满足即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if (10 &amp;lt; 20 || 10 &amp;gt; 5) {
    println(&quot;Yes&quot;)
} else {
    println(&quot;No&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;位运算符&lt;/h3&gt;
&lt;p&gt;位运算符直接处理每一个比特位(bit), 是非常底层的运算, 好处是速度极快, 缺点是很不直观, 许多场合不能使用它们, 否则会使代码难以理解和查错&lt;/p&gt;
&lt;h4&gt;快速计算位移方案 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt;&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;左移运算符就是*2的n次方 (n代表位移次数)&lt;/li&gt;
&lt;li&gt;右移运算符就是/2的n次方 (n代表位移次数, 不同点, 出现小数时要取整)&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;位运算演算过程&lt;/h4&gt;
&lt;h5&gt;字长&lt;/h5&gt;
&lt;p&gt;计算机的每个字包含的位数称为字长, 也称在&lt;code&gt;同一时间中CPU一次操作处理二进制的位数&lt;/code&gt;。大型计算机的字长为32-64位, 小型计算机为12-32位, 而微型计算机为4-16位。字长是衡量计算机性能的一个重要因素。现代计算机一般64位, 字长就是64位。&lt;/p&gt;
&lt;h5&gt;左移运算符 &amp;lt;&amp;lt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;5 &amp;lt;&amp;lt; 2  // 20
↓
0000 0000 0000 0000 0000 0000 0000 0101 // 5
0000 0000 0000 0000 0000 0000 0001 0100 // 20 左移2位
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;右移运算符 &amp;gt;&amp;gt;&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;1000 &amp;gt;&amp;gt; 8  // 3
↓
0000 0000 0000 0000 0000 0011 1110 1000 // 1000
0000 0000 0000 0000 0000 0000 0000 0011 // 3 右移8位
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;十进制转为二进制&lt;/h3&gt;
&lt;p&gt;采用&quot;除2取余, 逆序排列&quot;的方法&lt;br /&gt;
例如: 10转为二进制&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;10 / 2 = 5  余数0
5 / 2 = 2   余数1
2 / 2 = 1   余数0
1 / 2 = 0   余数1
得到的余数逆序排列就是10的二进制数: 1010
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;函数&lt;/h2&gt;
&lt;h3&gt;定义函数&lt;/h3&gt;
&lt;p&gt;仓颉使用关键字&lt;code&gt;func&lt;/code&gt;来表示函数定义的开始, &lt;code&gt;func&lt;/code&gt;之后依次是函数名、参数列表、可选的函数返回值类型、函数体。其中, 函数名可以是任意的合法标识符, 参数列表定义在一对圆括号内(多个参数间使用逗号分隔), 参数列表和函数返回值类型(如果存在)之间使用冒号间隔, 函数体定义在一对花括号内。&lt;/p&gt;
&lt;p&gt;func add(a: Int64, b: Int64): Int64 {
return a + b
}
↑ 上例中定义了一个名为&lt;code&gt;add&lt;/code&gt;的函数, 其参数列表由两个&lt;code&gt;Int64&lt;/code&gt;类型的参数&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;组成, 函数返回值类型为&lt;code&gt;Int64&lt;/code&gt;, 函数体中使用&lt;code&gt;return&lt;/code&gt;语句返回两个参数的和&lt;/p&gt;
&lt;h4&gt;函数调用&lt;/h4&gt;
&lt;p&gt;函数调用的形式为&lt;code&gt;funcName(arg1, arg2, ..., argn)&lt;/code&gt;。其中, &lt;code&gt;funcName&lt;/code&gt;是要调用的函数名, &lt;code&gt;arg1&lt;/code&gt; ~ &lt;code&gt;argn&lt;/code&gt;是n个调用时的参数(称为实参), 要求每个实参的类型必须是对应参数类型的子类型。实参可以有0个或多个, 当实参个数为0时, 调用方式为&lt;code&gt;funcName()&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;参数列表&lt;/h4&gt;
&lt;p&gt;一个函数可以拥有0个或多个参数, 这些参数均定义在函数的参数列表中。根据函数调用时是否需要给定参数名, 可以将参数列表中的参数分为两类: &lt;code&gt;非命名参数&lt;/code&gt;和&lt;code&gt;命名参数&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;非命名参数的定义方式是&lt;code&gt;p:T&lt;/code&gt;, 其中&lt;code&gt;p&lt;/code&gt;是参数名, &lt;code&gt;T&lt;/code&gt;是参数&lt;code&gt;p&lt;/code&gt;的类型, 参数名和其类型间使用冒号链接。例如, 上例中&lt;code&gt;add&lt;/code&gt;函数的两个参数&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;均为非命名参数&lt;/p&gt;
&lt;p&gt;命名参数的定义方式是&lt;code&gt;p!:T&lt;/code&gt;, 与非命名参数的不同是在参数名&lt;code&gt;p&lt;/code&gt;之后多了一个&lt;code&gt;!&lt;/code&gt;。可以将上例中&lt;code&gt;add&lt;/code&gt;函数的两个非命名参数修改为命名参数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func add(a!: Int64, b!: Int64): Int64 {
    return a + b
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;命名参数还可以设置默认值, 通过&lt;code&gt;p!:T = e&lt;/code&gt;方式将参数&lt;code&gt;p&lt;/code&gt;的默认值设置为表达式&lt;code&gt;e&lt;/code&gt;的值。&lt;br /&gt;
例如, 可以将上述&lt;code&gt;add&lt;/code&gt;函数的两个参数的默认值都设置为&lt;code&gt;1&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func add(a!: Int64 = 1, b!: Int64 = 1): Int64 {
    return a + b
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;非命名参数和命名参数的主要差异在于调用时的不同&lt;/p&gt;
&lt;p&gt;根据函数定义时参数是非命名参数还是命名参数的不同, 函数调用时传实参的方式也有所不同: 对于非命名参数, 它对应的实参是一个表达式, 对于命名参数, 它对应的实参需要使用&lt;code&gt;p:e&lt;/code&gt;的形式, 其中&lt;code&gt;p&lt;/code&gt;是命名参数的名字, &lt;code&gt;e&lt;/code&gt;是表达式(即传递给参数&lt;code&gt;p&lt;/code&gt;的值)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func add(a!: Int64 = 1, b!: Int64 = 1): Int64 {
    return a + b
}
add(a:10, b:20)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;函数参数均为不可变变量, 在函数定义内不能对其赋值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func add(a: Int64, b: Int64): Int64 {
    a = a + b // error: cannot assign to immutable value
    return a
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;返回值&lt;/h3&gt;
&lt;h4&gt;函数返回值类型&lt;/h4&gt;
&lt;p&gt;函数返回值类型是函数被调用后得到的值的类型, 函数定义时, 返回值类型是可选的: 可以显式地定义返回值类型(返回值类型定义在参数列表和函数体之间), 也可以不定义返回值类型, 交由编译器推导确定&lt;/p&gt;
&lt;p&gt;当显式地定义了函数返回值类型时, 就要求函数体的类型、函数体中所有&lt;code&gt;return e&lt;/code&gt;表达式中&lt;code&gt;e&lt;/code&gt;的类型是返回值类型的子类型。&lt;br /&gt;
例如, 对于上述&lt;code&gt;add&lt;/code&gt;函数, 显示地定义了它的返回值类型为&lt;code&gt;Int64&lt;/code&gt;, 如果将函数体中地&lt;code&gt;return a + b&lt;/code&gt;修改为&lt;code&gt;return (a, b)&lt;/code&gt;, 则会因为类型不匹配而报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Error: the type of the expression after return does not match the return type of the function
func add(a: Int64, b: Int64): Int64 {
    return (a, b)   // error: type mismatch
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在函数定义时如果未显式定义返回值类型, 编译器将根据函数体的类型以及函数体中所有地&lt;code&gt;return&lt;/code&gt;表达式来共同推导出函数的返回值类型。&lt;br /&gt;
例如, 下列&lt;code&gt;add&lt;/code&gt;函数的返回值类型虽然被省略, 但编译器可以根据&lt;code&gt;return a + b&lt;/code&gt;推导出&lt;code&gt;add&lt;/code&gt;函数的返回值类型是&lt;code&gt;Int64&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func add(a: Int64, b: Int64) {
    return a + b    // return type is Int64
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;&lt;br /&gt;
函数的返回值类型并不是任何情况下都可以被推导出来的, 如果返回值类型推导失败, 编译报错&lt;/p&gt;
&lt;h4&gt;函数体&lt;/h4&gt;
&lt;p&gt;函数体中定义了函数被调用时执行的操作, 通常包含一系列的变量定义和表达式, 也可以包含新的函数定义(即嵌套函数)。&lt;br /&gt;
如下&lt;code&gt;add&lt;/code&gt;函数的函数体中首先定义了&lt;code&gt;Int64&lt;/code&gt;类型的变量&lt;code&gt;r&lt;/code&gt;(初始值为0), 接着将&lt;code&gt;a + b&lt;/code&gt;的值赋于&lt;code&gt;r&lt;/code&gt;, 最后返回&lt;code&gt;r&lt;/code&gt;的值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func add(a: Int64, b: Int64): Int64 {
    var r: Int64 = 0
    r = a + b
    return r
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在函数体的任意位置都可以使用&lt;code&gt;return&lt;/code&gt;表达式来终止函数的执行并返回。&lt;code&gt;return&lt;/code&gt;表达式有两种形式:&lt;code&gt;return&lt;/code&gt;和&lt;code&gt;return expr&lt;/code&gt;( expr 是一种表达式)&lt;/p&gt;
&lt;p&gt;对于&lt;code&gt;return expr&lt;/code&gt;, 要求&lt;code&gt;expr&lt;/code&gt;的类型与函数定义的返回值类型保持一致。&lt;br /&gt;
例如, 下例中会因为&lt;code&gt;return 100&lt;/code&gt;中&lt;code&gt;100&lt;/code&gt;类型(&lt;code&gt;Int64&lt;/code&gt;)和函数&lt;code&gt;foo&lt;/code&gt;的返回值类型&lt;code&gt;String&lt;/code&gt;不同而报错&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// Error: the type of the expression after return does not match the return type of the function
func foo(): String {
    return 100 // error: type mismatch
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于&lt;code&gt;return&lt;/code&gt;, 其等价于&lt;code&gt;return ()&lt;/code&gt;, 所以函数的返回值类型为&lt;code&gt;Uint&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func add(a: Int64, b: Int64) {
    var r = 0
    r = a + b
    return r
}

func foo(): Unit{
    add(1, 2)
    return
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;提示&lt;/strong&gt;&lt;br /&gt;
&lt;code&gt;return&lt;/code&gt;表达式作为一个整体, 其类型并不由后面跟随的表达式决定, 而是 Nothing 类型&lt;/p&gt;
&lt;p&gt;在函数体内定义的变量属于局部变量的一种, 它的作用域从其定义之后开始到函数体结束&lt;/p&gt;
&lt;p&gt;对于一个局部变量, 允许在其外层作用域中定义同名变量, 并且在此局部变量的作用域内, 局部变量会&quot;遮盖&quot;外层作用域的同名变量&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;let r = 0
func add(a: Int64, b: Int64) {
    var r = 0
    r = a + b
    return r
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;👆上例, &lt;code&gt;add&lt;/code&gt;函数之前定义了&lt;code&gt;Int64&lt;/code&gt;类型的全局变量&lt;code&gt;r&lt;/code&gt;, 同时&lt;code&gt;add&lt;/code&gt;函数体内定义了同名的局部变量&lt;code&gt;r&lt;/code&gt;, 那么在函数体内, 所有使用变量&lt;code&gt;r&lt;/code&gt;的地方(如&lt;code&gt;r = a + b&lt;/code&gt;), 用到的将是局部变量&lt;code&gt;r&lt;/code&gt;, 即(在函数体内)局部变量&lt;code&gt;r&lt;/code&gt;&quot;遮盖&quot;了全局变量&lt;code&gt;r&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;函数体也是有类型的, 函数体的类型是函数体内最后一&quot;项&quot;的类型: 若最后一项为表达式, 则函数体的类型是此表达式的类型, 若最后一项为变量定义或函数声明, 或函数体为空, 则函数体的类型为 &lt;code&gt;Unit&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func add(a: Int64, b: Int64): Int64 {
    a + b
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;👆上例, 因为函数体的最后一&quot;项&quot;是&lt;code&gt;Int64&lt;/code&gt;类型的表达式(即&lt;code&gt;a + b&lt;/code&gt;), 所以函数体的类型也是&lt;code&gt;Int64&lt;/code&gt;, 与函数定义的返回值类型相匹配。&lt;br /&gt;
又如, 下例函数体的最后一项是&lt;code&gt;print&lt;/code&gt;函数调用, 所以函数体的类型是&lt;code&gt;Unit&lt;/code&gt;, 同样与函数定义的返回值类型相匹配&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func foo(): Unit{
    let s = &quot;Hello&quot;
    println(s)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;一等公民&lt;/h3&gt;
&lt;p&gt;仓颉编程语言中, 函数是一等公民(first-class citizens), 可以作为函数的参数或返回值, 也可以赋值给变量。因此函数本身也有类型, 称为函数类型&lt;/p&gt;
&lt;h4&gt;函数类型&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;函数类型&lt;/code&gt;由函数的参数类型和返回类型组成, 参数类型和返回类型之间使用&lt;code&gt;-&amp;gt;&lt;/code&gt;连接。参数类型使用圆括号&lt;code&gt;()&lt;/code&gt;括起来, 可以有0个或多个参数, 如果参数超过两个, 参数类型之间使用逗号&lt;code&gt;,&lt;/code&gt;分隔&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func hello(): Unit{
    println(&quot;Hello!&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;👆示例定义了一个函数, 函数名为hello, 其类型是&lt;code&gt;()-&amp;gt;Unit&lt;/code&gt;,表示该函数没有参数, 返回类型为&lt;code&gt;Unit&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func add(a: Int64, b: Int64): Int64 {
    a + b
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;👆函数名为&lt;code&gt;add&lt;/code&gt;, 其类型是&lt;code&gt;(Int64, Int64) -&amp;gt; Int64&lt;/code&gt;, 表示该函数有两个参数, 两个参数类型均为&lt;code&gt;Int64&lt;/code&gt;, 返回类型为&lt;code&gt;Int64&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;函数类型作为参数类型&lt;/h4&gt;
&lt;p&gt;示例: 函数名为&lt;code&gt;printAdd&lt;/code&gt;, 其类型是&lt;code&gt;((Int64, Int64) -&amp;gt; Int64, Int64, Int64) -&amp;gt; Unit&lt;/code&gt;, 表示该函数有三个参数, 参数类型分别为函数类型&lt;code&gt;(Int64, Int64) -&amp;gt; Int64&lt;/code&gt;和两个&lt;code&gt;Int64&lt;/code&gt;, 返回类型为&lt;code&gt;Unit&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func printAdd(add: (Int64, Int64) -&amp;gt; Int64, a: Int64, b: Int64 ): Unit {
    println(add(a, b))
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;func demo(x: Int64, y: Int64): Int64{
    return x * y
}
main() {
    printAdd(demo, 10, 10)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;函数类型作为返回类型&lt;/h4&gt;
&lt;p&gt;函数类型可以作为另一个函数的返回类型
👇示例, 函数名为&lt;code&gt;returnAdd&lt;/code&gt;, 其类型是&lt;code&gt;() -&amp;gt; (Int64, Int64) -&amp;gt; Int64&lt;/code&gt;, 表示该函数无参数, 返回类型为函数类型&lt;code&gt;(Int64, Int64) -&amp;gt; Int64&lt;/code&gt;。注意,&lt;code&gt;-&amp;gt;&lt;/code&gt;是右结合的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func add(a: Int64, b: Int64): Int64 {
    return a + b
}
func returnAdd(): (Int64, Int64) -&amp;gt; Int64 {
    add
}
main() {
    var a = returnAdd()
    println(a(1, 2)) // 3
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;函数类型作为变量类型&lt;/h4&gt;
&lt;p&gt;函数名本身也是表达式, 它的类型为对应的函数类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func add(p1: Int64, p2: Int64): Int64 {
    p1 + p2
}

let f: (Int64, Int64) -&amp;gt; Int64 = add
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;嵌套函数&lt;/h3&gt;
&lt;h2&gt;更多资源搜索&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://cangjie-lang.cn&quot;&gt;仓颉编程语言官网&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.huawei.com/consumer/cn/&quot;&gt;华为开发者联盟&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gitcode.com/Cangjie&quot;&gt;GitCode 仓颉&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=IDE-Innovation-Lab.cangjie&quot;&gt;Cangjie Vscode插件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>Arbitrum Stylus 全方位解析：核心竞争力与实践教程</title><link>https://newpower.pro/posts/blockchain/arbitrum/arbitrumstylustutorial/</link><guid isPermaLink="true">https://newpower.pro/posts/blockchain/arbitrum/arbitrumstylustutorial/</guid><description>深度解析 Arbitrum Stylus 的核心技术优势，包括多语言支持、性能跃升、Gas 成本降低、扩展性及模块化架构，并提供实践教程与未来展望。</description><pubDate>Sun, 11 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;在区块链开发领域，智能合约的技术瓶颈长期困扰着开发者：Solidity 单一语言生态的封闭性、EVM 计算效率的天花板、高昂的 Gas 费用，如同三重枷锁限制着 Web3 应用的创新边界。2023 年，Arbitrum 推出的 Stylus 技术打破了这一僵局，通过多语言支持、极致性能优化、Gas 成本锐减、无缝扩展性与模块化架构，为智能合约开发开启了全新维度。&lt;/p&gt;
&lt;p&gt;Arbitrum Stylus 是 Arbitrum 网络中的一项新型功能，旨在为智能合约开发者提供更灵活、更高性能的工具。它打破了传统 EVM 框架中只能使用 Solidity 的限制，使得开发者可以借助多种编程语言（如 C、C++、Rust 等）在 Arbitrum 上编写合约，从而提升可扩展性与开发效率。根据官方文档和不同社区的测试，Stylus 在性能和资源利用率方面具有显著优势，引起了广泛关注。&lt;/p&gt;
&lt;p&gt;本文将结合官方资料和社区经验，深度解析 Stylus 如何重塑行业规则，并为读者提供一份详尽的使用指南与未来展望。&lt;/p&gt;
&lt;h2&gt;一、Arbitrum Stylus：重新定义智能合约的核心竞争力&lt;/h2&gt;
&lt;p&gt;Stylus 的出现，为智能合约开发带来了革命性的变化。其核心竞争力主要体现在以下几个方面：&lt;/p&gt;
&lt;h3&gt;1.1 编程语言革命：从「Solidity 孤岛」到「全栈语言互联」&lt;/h3&gt;
&lt;p&gt;传统 EVM 生态中，Solidity 是唯一官方语言，导致全球 90% 以上的开发者（精通 Rust/C++/Python 等主流语言）被挡在 Web3 门外。Stylus 通过 &lt;strong&gt;WASM（WebAssembly）技术&lt;/strong&gt; 彻底打破壁垒：&lt;/p&gt;
&lt;h4&gt;1.1.1 工业级语言原生支持&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;Rust/C++ 首选&lt;/strong&gt;：支持内存安全特性的 Rust（杜绝缓冲区溢出、悬垂指针等漏洞）与高性能计算见长的 C++，可直接编译为 WASM 字节码部署至 Arbitrum 链。例如，Rust 的加密库 &lt;code&gt;rust-crypto&lt;/code&gt;、C++ 的数学库 &lt;code&gt;Eigen&lt;/code&gt; 可无缝集成到智能合约。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生态无缝对接&lt;/strong&gt;：通过 &lt;code&gt;wasm-bindgen&lt;/code&gt; 等工具，Python/Go 代码可间接转译为 WASM，实现「全栈语言上链」，彻底释放传统软件生态的万亿级开发资源。&lt;/p&gt;
&lt;p&gt;通过 Stylus，开发者在获取底层性能的同时也能灵活使用多样化的编程范式，例如 Rust 中的所有权模型、C++ 强调的面向对象特性等。在传统 EVM 框架下，一些高级语言特性往往需要手动转换为 Solidity 能接受的形式，但在 Stylus 中，此类操作可得到一定的简化。尤其在涉及大量运算或自定义内存结构时，多语言的支持可显著降低开发难度、提高执行效率。&lt;/p&gt;
&lt;h4&gt;1.1.2 双引擎互操作架构&lt;/h4&gt;
&lt;p&gt;Stylus 并非推翻 EVM，而是构建 &lt;strong&gt;「EVM+WASM」双虚拟机共生体系&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Solidity 合约可调用 Rust 编写的高性能算法（如 zk-SNARK 证明生成）；&lt;/li&gt;
&lt;li&gt;C++ 开发的链上游戏逻辑能直接读取 EVM 账户的 ERC-721 资产；&lt;/li&gt;
&lt;li&gt;跨语言合约通过 ArbOS 的 &lt;code&gt;arbitrum-std&lt;/code&gt; 标准库实现数据交互，例如：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// Rust合约调用EVM的ERC-20转账
let transfer_result = evm_call(
    &quot;0xTokenContractAddress&quot;,
    &quot;transfer&quot;,
    &amp;amp;[sender_address, receiver_address, amount]
);

// EVM合约调用Rust的哈希计算
let hash = wasm_call(&quot;crypto_module&quot;, &quot;sha256&quot;, &amp;amp;data_bytes);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;(注：上述代码片段为示意，具体实现需参考 Stylus SDK)&lt;/strong&gt;\&lt;/p&gt;
&lt;h3&gt;1.2 性能跃升与成本锐减&lt;/h3&gt;
&lt;h4&gt;1.2.1 性能跃升：从「EVM 龟速」到「WASM 超音速」&lt;/h4&gt;
&lt;p&gt;EVM 的栈式架构在复杂计算中效率低下，而 Stylus 基于 WASM 的线性内存模型与 JIT 编译，实现 &lt;strong&gt;10-100 倍性能突破&lt;/strong&gt;（数据来源：Arbitrum 官方测试网）：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;strong&gt;计算场景&lt;/strong&gt;&lt;/th&gt;
&lt;th&gt;EVM 执行时间&lt;/th&gt;
&lt;th&gt;Stylus（Rust）&lt;/th&gt;
&lt;th&gt;效率提升&lt;/th&gt;
&lt;th&gt;Gas 成本对比&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SHA-256 哈希计算&lt;/td&gt;
&lt;td&gt;120ms&lt;/td&gt;
&lt;td&gt;8ms&lt;/td&gt;
&lt;td&gt;15 倍&lt;/td&gt;
&lt;td&gt;降低 93%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;椭圆曲线签名生成&lt;/td&gt;
&lt;td&gt;450ms&lt;/td&gt;
&lt;td&gt;32ms&lt;/td&gt;
&lt;td&gt;14 倍&lt;/td&gt;
&lt;td&gt;降低 89%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;金融衍生品定价模型&lt;/td&gt;
&lt;td&gt;1.2s&lt;/td&gt;
&lt;td&gt;65ms&lt;/td&gt;
&lt;td&gt;18 倍&lt;/td&gt;
&lt;td&gt;降低 91%&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这种提升在 DeFi 高频交易中尤为关键：某算法交易协议迁移至 Stylus 后，每秒可处理 2000 笔套利交易，而同等操作在 EVM 上因 Gas 限制最多仅能处理 50 笔。&lt;/p&gt;
&lt;h4&gt;1.2.2 Gas 成本锐减：让「链上计算自由」成为可能&lt;/h4&gt;
&lt;p&gt;高 Gas 费用曾是链上复杂逻辑的「拦路虎」，Stylus 通过三重优化实现成本革命：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;计算效率原生优势&lt;/strong&gt;：WASM 的二进制指令密度比 EVM 字节码高 50%，且无需复杂的 Gas 计量模型，同等计算量下 Gas 消耗呈指数级下降。例如：
&lt;ul&gt;
&lt;li&gt;链上验证一个 zk-SNARK 证明，EVM 需消耗 200 万 Gas（约 15 美元），Stylus 仅需 20 万 Gas（约 1.2 美元）；&lt;/li&gt;
&lt;li&gt;复杂的金融合约交互（如期权定价），Gas 成本从平均 50 美元降至 3 美元以下。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存与存储优化&lt;/strong&gt;：Rust 的所有权系统避免了 EVM 常见的「数据拷贝损耗」，WASM 的紧凑格式使链上存储成本降低 40%。某 NFT 游戏迁移后，角色属性动态更新的 Gas 成本从 2000Gas 降至 800Gas。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;据官方及社区的基准测试，Stylus 合约在同等操作下往往可以实现较低的 Gas 消耗，同时保有更快的执行速度。尤其当合约逻辑复杂时，使用系统级语言可能在内存管理、计算等方面带来效率收益。&lt;/p&gt;
&lt;h3&gt;1.3 扩展性突破与生态融合：从「功能受限」到「场景无限」&lt;/h3&gt;
&lt;p&gt;Stylus 通过模块化架构与生态兼容性，解锁三大类此前 EVM 无法承载的场景，并与 Arbitrum 生态深度融合：&lt;/p&gt;
&lt;h4&gt;1.3.1 高性能金融应用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;高频交易协议&lt;/strong&gt;：C++ 编写的订单簿引擎支持 10 万 TPS，延迟控制在 50 微秒，为算法交易、量化策略提供基础设施；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实时风险计算&lt;/strong&gt;：Rust 实现的蒙特卡洛模拟合约，可在 200ms 内完成万人级保单的风险评估，推动去中心化保险产品落地。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1.3.2 链上原生交互体验&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;实时物理引擎&lt;/strong&gt;：C++ 移植的 Box2D 引擎在链上实现车辆碰撞、流体模拟，某赛车游戏因此达到 120FPS 流畅度，操作延迟从 3 秒缩短至 200ms；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;动态 NFT 系统&lt;/strong&gt;：支持复杂状态变更（如武器磨损度、土地肥力），单合约调用 Gas 成本仅为 EVM 的 1/20。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1.3.3 企业级合规需求&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;KYC/AML 模块&lt;/strong&gt;：金融机构用 C++ 开发的合规验证逻辑，处理速度提升 50 倍，同时满足 GDPR 数据隐私要求；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;供应链溯源&lt;/strong&gt;：Rust 实现的零知识证明合约，在不泄露商业数据的前提下完成跨企业验证，审计时间从 30 天压缩至 2 小时。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;1.3.4 合约可组合性&lt;/h4&gt;
&lt;p&gt;除了性能的提升，Arbitrum Stylus 也关注与其他协议的交互和可组合性。Stylus 将使复杂协议在合约层面的互操作变得更加容易，可在更多场景下实现与 DeFi、NFT 或其他 Layer 2 协议的联动。&lt;/p&gt;
&lt;h4&gt;1.3.5 与 Arbitrum 生态的融合&lt;/h4&gt;
&lt;p&gt;Stylus 充分利用了 Arbitrum 在 Layer 2 的技术栈，依托安全性与高吞吐量的基础，提供易于使用的接口。它既能与传统的 EVM 合约配合，实现资源共享和模块化部署，也能独立运行基于系统级语言的业务逻辑，兼具灵活性和兼容性。&lt;/p&gt;
&lt;h3&gt;1.4 Stylus 技术架构与核心原理&lt;/h3&gt;
&lt;h4&gt;1.4.1 Stylus 技术模块：构建开发者友好生态&lt;/h4&gt;
&lt;p&gt;Arbitrum 通过三层技术架构降低开发门槛，形成完整工具链闭环：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;语言层：保留开发习惯&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;支持主流 IDE（VS Code/PyCharm）调试，兼容 Git 版本控制与 Docker 容器化部署；&lt;/li&gt;
&lt;li&gt;提供 &lt;code&gt;arbitrum-std-rs&lt;/code&gt; (针对 Rust) 等标准库，封装区块链核心接口（如区块高度获取、合约调用）：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// 示例：获取当前区块时间戳 (具体API请参考官方SDK)
let current_time = arbitrum::chain::timestamp();

// 示例：查询ERC-20合约余额 (具体API请参考官方SDK)
let balance = arbitrum::evm::erc20::balance_of(
     token_contract,
     user_address
);
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;编译执行层：高效转化链路&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基于 LLVM 编译器链，将高级语言转为 WASM 字节码，支持 &lt;code&gt;cargo build --release&lt;/code&gt; 一键生成部署文件；&lt;/li&gt;
&lt;li&gt;Stylus VM 针对区块链场景优化，内存访问速度比通用 WASM 引擎快 30%。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;互操作层：无缝连接 EVM&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ArbOS 作为「智能合约操作系统」，实现双虚拟机状态共享与函数互调；&lt;/li&gt;
&lt;li&gt;支持 Solidity 与 Rust/C++ 合约在同一交易中协同，例如：Rust 预言机获取链下数据后，触发 EVM 借贷合约的利率调整。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;1.4.2 背景：EVM 的局限与 Layer 2 的演进&lt;/h4&gt;
&lt;p&gt;以太坊虚拟机（EVM）为智能合约生态提供了基础支撑，但其在性能与多语言支持上存在局限。这些局限使得编写与部署高性能合约的过程较为艰难，尤其在涉及复杂业务逻辑或者需要高吞吐量时。&lt;/p&gt;
&lt;p&gt;Arbitrum 作为一种 Layer 2 解决方案，在主链上通过汇总批量交易来降低 Gas 成本并提高可扩展性。它利用了自己的执行环境，同时通过 Rollup 技术将交易数据安全地记录在以太坊上，实现高效与安全的平衡。&lt;/p&gt;
&lt;h4&gt;1.4.3 Stylus 的引入：Arbitrum 上的协同工作方式&lt;/h4&gt;
&lt;p&gt;在深入讨论之前，需要进一步了解 Stylus 引擎与 Arbitrum Rollup 之间的协同工作方式。Stylus 背后的核心思路是将多语言编译产物转换为与 Arbitrum VM 兼容的字节码，并利用 Arbitrum 的 Rollup 机制实现高吞吐量的交易打包与提交。同时，Stylus 还注重可维护性，对跨语言交互和数据结构格式进行了适配，让不同语言实现的逻辑能在同一合约生态中顺畅调用与组合。这为复杂场景下的风险控制与扩展提供了创新空间。&lt;/p&gt;
&lt;p&gt;在此基础上，Arbitrum 推出了 Stylus，实现了对多种系统级语言编写智能合约的支持。与传统 EVM 合约相比，Stylus 合约运行在与 Arbitrum 兼容的环境中，利用字节码级的方式整合 Rust、C/C++ 等语言所编译生成的构件。这使得开发者可在熟悉的语言中进行编程，并在 Arbitrum 上享受更高的吞吐量与灵活性。&lt;/p&gt;
&lt;h2&gt;二、基础使用流程与示例&lt;/h2&gt;
&lt;h3&gt;2.1 环境准备&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;编译工具链&lt;/strong&gt;：确保安装适用于目标语言（Rust/C/C++）的编译器，如进行 Rust 开发时，需要安装 &lt;code&gt;rustup&lt;/code&gt; 并设置好相应的 nightly 工具链。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Arbitrum 节点或测试网络&lt;/strong&gt;：可选择官方提供的 Rollup 测试环境，或者在本地搭建一个 Arbitrum 节点，用于对合约进行本地测试。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SDK 获取&lt;/strong&gt;：从官方仓库 (如 &lt;a href=&quot;https://github.com/OffchainLabs/stylus-sdk-rs&quot;&gt;OffchainLabs/stylus-sdk-rs&lt;/a&gt; for Rust) 克隆或下载最新版本的 Stylus SDK，并按照文档指引进行安装和配置。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;2.2 编写 Stylus 合约&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;项目初始化&lt;/strong&gt;：以 Rust 为例，可使用 &lt;code&gt;cargo new&lt;/code&gt; 命令创建新项目。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;实现业务逻辑&lt;/strong&gt;：在项目中编写具体的函数和数据结构，并保证符合 Stylus 运行环境的适配要求（如入口函数、内存管理、回调等）。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;测试与调试&lt;/strong&gt;：在本地通过编译工具链测试代码逻辑，使用官方或社区提供的测试框架检查合约行为。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于开发者而言，除了要掌握基本的 Rust 或 C/C++ 语法外，还需理解 Stylus 合约如何与 Arbitrum 上的其他合约进行信息交互。例如，与传统 EVM 合约之间的调用方式会包含一层 Stylus 专用的编解码步骤，确保映射到通用的字节码接口后双方能够正确接收与发送数据。同时，合约内部需要对 Gas 成本保持敏感，因为虽然 Stylus 有潜在的费用和性能优势，但不合理的逻辑仍可能导致资源浪费。&lt;/p&gt;
&lt;h3&gt;2.3 编译与部署&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;编译生成字节码&lt;/strong&gt;：按照 Stylus SDK 的说明，将 Rust/C/C++ 源码编译为 Stylus 兼容的字节码包。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;部署脚本&lt;/strong&gt;：使用 Arbitrum 提供的 CLI 工具或 Web 界面，将生成的字节码合约部署到测试网或主网。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;合约交互&lt;/strong&gt;：完成部署后，即可通过 Arbitrum 的 RPC 或者兼容的工具（如 Hardhat、Foundry 等），对合约方法进行调用或阅读合约状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在部署合约时，需要注意目标链所在的网络环境，如测试网或主网。为了在测试环境中更快地迭代，开发者可借助 Arbitrum 提供的公共测试网，或本地模拟环境，先完成初步验证和调试，再通过官方 CLI 或者第三方工具进行正式部署。部署后，可使用类似 Hardhat 或 Foundry 等工具与合约进行交互、测试调用结果，并借助区块浏览器或监控服务查看合约执行的细节与统计信息。&lt;/p&gt;
&lt;h3&gt;2.4 使用示例 (Rust)&lt;/h3&gt;
&lt;p&gt;以下为一个极简的 Rust 示例，仅用于演示合约编写逻辑与部署方式（具体可参考官方 &lt;a href=&quot;https://docs.arbitrum.io/stylus/gentle-introduction&quot;&gt;Gentle Introduction&lt;/a&gt; 及相关文档）：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 假设在 main.rs 中使用 Rust 编写
// 真实的 Stylus 合约会使用 SDK 提供的宏和类型
#![cfg_attr(not(feature = &quot;export-abi&quot;), no_main)]
extern crate alloc;

#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

use stylus_sdk::{alloy_primitives::U256, prelude::*};

sol_storage! {
    #[entrypoint] // 使其成为合约的入口点
    struct Counter {
        uint256 number;
    }
}
//
#[external] // 标记为外部可调用函数
impl Counter {
    pub fn number(&amp;amp;self) -&amp;gt; Result&amp;lt;U256, Vec&amp;lt;u8&amp;gt;&amp;gt; {
        Ok(self.number.get())
    }

    pub fn set_number(&amp;amp;mut self, new_number: U256) -&amp;gt; Result&amp;lt;(), Vec&amp;lt;u8&amp;gt;&amp;gt; {
        self.number.set(new_number);
        Ok(())
    }

    pub fn increment(&amp;amp;mut self) -&amp;gt; Result&amp;lt;(), Vec&amp;lt;u8&amp;gt;&amp;gt; {
        let current = self.number.get();
        self.number.set(current + U256::from(1));
        Ok(())
    }
}

// 以下为原文中提供的极简示例，非标准 Stylus 合约格式，仅作概念演示
fn main() {
    // 在 Stylus 中执行的简单示例逻辑
    // 例如：读取输入参数、执行一些计算，然后返回结果
    let result = add(2, 3);
    println!(&quot;Execution result: {}&quot;, result);
}

fn add(a: i32, b: i32) -&amp;gt; i32 {
    a + b
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上方的 Rust 示例（&lt;code&gt;main&lt;/code&gt; 和 &lt;code&gt;add&lt;/code&gt; 函数）仅仅展示了一个最简化的逻辑概念，并非一个可直接部署的 Stylus 合约。一个真正的 Stylus 合约（如注释中展示的 &lt;code&gt;Counter&lt;/code&gt; 示例结构）会使用 Stylus SDK 提供的宏（如 &lt;code&gt;sol_storage!&lt;/code&gt;, &lt;code&gt;#[entrypoint]&lt;/code&gt;, &lt;code&gt;#[external]&lt;/code&gt;）和特定的类型来定义状态和函数，以便与 Arbitrum 虚拟机正确交互。&lt;/p&gt;
&lt;p&gt;在真正的 Stylus 合约中，我们往往会定义多种接口函数和业务逻辑模块，并通过 SDK 中的 ABI 适配层来处理对外接口。很多情况下，需要结合链下数据进行混合计算或操作，例如通过 Oracles 获取价格信息，再在合约内执行精准的数值运算。正是这些对多语言特性的需求，促使 Stylus 的开发与演进。&lt;/p&gt;
&lt;p&gt;在完成本地测试后，通过 Stylus SDK 对项目进行打包并部署，即可在 Arbitrum 网络中与该合约进行交互。&lt;/p&gt;
&lt;h2&gt;三、常见问题、未来展望与结语&lt;/h2&gt;
&lt;h3&gt;3.1 常见问题&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;合约审计&lt;/strong&gt;：虽然 Stylus 提供多语言支持，但依然需要对合约逻辑、边界条件和安全隐患进行审计。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;生态工具链&lt;/strong&gt;：Stylus 属于新兴技术，其可用的调试工具、框架与库仍在快速迭代，未来可能会出现更丰富的开发工具与最佳实践。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;与 EVM 的共存&lt;/strong&gt;：Stylus 并非取代 EVM，而是与 EVM 合约共同存在，为开发者提供多元化选择。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能与可扩展性&lt;/strong&gt;：后续官方或社区仍会进行深入优化，包含编译器层面和执行引擎层面的改进，提升整体性能。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外，由于 Stylus 仍处于积极的迭代阶段，合约安全审核和工具链测试必须引起足够的重视。开发者在正式发布前，应该借鉴常见的漏洞分析方法，对可能出现的越界读写、内存泄漏或函数访问控制不当等问题进行排查。&lt;/p&gt;
&lt;h3&gt;3.2 未来展望与结语&lt;/h3&gt;
&lt;p&gt;随着社区的不断壮大，更多的审计机构和开发团队也将逐步建立完善的最佳实践与范式。未来，随着在合规性与易用性方面的改进，Stylus 将有望进一步融入主流 Layer 2 生态。&lt;/p&gt;
&lt;p&gt;Arbitrum Stylus 的价值，远不止于技术参数的提升，更在于它打破了「区块链开发的语言壁垒」，让数千万传统开发者首次拥有平等参与 Web3 的机会。当 Rust 工程师能用熟悉的语言编写 DeFi 协议，当 C++ 开发者为链游注入复杂物理逻辑，当企业架构师用 Stylus 构建合规链上系统，我们正在见证的，是智能合约从「极客玩具」到「主流基础设施」的历史性跨越。&lt;/p&gt;
&lt;p&gt;对于开发者而言，现在正是抢占技术先机的黄金窗口 ——Stylus 不仅是一个工具，更是通往 Web3 创新蓝海的通行证。随着 Arbitrum 生态的持续扩张，这场由编程语言引发的革命，终将重塑整个区块链开发的未来图景。&lt;/p&gt;
&lt;p&gt;通过上述内容，可以进一步深入了解 Stylus 的实现原理与应用场景。总之，Arbitrum Stylus 集多语言支持、执行效率与安全性于一体，为智能合约开发者提供了新的选择。希望本教程能为初次接触本技术的读者带来帮助，后续可持续关注官方与社区的更新，及时掌握最新功能与最佳实践。&lt;/p&gt;
&lt;p&gt;对于那些希望通过多语言能力来提升合约可读性与可维护性的团队而言，Stylus 的出现无疑是一个重要机遇。它不仅扩大了人才储备的范围，也为各类新型用例提供了技术可行性。在具体应用上，无论是对 NFT 协议进行技术创新，还是实现更加复杂的金融衍生品逻辑，都可以充分利用多语言编程带来的灵活性。未来，借助社区的力量，Stylus 有望提供更齐全的库与开发框架来支撑大型项目的持续迭代与运行。&lt;/p&gt;
&lt;p&gt;希望本文能为读者提供一个清晰的 Stylus 入门指南，帮助大家在 Arbitrum 生态中更好地发挥多语言编程的优势。随着技术的不断发展，Stylus 将在智能合约领域扮演越来越重要的角色。&lt;/p&gt;
&lt;h2&gt;四、参考资料与延伸探索&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://arbitrum.io/stylus&quot;&gt;Arbitrum 官方介绍&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.arbitrum.io/stylus/gentle-introduction&quot;&gt;Arbitrum Stylus Gentle Introduction (官方入门文档)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.welldonestudio.io/tutorials/arbitrum-stylus-benchmark&quot;&gt;Arbitrum Stylus Benchmark&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://fishyonchain.medium.com/arbitrum-stylus-a-new-standard-for-smart-contract-composability-2c5c3679ca20&quot;&gt;Fishyonchain: Stylus 可组合性文章&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/OffchainLabs/stylus-sdk-rs&quot;&gt;Stylus SDK (Rust)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过上述资料，可以进一步深入了解 Stylus 的实现原理与应用场景。&lt;/p&gt;
</content:encoded></item><item><title>仓颉编程语言：国产编程语言的探索之路</title><link>https://newpower.pro/posts/notebook/diary/%E9%9A%8F%E7%AC%9420250510/</link><guid isPermaLink="true">https://newpower.pro/posts/notebook/diary/%E9%9A%8F%E7%AC%9420250510/</guid><description>仓颉编程语言是一款面向全场景智能的新一代编程语言，主打原生智能化、天生全场景、高性能、强安全。融入鸿蒙生态，为开发者提供良好的编程体验。全方位的编译优化和运行时实现、以及开箱即用的 IDE 工具链支持，为开发者打造友好开发体验和卓越程序性能。</description><pubDate>Sat, 10 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;作为一名练习时长1.4*两年半的程序员，我一直以来都对新兴的编程语言保持着浓厚的兴趣。当仓颉编程语言上线公测后，我毫不犹豫地开始了我的体验之旅。经过一段时间的使用，我对这款国产编程语言有了更深入的了解和感受。&lt;/p&gt;
&lt;h2&gt;一、语法融合的创新尝试&lt;/h2&gt;
&lt;p&gt;仓颉编程语言最显著的特点之一，就是其语法融合了多种主流编程语言的优点。它汲取了C语言的简洁高效、Java的面向对象特性、Go语言的并发处理优势、Rust的内存安全机制以及Python的易读易写风格。这种融合并不是简单的拼凑，而是经过精心设计，使得不同语言的优点能够相互补充，形成一种独特的编程体验。&lt;/p&gt;
&lt;p&gt;在实际使用中，我可以明显感受到这种语法融合带来的便利。例如，在处理并发任务时，仓颉语言借鉴了Go语言的协程机制，让我能够轻松地实现高效的并发编程。同时，它又继承了Rust的内存安全特性，让我在编写代码时无需过多担心内存泄漏和数据竞争等问题。这种融合让我在编写代码时能够更加专注于逻辑的实现，而不必被语言本身的限制所束缚。&lt;/p&gt;
&lt;h2&gt;二、国产编程语言的担当&lt;/h2&gt;
&lt;p&gt;新编程语言的诞生总是伴随着争议和质疑，仓颉编程语言也不例外。然而，作为一名Cn Coder，我对这款国产编程语言有着特殊的情感。尽管它目前可能还存在一些不足之处，但它的出现本身就是一种突破和尝试。在全球化的今天，技术的自主可控至关重要。仓颉编程语言的出现，让我们看到了国内在编程语言领域的发展潜力和努力方向。&lt;/p&gt;
&lt;p&gt;它不仅仅是一款编程工具，更是一种对国内计算机技术自主创新能力的推动。“花❀厂”在互联网上虽然名声褒贬不一，但它确实在一步步提升国内计算机技术的竞争力，这一点是不可否认的。在一些极端情况下，拥有自主的编程语言意味着我们不会受制于人，这对于我们国家的科技发展和技术安全具有深远的意义。&lt;/p&gt;
&lt;h2&gt;三、未来可期的探索&lt;/h2&gt;
&lt;p&gt;关于仓颉编程语言的未来，我充满期待。目前，它还处于公测阶段，我相信随着更多开发者的参与和反馈，它会不断完善和优化。至于未来是否会开源、是否会被广泛应用，这些都是值得我们关注的问题。但无论如何，仓颉编程语言的出现已经是一个很好的开始。&lt;/p&gt;
&lt;p&gt;它为国内编程语言的发展提供了一个全新的思路和方向。作为一名程序员，我愿意继续支持和尝试这款国产编程语言。我相信，只要我们给予它足够的时间和机会，它一定能够在未来的发展中展现出更大的潜力和价值。&lt;/p&gt;
&lt;p&gt;总之，仓颉编程语言是我近期使用过的一款非常有特色的编程语言。它的语法融合创新、国产语言的担当以及未来发展的潜力，都让我对它充满了信心。希望更多的开发者能够关注和支持这款国产编程语言，共同推动国内编程语言的发展。&lt;/p&gt;
</content:encoded></item><item><title>随笔20250508</title><link>https://newpower.pro/posts/notebook/diary/%E9%9A%8F%E7%AC%9420250508/</link><guid isPermaLink="true">https://newpower.pro/posts/notebook/diary/%E9%9A%8F%E7%AC%9420250508/</guid><pubDate>Thu, 08 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;🎁【开箱惊喜】HackQuest x Arbitrum共学营结营礼物大公开&lt;/h2&gt;
&lt;p&gt;激动的心，颤抖的手，终于收到了HackQuest和Arbitrum共学营的结营礼物！🎉&lt;br /&gt;
开箱的瞬间，满满的惊喜和感动，每一件小物都充满了心意和创意。🎨&lt;br /&gt;
👜 帆布袋：简约而不简单，上面的图案超级可爱，日常出门必备单品！&lt;br /&gt;
🔑 钥匙扣：设计感十足，细节满满，每次拿出钥匙都能想起这段难忘的学习旅程。&lt;br /&gt;
📚 笔记本：记录学习的点滴，每一页都是成长的见证。&lt;br /&gt;
🎖️ 徽章：每一枚都是对努力的肯定，也是对未来的期许。&lt;br /&gt;
这份礼物不仅是对过去努力的肯定，更是对未来的鼓励。感谢HackQuest和Arbitrum，让我在学习的道路上不断前行！🚀&lt;br /&gt;
Let&apos;s Quack!!!!!!!!!!!!!!!!!!!!!!!!!!&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://asset-repository.vercel.app/blog/library/H00001.jpg&quot; alt=&quot;alt text&quot; /&gt;
&lt;img src=&quot;https://asset-repository.vercel.app/blog/library/H00002.jpg&quot; alt=&quot;alt text&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>英语构词法</title><link>https://newpower.pro/posts/notebook/english/%E6%9E%84%E8%AF%8D%E6%B3%95/</link><guid isPermaLink="true">https://newpower.pro/posts/notebook/english/%E6%9E%84%E8%AF%8D%E6%B3%95/</guid><pubDate>Wed, 07 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;英语构词法：揭开词汇创造的密码&lt;/p&gt;
&lt;p&gt;你是否曾好奇英语词汇为何如此庞大且灵活？从 &quot;unhappiness&quot; 到 &quot;smartphone&quot;，从 &quot;email&quot; 到 &quot;smog&quot;，这些单词的诞生并非偶然，而是遵循着一套系统的构词规则。掌握英语构词法，就像获得一把钥匙，不仅能快速扩充词汇量，更能深入理解语言背后的逻辑。本文将带你探索构词法的核心奥秘，结合实例解析六大主要构词方式，助你成为词汇记忆的高效学习者。&lt;/p&gt;
&lt;h3&gt;一、派生法：词根词缀的化学反应&lt;/h3&gt;
&lt;p&gt;派生法是英语构词的主力军，约 70% 的词汇由此而生。它通过&lt;strong&gt;前缀改变词义&lt;/strong&gt;、&lt;strong&gt;后缀改变词性&lt;/strong&gt;，如同汉字的偏旁部首，赋予单词新的生命力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;词根的核心地位&lt;/strong&gt;：词根是单词的灵魂，如 &quot;vis&quot;（看）在 &quot;visible&quot;（可见的）、&quot;vision&quot;（视力）中反复出现。希腊语和拉丁语词根（如 &quot;hydr-&quot; 水、&quot;aqua-&quot; 水）与日耳曼语词汇（如 &quot;water&quot;）共同构成英语的双重词汇体系。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;前缀的魔术手&lt;/strong&gt;：否定前缀 &quot;un-&quot;、&quot;in-&quot;、&quot;dis-&quot; 能瞬间反转词义（happy→unhappy），而 &quot;en-&quot;（使...）可将形容词转化为动词（large→enlarge）。值得注意的是，前缀可能因发音调整拼写（如 &quot;im-possible&quot; 而非 &quot;in-possible&quot;）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;后缀的变形术&lt;/strong&gt;：后缀不仅改变词性，还能细化词义。例如，动词 &quot;work&quot; 加 &quot;-able&quot; 变为形容词 &quot;workable&quot;（可行的），而 &quot;accept&quot; 加 &quot;-able&quot; 成为 &quot;acceptable&quot;（可接受的）。需要注意的是，法语词根多接 &quot;-able&quot;，希腊 / 拉丁词根则常用 &quot;-ible&quot;（如 &quot;credible&quot; 可信的）。&lt;/p&gt;
&lt;h3&gt;二、合成法：词汇的积木游戏&lt;/h3&gt;
&lt;p&gt;合成法将两个或多个独立单词组合成新词，如同搭积木般直观。这种构词法在科技、日常用语中尤为常见，约占英语词汇的 30%。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;直接组合&lt;/strong&gt;：如 &quot;waterproof&quot;（防水的）由 &quot;water&quot;（水）和 &quot;proof&quot;（对抗）构成，&quot;highclass&quot;（高级的）结合 &quot;high&quot;（高）与 &quot;class&quot;（等级）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;混合词的创意&lt;/strong&gt;：当单词过长时，人们会截取部分字母组合，例如 &quot;smog&quot;（烟雾）来自 &quot;smoke&quot; 和 &quot;fog&quot;，&quot;brunch&quot;（早午餐）融合 &quot;breakfast&quot; 与 &quot;lunch&quot;。科技领域的 &quot;telecast&quot;（电视广播）由 &quot;television&quot; 和 &quot;broadcast&quot; 混合而成，展现了语言的创新性。&lt;/p&gt;
&lt;h3&gt;三、转化法：一词多义的变形记&lt;/h3&gt;
&lt;p&gt;转化法允许单词在词形不变的情况下转换词性，赋予语言极大的灵活性。例如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;名词→动词&lt;/strong&gt;：&quot;book&quot;（书）→&quot;book a flight&quot;（预订航班），&quot;hand&quot;（手）→&quot;hand me the pen&quot;（递给我笔）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;形容词→动词&lt;/strong&gt;：&quot;better&quot;（更好的）→&quot;better our lives&quot;（改善生活），&quot;slow&quot;（慢的）→&quot;slow down&quot;（减速）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动词→名词&lt;/strong&gt;：&quot;swim&quot;（游泳）→&quot;have a swim&quot;（游泳），&quot;laugh&quot;（笑）→&quot;burst into laughter&quot;（大笑）。&lt;/p&gt;
&lt;h3&gt;四、缩写法：语言的瘦身术&lt;/h3&gt;
&lt;p&gt;缩写法通过缩短单词或取首字母创造简洁表达，常见于日常交流和专业领域：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;截短词&lt;/strong&gt;：&quot;ad&quot;（广告）来自 &quot;advertisement&quot;，&quot;phone&quot;（电话）截取自 &quot;telephone&quot;，&quot;flu&quot;（流感）省略首尾字母。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首字母缩略词&lt;/strong&gt;：&quot;NASA&quot;（美国宇航局）、&quot;VIP&quot;（贵宾）、&quot;TOEFL&quot;（托福考试）等，读音可逐个字母或作为单词（如 &quot;NASA&quot; 读作 /&apos;næsə/）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;特殊缩写&lt;/strong&gt;：&quot;AIDS&quot;（艾滋病）由 &quot;Acquired Immune Deficiency Syndrome&quot; 缩写而来，&quot;radar&quot;（雷达）则是 &quot;Radio Detection and Ranging&quot; 的首字母组合。&lt;/p&gt;
&lt;h3&gt;五、逆成法：反向创造的艺术&lt;/h3&gt;
&lt;p&gt;逆成法通过删除误认为词缀的部分创造新词，常见于动词生成。例如：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;名词→动词&lt;/strong&gt;：&quot;editor&quot;（编辑）去掉 &quot;-or&quot; 变成 &quot;edit&quot;（编辑），&quot;donation&quot;（捐赠）去掉 &quot;-ation&quot; 成为 &quot;donate&quot;（捐赠）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;形容词→动词&lt;/strong&gt;：&quot;lazy&quot;（懒惰的）去掉 &quot;-y&quot; 变为 &quot;laze&quot;（偷懒），&quot;greedy&quot;（贪婪的）去掉 &quot;-y&quot; 成为 &quot;greed&quot;（贪婪）。&lt;/p&gt;
&lt;h3&gt;六、混合法：跨词融合的新物种&lt;/h3&gt;
&lt;p&gt;混合法结合两个单词的部分字母，创造兼具两者含义的新词：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;首尾拼接&lt;/strong&gt;：&quot;motel&quot;（汽车旅馆）=motor + hotel，&quot;Chunnel&quot;（英法海底隧道）=channel + tunnel。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;保留部分词形&lt;/strong&gt;：&quot;paratroops&quot;（空降部队）=parachute + troops，&quot;docudrama&quot;（纪录片）=document + drama。&lt;/p&gt;
&lt;h3&gt;学习构词法的实用技巧&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;词根词缀拆解&lt;/strong&gt;：遇到生词时，尝试分解为前缀 + 词根 + 后缀。例如 &quot;invisible&quot;=in-（否定）+vis（看）+ -ible（可... 的），意为 &quot;不可见的&quot;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;建立词汇网络&lt;/strong&gt;：以词根为中心，扩展相关词汇。如 &quot;aud&quot;（听）可衍生出 &quot;audible&quot;（可听见的）、&quot;audience&quot;（听众）、&quot;audio&quot;（音频）等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意例外与变体&lt;/strong&gt;：并非所有派生词都遵循规则，例如 &quot;effible&quot;（可描述的）实际不存在，只有其否定形式 &quot;ineffible&quot;（不可描述的）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;结合语境记忆&lt;/strong&gt;：通过阅读和听力积累合成词与转化词，如 &quot;Google&quot; 作为动词（搜索）在 &quot;I Google the answer&quot; 中的用法。&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- 英语构词法是词汇学习的加速器，掌握它不仅能让背单词事半功倍，更能提升对语言的敏感度。无论是通过派生法解析复杂词汇，还是用合成法创造新表达，构词法都揭示了语言的创造性与逻辑性。下次遇到陌生单词时，不妨尝试拆解它的 &quot;基因&quot;，你会发现词汇的世界远比想象中更有趣！ --&amp;gt;&lt;/p&gt;
&lt;p&gt;（本文参考资料：&lt;a href=&quot;https://mp.weixin.qq.com/s/Vj-1SIebCe0RWswom2o2sg&quot;&gt;英语构词法详解&lt;/a&gt;及多平台权威构词法研究成果）&lt;/p&gt;
</content:encoded></item><item><title>英语语法</title><link>https://newpower.pro/posts/notebook/english/%E8%AF%AD%E6%B3%95%E4%BD%93%E7%B3%BB/</link><guid isPermaLink="true">https://newpower.pro/posts/notebook/english/%E8%AF%AD%E6%B3%95%E4%BD%93%E7%B3%BB/</guid><pubDate>Tue, 06 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;一、语法体系基石：从字母到词性&lt;/h2&gt;
&lt;h3&gt;（一）26 个英文字母 —— 语言的最小单位&lt;/h3&gt;
&lt;p&gt;英语由 26 个字母构成，分为元音字母（Aa、Ee、Ii、Oo、Uu）和辅音字母（其余 21 个）。正确掌握字母的发音和书写，是拼写单词、学习音标和发音规则的基础。&lt;/p&gt;
&lt;h3&gt;（二）10 种单词词性 —— 句子的 “建筑材料”&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;词性&lt;/th&gt;
&lt;th&gt;缩写&lt;/th&gt;
&lt;th&gt;定义&lt;/th&gt;
&lt;th&gt;例词&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;名词&lt;/td&gt;
&lt;td&gt;n.&lt;/td&gt;
&lt;td&gt;表示人或事物的总称&lt;/td&gt;
&lt;td&gt;apple（苹果）、pen（笔）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;动词&lt;/td&gt;
&lt;td&gt;v.&lt;/td&gt;
&lt;td&gt;表示动作或状态&lt;/td&gt;
&lt;td&gt;smile（微笑）、finish（完成）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;形容词&lt;/td&gt;
&lt;td&gt;adj.&lt;/td&gt;
&lt;td&gt;修饰名词，描述特质&lt;/td&gt;
&lt;td&gt;good（好的）、short（短的）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;副词&lt;/td&gt;
&lt;td&gt;adv.&lt;/td&gt;
&lt;td&gt;修饰动词、形容词或其他副词&lt;/td&gt;
&lt;td&gt;now（现在）、truly（真正地）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;代词&lt;/td&gt;
&lt;td&gt;pron.&lt;/td&gt;
&lt;td&gt;代替名词、形容词或数词&lt;/td&gt;
&lt;td&gt;he（他）、this（这个）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数词&lt;/td&gt;
&lt;td&gt;num.&lt;/td&gt;
&lt;td&gt;表示数量或顺序&lt;/td&gt;
&lt;td&gt;one（一）、first（第一）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;介词&lt;/td&gt;
&lt;td&gt;prep.&lt;/td&gt;
&lt;td&gt;用在名 / 代词前，说明关系&lt;/td&gt;
&lt;td&gt;in（在…… 里）、on（在…… 上）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;冠词&lt;/td&gt;
&lt;td&gt;art.&lt;/td&gt;
&lt;td&gt;用在名词前，限定范围&lt;/td&gt;
&lt;td&gt;a/an（泛指）、the（特指）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;连词&lt;/td&gt;
&lt;td&gt;conj.&lt;/td&gt;
&lt;td&gt;连接短语或句子&lt;/td&gt;
&lt;td&gt;and（和）、but（但是）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;感叹词&lt;/td&gt;
&lt;td&gt;int.&lt;/td&gt;
&lt;td&gt;表达情感或语气&lt;/td&gt;
&lt;td&gt;oh（哦）、well（嗯）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;二、语法核心：从词到句的逻辑纽带&lt;/h2&gt;
&lt;h3&gt;（一）20 个疑问代词 —— 精准提问的关键&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;疑问词&lt;/th&gt;
&lt;th&gt;提问对象&lt;/th&gt;
&lt;th&gt;例句&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;who&lt;/td&gt;
&lt;td&gt;人（主格）&lt;/td&gt;
&lt;td&gt;Who is standing there?（谁站在那里？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;whom&lt;/td&gt;
&lt;td&gt;人（宾格）&lt;/td&gt;
&lt;td&gt;Whom did you meet?（你遇见了谁？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;what&lt;/td&gt;
&lt;td&gt;事物&lt;/td&gt;
&lt;td&gt;What do you want?（你想要什么？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;why&lt;/td&gt;
&lt;td&gt;原因&lt;/td&gt;
&lt;td&gt;Why are you late?（你为什么迟到？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;where&lt;/td&gt;
&lt;td&gt;地点&lt;/td&gt;
&lt;td&gt;Where is the library?（图书馆在哪里？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;which&lt;/td&gt;
&lt;td&gt;特定范围的人 / 物&lt;/td&gt;
&lt;td&gt;Which book do you like?（你喜欢哪本书？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;when&lt;/td&gt;
&lt;td&gt;时间&lt;/td&gt;
&lt;td&gt;When will you leave?（你什么时候离开？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;how&lt;/td&gt;
&lt;td&gt;方式 / 程度&lt;/td&gt;
&lt;td&gt;How do you go to school?（你怎么去上学？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;whose&lt;/td&gt;
&lt;td&gt;所属关系&lt;/td&gt;
&lt;td&gt;Whose pen is this?（这是谁的笔？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;how old&lt;/td&gt;
&lt;td&gt;年龄&lt;/td&gt;
&lt;td&gt;How old is your sister?（你妹妹多大了？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;what color&lt;/td&gt;
&lt;td&gt;颜色&lt;/td&gt;
&lt;td&gt;What color is your car?（你的车是什么颜色？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;how tall&lt;/td&gt;
&lt;td&gt;高度&lt;/td&gt;
&lt;td&gt;How tall is the tree?（这棵树有多高？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;how big&lt;/td&gt;
&lt;td&gt;大小&lt;/td&gt;
&lt;td&gt;How big is your room?（你的房间有多大？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;how far&lt;/td&gt;
&lt;td&gt;距离&lt;/td&gt;
&lt;td&gt;How far is the school?（学校有多远？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;how many&lt;/td&gt;
&lt;td&gt;可数名词数量&lt;/td&gt;
&lt;td&gt;How many books are there?（有多少本书？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;how much&lt;/td&gt;
&lt;td&gt;不可数名词数量 / 价格&lt;/td&gt;
&lt;td&gt;How much milk do you need?（你需要多少牛奶？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;how often&lt;/td&gt;
&lt;td&gt;频率&lt;/td&gt;
&lt;td&gt;How often do you exercise?（你多久锻炼一次？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;what time&lt;/td&gt;
&lt;td&gt;具体时间&lt;/td&gt;
&lt;td&gt;What time is it?（几点了？）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;how long&lt;/td&gt;
&lt;td&gt;时长 / 长度&lt;/td&gt;
&lt;td&gt;How long does it take?（需要多长时间？）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;（二）8 组人称代词 —— 明确指代关系&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;人称&lt;/th&gt;
&lt;th&gt;主格&lt;/th&gt;
&lt;th&gt;宾格&lt;/th&gt;
&lt;th&gt;形容词性物主代词&lt;/th&gt;
&lt;th&gt;名词性物主代词&lt;/th&gt;
&lt;th&gt;反身代词&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;第一人称单数&lt;/td&gt;
&lt;td&gt;I&lt;/td&gt;
&lt;td&gt;me&lt;/td&gt;
&lt;td&gt;my&lt;/td&gt;
&lt;td&gt;mine&lt;/td&gt;
&lt;td&gt;myself&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第一人称复数&lt;/td&gt;
&lt;td&gt;we&lt;/td&gt;
&lt;td&gt;us&lt;/td&gt;
&lt;td&gt;our&lt;/td&gt;
&lt;td&gt;ours&lt;/td&gt;
&lt;td&gt;ourselves&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第二人称单 / 复数&lt;/td&gt;
&lt;td&gt;you&lt;/td&gt;
&lt;td&gt;you&lt;/td&gt;
&lt;td&gt;your&lt;/td&gt;
&lt;td&gt;yours&lt;/td&gt;
&lt;td&gt;yourself/yourselves&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第三人称单数（男）&lt;/td&gt;
&lt;td&gt;he&lt;/td&gt;
&lt;td&gt;him&lt;/td&gt;
&lt;td&gt;his&lt;/td&gt;
&lt;td&gt;his&lt;/td&gt;
&lt;td&gt;himself&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第三人称单数（女）&lt;/td&gt;
&lt;td&gt;she&lt;/td&gt;
&lt;td&gt;her&lt;/td&gt;
&lt;td&gt;her&lt;/td&gt;
&lt;td&gt;hers&lt;/td&gt;
&lt;td&gt;herself&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第三人称单数（物）&lt;/td&gt;
&lt;td&gt;it&lt;/td&gt;
&lt;td&gt;it&lt;/td&gt;
&lt;td&gt;its&lt;/td&gt;
&lt;td&gt;its&lt;/td&gt;
&lt;td&gt;itself&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;第三人称复数&lt;/td&gt;
&lt;td&gt;they&lt;/td&gt;
&lt;td&gt;them&lt;/td&gt;
&lt;td&gt;their&lt;/td&gt;
&lt;td&gt;theirs&lt;/td&gt;
&lt;td&gt;themselves&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;三、时态 —— 动词的 “时间魔法”&lt;/h2&gt;
&lt;p&gt;英语共有 16 种时态，按 “时间轴”（现在、过去、将来、过去将来）和 “状态”（一般、进行、完成、完成进行）分为四大类：&lt;/p&gt;
&lt;h3&gt;（一）现在时态&lt;/h3&gt;
&lt;p&gt;一般现在时：主语 + 动词原形 / 第三人称单数（标志词：always, often, every day）例：She studies English every day.（她每天学英语。）&lt;/p&gt;
&lt;p&gt;现在进行时：主语 + am/is/are + 动词 - ing（标志词：now, look, listen）例：We are watching TV now.（我们正在看电视。）&lt;/p&gt;
&lt;p&gt;现在完成时：主语 + have/has + 过去分词（标志词：already, yet, ever）例：I have visited Beijing twice.（我去过北京两次。）&lt;/p&gt;
&lt;p&gt;现在完成进行时：主语 + have/has been + 动词 - ing（强调持续到现在的动作）例：She has been waiting for an hour.（她等了一个小时了。）&lt;/p&gt;
&lt;h3&gt;（二）过去时态&lt;/h3&gt;
&lt;p&gt;一般过去时：主语 + 动词过去式（标志词：yesterday, ago, last year）例：He went to the park yesterday.（他昨天去了公园。）&lt;/p&gt;
&lt;p&gt;过去进行时：主语 + was/were + 动词 - ing（标志词：at that time, when/while 引导的从句）例：They were playing basketball when it rained.（下雨时他们正在打篮球。）&lt;/p&gt;
&lt;p&gt;过去完成时：主语 + had + 过去分词（标志词：by + 过去时间）例：She had left before I arrived.（我到之前她已经走了。）&lt;/p&gt;
&lt;p&gt;过去完成进行时：主语 + had been + 动词 - ing（强调过去持续到过去某时的动作）例：He had been working here for 10 years before he retired.（退休前他在这里工作了 10 年。）&lt;/p&gt;
&lt;h3&gt;（三）将来时态&lt;/h3&gt;
&lt;p&gt;一般将来时：主语 + will/shall + 动词原形（标志词：tomorrow, next week）例：We will visit the museum tomorrow.（我们明天要去参观博物馆。）&lt;/p&gt;
&lt;p&gt;将来进行时：主语 + will be + 动词 - ing（强调将来某时正在进行的动作）例：She will be studying at 8 o&apos;clock tonight.（今晚 8 点她会在学习。）&lt;/p&gt;
&lt;p&gt;将来完成时：主语 + will have + 过去分词（标志词：by + 将来时间）例：By next year, I will have finished the project.（到明年，我将完成这个项目。）&lt;/p&gt;
&lt;p&gt;将来完成进行时：主语 + will have been + 动词 - ing（强调将来持续到某时的动作）例：They will have been living here for 5 years by next month.（到下个月，他们在这里住了 5 年了。）&lt;/p&gt;
&lt;h3&gt;（四）过去将来时态（以过去某时间为基准的 “将来”）&lt;/h3&gt;
&lt;p&gt;过去将来时：主语 + would + 动词原形（标志词：常用于宾语从句）例：He said he would come back soon.（他说他很快会回来。）&lt;/p&gt;
&lt;p&gt;过去将来进行时：主语 + would be + 动词 - ing例：She told me she would be waiting for me there.（她告诉我她会在那里等我。）&lt;/p&gt;
&lt;p&gt;过去将来完成时：主语 + would have + 过去分词例：He thought he would have finished the work by then.（他以为到那时他已经完成工作了。）&lt;/p&gt;
&lt;p&gt;过去将来完成进行时：主语 + would have been + 动词 - ing例：They knew they would have been studying for 3 hours by 9 o&apos;clock.（他们知道到 9 点他们会已经学习了 3 个小时。）&lt;/p&gt;
&lt;h2&gt;四、句子结构 —— 语法的 “骨架”&lt;/h2&gt;
&lt;h3&gt;（一）5 种简单句基本结构&lt;/h3&gt;
&lt;p&gt;主语 + 谓语（S+V）例：She laughs.（她笑了。）&lt;/p&gt;
&lt;p&gt;主语 + 谓语 + 宾语（S+V+O）例：I love English.（我爱英语。）&lt;/p&gt;
&lt;p&gt;主语 + 系动词 + 表语（S+Link.V+P）例：The cake tastes delicious.（蛋糕尝起来很美味。）&lt;/p&gt;
&lt;p&gt;主语 + 谓语 + 间接宾语 + 直接宾语（S+V+IO+DO）例：He gave me a book.（他给了我一本书。）&lt;/p&gt;
&lt;p&gt;主语 + 谓语 + 宾语 + 宾语补足语（S+V+O+C）例：We made him our monitor.（我们选他当班长。）&lt;/p&gt;
&lt;h3&gt;（二）3 大从句体系&lt;/h3&gt;
&lt;p&gt;名词性从句（包括主语从句、宾语从句、表语从句、同位语从句）例：What he said is true.（他说的是真的。）（主语从句）&lt;/p&gt;
&lt;p&gt;形容词性从句（定语从句）例：The book that I bought yesterday is interesting.（我昨天买的书很有趣。）&lt;/p&gt;
&lt;p&gt;副词性从句（状语从句，包括时间、地点、原因、条件、让步等）例：I will call you when I arrive.（我到了就给你打电话。）（时间状语从句）&lt;/p&gt;
&lt;h2&gt;五、语法细节：缩略词与时态标志词&lt;/h2&gt;
&lt;h3&gt;（一）常用缩略词 —— 口语与写作的 “简化工具”&lt;/h3&gt;
&lt;p&gt;主语 + be 动词：I&apos;m=I am, he&apos;s=he is, they&apos;re=they are&lt;/p&gt;
&lt;p&gt;否定形式：isn&apos;t=is not, aren&apos;t=are not, can&apos;t=cannot&lt;/p&gt;
&lt;p&gt;将来时：I&apos;ll=I will, we&apos;ll=we will, won&apos;t=will not&lt;/p&gt;
&lt;p&gt;其他：what&apos;s=what is, that&apos;s=that is, here&apos;s=here is&lt;/p&gt;
&lt;h3&gt;（二）时态标志词 —— 快速判断时态的 “信号灯”&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;时态&lt;/th&gt;
&lt;th&gt;标志词&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;一般现在时&lt;/td&gt;
&lt;td&gt;always, often, usually, every day&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;一般过去时&lt;/td&gt;
&lt;td&gt;yesterday, ago, last week, in 2020&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;一般将来时&lt;/td&gt;
&lt;td&gt;tomorrow, next month, in the future&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;现在进行时&lt;/td&gt;
&lt;td&gt;now, look, listen, at present&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;过去进行时&lt;/td&gt;
&lt;td&gt;at that time, when/while 引导的从句&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;现在完成时&lt;/td&gt;
&lt;td&gt;already, yet, ever, never, since, for&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;六、句子成分解析：精准拆分句子&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;主语&lt;/strong&gt;：动作的发出者（例：She made her brother sad. 中 “She” 是主语）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;宾语&lt;/strong&gt;：动作的承受者（例：I love apples. 中 “apples” 是宾语）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;表语&lt;/strong&gt;：说明主语的状态或特征（例：He is a teacher. 中 “a teacher” 是表语）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;定语&lt;/strong&gt;：修饰名词的成分（例：The red car is mine. 中 “red” 是定语）&lt;/p&gt;
&lt;h2&gt;结语：系统化学习，让语法不再难懂&lt;/h2&gt;
&lt;p&gt;英语语法体系看似复杂，实则是由一个个 “模块” 组成的逻辑系统。从字母到词性，从时态到句子结构，每一部分都是环环相扣的。对于零基础学习者来说，通过 “分模块整理 + 例句理解 + 刻意练习”，就能逐步搭建起完整的语法框架。记住，语法不是死记硬背的规则，而是帮助我们理解和运用英语的工具。&lt;/p&gt;
</content:encoded></item><item><title>研-计划</title><link>https://newpower.pro/posts/notebook/%E4%B8%AD%E5%B1%B1%E5%A4%A7%E5%AD%A6-%E7%A0%94-%E8%AE%A1%E5%88%92/</link><guid isPermaLink="true">https://newpower.pro/posts/notebook/%E4%B8%AD%E5%B1%B1%E5%A4%A7%E5%AD%A6-%E7%A0%94-%E8%AE%A1%E5%88%92/</guid><pubDate>Thu, 01 May 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;1. 基础阶段（2025 年 5 月 - 2026 年 12 月）&lt;/h2&gt;
&lt;h3&gt;目标：系统学习各科基础知识，构建知识框架&lt;/h3&gt;
&lt;h3&gt;数学（数一）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;教材：《高等数学》（同济版）、《线性代数》（同济版）、《概率论与数理统计》（浙大版）。&lt;/li&gt;
&lt;li&gt;网课：张宇基础班（高数）、李永乐线代强化班、王式安概率论基础班。&lt;/li&gt;
&lt;li&gt;习题：《660 题》《基础过关 1000 题》，每周完成 2 个章节。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;英语（一）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;词汇：每日背诵 50 个考研高频词（推荐《红宝书》）。&lt;/li&gt;
&lt;li&gt;语法：学习长难句分析（推荐田静《句句真研》）。&lt;/li&gt;
&lt;li&gt;阅读：精析 2005-2010 年真题阅读，每篇翻译并总结错题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;专业课（408）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;教材：《数据结构》（严蔚敏）、《计算机组成原理》（唐朔飞）、《操作系统》（汤小丹）、《计算机网络》（谢希仁）。&lt;/li&gt;
&lt;li&gt;网课：王道考研基础班，配套《王道考研复习指导书》。&lt;/li&gt;
&lt;li&gt;练习：完成教材课后习题，整理思维导图。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2. 强化阶段（2027 年 1 月 - 2027 年 6 月）&lt;/h2&gt;
&lt;h3&gt;目标：深化重点难点，提高解题速度&lt;/h3&gt;
&lt;h3&gt;数学&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;习题：《张宇 18 讲》《李林 880 题》，重点突破中高难度题型。&lt;/li&gt;
&lt;li&gt;真题：限时完成 2000-2015 年真题，每周 2 套，分析错题。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;英语&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;阅读：精析 2011-2020 年真题，总结阅读技巧（如定位法、排除法）。&lt;/li&gt;
&lt;li&gt;写作：背诵 10 篇大作文模板，每周练习 1 篇。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;专业课&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;真题：完成 2009-2018 年 408 真题，总结高频考点（如数据结构中的算法设计、计组中的流水线计算）。&lt;/li&gt;
&lt;li&gt;模拟题：做《王道模拟 8 套卷》，训练答题时间分配。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3. 冲刺阶段（2027 年 7 月 - 2027 年 12 月）&lt;/h2&gt;
&lt;h3&gt;目标：模拟实战，查漏补缺&lt;/h3&gt;
&lt;h3&gt;数学&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;真题：二刷 2016-2022 年真题，重点关注近 5 年新题型。&lt;/li&gt;
&lt;li&gt;模拟题：做《李林 6+4 套卷》《合工大超越卷》，保持题感。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;英语&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;模考：每周全真模拟 1 套真题（含作文），严格限时 3 小时。&lt;/li&gt;
&lt;li&gt;翻译：练习 2010-2020 年真题翻译，总结翻译技巧。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;专业课&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;真题：三刷 408 真题，重点突破薄弱环节（如操作系统中的进程调度、计算机网络中的 TCP 协议）。&lt;/li&gt;
&lt;li&gt;复试准备：提前学习离散数学（推荐《离散数学及其应用》）和 C 语言（推荐《C Primer Plus》），为复试笔试做准备。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;政治&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;教材：《肖秀荣精讲精练》《1000 题》。&lt;/li&gt;
&lt;li&gt;网课：徐涛强化班（马原、毛中特）。&lt;/li&gt;
&lt;li&gt;冲刺：11 月开始背诵《肖四》《肖八》，关注时政热点。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;时间管理&lt;/h2&gt;
&lt;h3&gt;每日规划&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;数学：3 小时（1.5 小时网课 + 1.5 小时习题）。&lt;/li&gt;
&lt;li&gt;英语：2 小时（1 小时单词 + 1 小时阅读）。&lt;/li&gt;
&lt;li&gt;专业课：3 小时（2 小时网课 + 1 小时习题）。&lt;/li&gt;
&lt;li&gt;政治：1 小时（后期增加至 2 小时）。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;每周总结&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;周日上午复盘本周学习进度，调整下周计划。&lt;/li&gt;
&lt;li&gt;整理错题本，标注易错知识点。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;资源推荐&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;科目&lt;/th&gt;
&lt;th&gt;推荐资料&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;数学&lt;/td&gt;
&lt;td&gt;《张宇考研数学基础 30 讲》《李林考研数学 880 题》《历年真题详解》&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;英语&lt;/td&gt;
&lt;td&gt;《考研英语长难句解密》《考研英语高分写作》《黄皮书真题解析》&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;专业课&lt;/td&gt;
&lt;td&gt;《王道考研复习指导书》《天勤计算机考研高分笔记》《408 真题解析》&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;政治&lt;/td&gt;
&lt;td&gt;《肖秀荣精讲精练》《徐涛冲刺背诵笔记》《肖四肖八》&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</content:encoded></item><item><title>使用 GitHub Actions 构建并部署 Astro 项目</title><link>https://newpower.pro/posts/document/github-actions-astro-build/</link><guid isPermaLink="true">https://newpower.pro/posts/document/github-actions-astro-build/</guid><description>根据指定的工作流文件，自动构建、检查并部署 Astro 项目</description><pubDate>Sat, 28 Dec 2024 13:00:00 GMT</pubDate><content:encoded>&lt;p&gt;本文基于以下工作流进行构建与部署：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;name: Build, Check and Deploy

on:
  # 每次推送到 `main` 分支时触发这个&quot;工作流程&quot;
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  # 允许你在 GitHub 上的 Actions 标签中手动触发此&quot;工作流程&quot;
  workflow_dispatch:

# 只需要读取权限
permissions:
  contents: read

# 避免同时运行多个相同工作流
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # 代码质量检查
  quality:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      
      - name: Setup Biome
        uses: biomejs/setup-biome@f382a98e582959e6aaac8e5f8b17b31749018780 # v2.5.0
        with:
          version: latest

      - name: Format code with Biome
        run: biome format --write ./src
        continue-on-error: true

      - name: Run Biome check
        run: biome ci ./src --reporter=github
        continue-on-error: true # 添加这一行使格式检查失败不会阻止工作流

  # Astro 类型检查 - 多 Node.js 版本矩阵测试
  check:
    strategy:
      matrix:
        node: [ 22, 23 ]
      # 即使某个版本测试失败，也继续测试其他版本
      fail-fast: false
    runs-on: ubuntu-latest
    needs: quality
    name: Astro Check for Node.js ${{ matrix.node }}
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      
      - name: Setup Node.js
        uses: actions/setup-node@cdca7365b2dadb8aad0a33bc7601856ffabcc48e # v4.3.0
        with:
          node-version: ${{ matrix.node }}
      
      - name: Setup pnpm
        uses: pnpm/action-setup@a7487c7e89a18df4991f7f222e4898a00d66ddda # v4.1.0
        with:
          run_install: false
      
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
      
      - name: Run Astro Check
        run: pnpm astro check

  # 构建站点 - 多 Node.js 版本矩阵测试
  build:
    strategy:
      matrix:
        node: [ 22, 23 ]
      fail-fast: false
    runs-on: ubuntu-latest
    needs: check
    name: Astro Build for Node.js ${{ matrix.node }}
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      
      - name: Setup Node.js
        uses: actions/setup-node@cdca7365b2dadb8aad0a33bc7601856ffabcc48e # v4.3.0
        with:
          node-version: ${{ matrix.node }}
      
      - name: Setup pnpm
        uses: pnpm/action-setup@a7487c7e89a18df4991f7f222e4898a00d66ddda # v4.1.0
        with:
          run_install: false
      
      - name: Install dependencies
        run: pnpm install --frozen-lockfile
      
      - name: Build site
        run: pnpm astro build
      
      # 将构建产物上传为 artifact，以便部署任务使用
      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: dist-node-${{ matrix.node }}
          path: dist
          retention-days: 1

  # 部署到外部仓库 - 仅使用 Node.js 22 的构建结果
  deploy:
    if: github.ref == &apos;refs/heads/main&apos; &amp;amp;&amp;amp; github.event_name != &apos;pull_request&apos;
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4.2.2
      
      # 下载 Node.js 22 版本的构建产物
      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: dist-node-22
          path: dist
      
      - name: Deploy to Your GitHub Pages
        uses: JamesIves/github-pages-deploy-action@v4
        with:
          token: ${{ secrets.DEPLOY_KEY }}  # 需要在 GitHub 仓库的 Secrets 中设置一个名为 DEPLOY_KEY 的密钥
          repository-name: your-username/your-repo-name # 替换为你的 GitHub 用户名和仓库名
          branch: main
          folder: dist
          commit-message: &quot;⭐Site updated: ${{ github.event.head_commit.timestamp }} ${{ github.event.head_commit.message }}&quot;
          # single-commit: false
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;工作流说明&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;quality: 使用 Biome 对代码进行检查与格式化&lt;/li&gt;
&lt;li&gt;check: 基于多节点版本进行 Astro 类型检查&lt;/li&gt;
&lt;li&gt;build: 基于多节点版本生成产物并打包为 artifact&lt;/li&gt;
&lt;li&gt;deploy: 从 artifact 下载构建结果，再部署至目标仓库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过以上步骤，可在推送到指定分支后自动完成检查、构建和部署的流程。&lt;/p&gt;
</content:encoded></item><item><title>精选软件</title><link>https://newpower.pro/posts/favorite/%E7%B2%BE%E9%80%89%E8%BD%AF%E4%BB%B6/</link><guid isPermaLink="true">https://newpower.pro/posts/favorite/%E7%B2%BE%E9%80%89%E8%BD%AF%E4%BB%B6/</guid><description>个人收藏夹</description><pubDate>Wed, 10 Jan 2024 10:31:35 GMT</pubDate><content:encoded>&lt;h2&gt;编辑器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://code.visualstudio.com/&quot;&gt;VS Code&lt;/a&gt; 最好用的编程软件&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.dcloud.io/hbuilderx.html&quot;&gt;HBuilderX&lt;/a&gt; 国内优秀编辑器&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://developers.weixin.qq.com/miniprogram/dev/devtools/download.html&quot;&gt;微信开发者工具&lt;/a&gt; 微信小程序开发首选&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://visualstudio.microsoft.com/zh-hans/downloads/&quot;&gt;Visual Studio&lt;/a&gt; 地表最强编辑器&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jetbrains.com/zh-cn/idea/download/?section=windows&quot;&gt;IntelliJ IDEA&lt;/a&gt; 领先的 Java 和 Kotlin IDE&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;开发工具&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://nodejs.org/en/&quot;&gt;Node.js&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://git-scm.com/&quot;&gt;Git&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;通讯&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://im.qq.com/index/&quot;&gt;QQ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://weixin.qq.com/&quot;&gt;微信&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;浏览器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.google.cn/intl/zh-CN/chrome/&quot;&gt;Chrome&lt;/a&gt; 谷歌浏览器&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.firefox.com.cn/&quot;&gt;Firefox&lt;/a&gt; 火狐浏览器&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.opera.com/zh-cn/download&quot;&gt;Opera&lt;/a&gt; 欧朋浏览器&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;压缩&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.360totalsecurity.com/zh-cn/360zip/&quot;&gt;360压缩&lt;/a&gt; 国际版，无广&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.7-zip.org/download.html&quot;&gt;7-Zip&lt;/a&gt; 轻量，极致压缩&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.win-rar.com/predownload.html?&amp;amp;L=7&quot;&gt;WinRAR&lt;/a&gt; 老牌压缩软件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;屏幕录制&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ieway.cn/evcapture.html&quot;&gt;EV录屏&lt;/a&gt; 免费无水印&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://obsproject.com/&quot;&gt;OBS Studio&lt;/a&gt; 免费开源，直播-录屏&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.screentogif.com/&quot;&gt;ScreenToGif&lt;/a&gt; 微软出品，GIF录制首选&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;截图贴图&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.snipaste.com/&quot;&gt;Snipaste&lt;/a&gt; 免费无广，轻量极简&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pixpinapp.com/&quot;&gt;PixPin&lt;/a&gt; 可截长图，OCR识别&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;手机投屏&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://gitee.com/Barryda/QtScrcpy/releases&quot;&gt;QtScrcpy&lt;/a&gt; 安卓手机投屏到电脑&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/Genymobile/scrcpy/releases&quot;&gt;scrcpy&lt;/a&gt; 适用于安卓手机&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;虚拟机&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html&quot;&gt;VMware&lt;/a&gt; 支持多种系统运行&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bluestacks.com/tw/index.html&quot;&gt;BlueStacks&lt;/a&gt; 安卓模拟器&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;远程控制&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://sunlogin.oray.com/&quot;&gt;向日葵&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;翻译&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://fanyi.youdao.com/download-Windows#/&quot;&gt;网易有道翻译&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://transmart.qq.com/zh-CN/download&quot;&gt;腾讯交互翻译&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pot-app.com/&quot;&gt;Pot&lt;/a&gt; 跨平台划词翻译和OCR&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;笔记&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://typora.io/&quot;&gt;Typora&lt;/a&gt; 优秀的 Markdown 编辑器&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://notepad-plus-plus.org/downloads/v8.4.7/&quot;&gt;Notepad++&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://note.youdao.com/&quot;&gt;有道云笔记&lt;/a&gt; 云端同步&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;桌面整理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.coodesker.com/&quot;&gt;酷呆桌面&lt;/a&gt; 支持硬件加速，启动很快&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://guanjia.qq.com/product/zmzl/?ADTAG=media.innerenter.gj_product&amp;amp;wd=&amp;amp;eqid=ab60bbea000010a20000000465291abf&quot;&gt;腾讯电脑管家桌面整理&lt;/a&gt; 可下载桌面整理独立版&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;网盘&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://pan.baidu.com/download?_at_=1704863197978#win&quot;&gt;百度网盘&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pan.quark.cn/&quot;&gt;夸克网盘&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;游戏相关&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://store.steampowered.com/about&quot;&gt;Steam&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.epicgames.com/help/zh-CN/?lang=zh-CN&quot;&gt;EPIC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ea.com/ea-app?isLocalized=true&quot;&gt;EA&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ys.mihoyo.com/&quot;&gt;原神&lt;/a&gt; 启动！&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;其他&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.tbtool.cn/#container_23932c22&quot;&gt;图吧工具箱&lt;/a&gt; 硬件检测工具合集&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bypass.cn/&quot;&gt;分流抢票&lt;/a&gt; 高铁、火车抢票软件&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.rocksdanister.com/lively/&quot;&gt;LIVELY WALLPAPER&lt;/a&gt; 动态壁纸&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://dubbingai.io/&quot;&gt;大饼AI&lt;/a&gt; ai变声&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://pan.baidu.com/s/1GvvlU3NYeC2DhKEeNwANjw?pwd=f1jm&quot;&gt;SoftPerfect Network Scanner v8.1.6&lt;/a&gt; 局域网IP扫描工具 便携版&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>Markdown使用教程</title><link>https://newpower.pro/posts/document/markdown%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</link><guid isPermaLink="true">https://newpower.pro/posts/document/markdown%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</guid><pubDate>Mon, 25 Dec 2023 14:27:01 GMT</pubDate><content:encoded>&lt;h2&gt;一、Markdown&lt;/h2&gt;
&lt;h3&gt;简介&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png&quot; alt=&quot;logo&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Markdown&lt;/code&gt; 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- more --&amp;gt;&lt;/p&gt;
&lt;h3&gt;应用&lt;/h3&gt;
&lt;p&gt;当前许多网站都广泛使用 &lt;code&gt;Markdown&lt;/code&gt; 来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、知乎等&lt;/p&gt;
&lt;h3&gt;编辑器&lt;/h3&gt;
&lt;p&gt;推荐使用&lt;code&gt;Typora&lt;/code&gt;，官网：&lt;a href=&quot;https://typora.io/&quot;&gt;https://typora.io/&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;二、徽章&lt;/h2&gt;
&lt;h4&gt;什么是徽章&lt;/h4&gt;
&lt;p&gt;徽章是一种小巧精美的小图标，一般配有相关文字进行辅助说明，可对数据进行监控，链接跳转等，富有表现力。&lt;/p&gt;
&lt;p&gt;常见于&lt;code&gt;github&lt;/code&gt;项目主页，但其不仅出现于 &lt;code&gt;github&lt;/code&gt; 项目主页，凡是能够表现图片的地方都可以出现徽章。&lt;/p&gt;
&lt;h4&gt;徽章的使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在&lt;code&gt;markdown&lt;/code&gt;中使用&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;格式:
[![图片文字说明](图片源地址)](超链接地址)  # 即超链接内部嵌套图片

语法：
[![github](https://img.shields.io/badge/github-xugaoyi-brightgreen.svg)](https://github.com/xugaoyi)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/xugaoyi&quot;&gt;&lt;img src=&quot;https://img.shields.io/badge/github-xugaoyi-brightgreen.svg&quot; alt=&quot;github&quot; /&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;徽章生成网站：&lt;a href=&quot;https://shields.io/&quot;&gt;https://shields.io/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本文档主要介绍markdown，不对徽章做过多介绍，详细介绍请 &lt;a href=&quot;https://segmentfault.com/a/1190000019552597&quot;&gt;戳我&lt;/a&gt; 了解。&lt;/p&gt;
&lt;h2&gt;三、设置目录&lt;/h2&gt;
&lt;p&gt;设置之后会根据分级标题来自动生成目录。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[TOC]
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注：github暂未支持。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;在github生成TOC的方法：&lt;a href=&quot;https://github.com/ekalinin/github-markdown-toc&quot;&gt;https://github.com/ekalinin/github-markdown-toc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;windows系统需要基于golang实现的工具：&lt;a href=&quot;https://github.com/ekalinin/github-markdown-toc.go&quot;&gt;https://github.com/ekalinin/github-markdown-toc.go&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果你有GO语言的编译环境，可以尝试自己编译，如果没有，可以直接下载编译好的二进制文件。&lt;/p&gt;
&lt;p&gt;如windows系统64位 下载：gh-md-toc.windows.amd64.tgz （386 是32位，amd64是64位）&lt;/p&gt;
&lt;p&gt;下载解压后，发现没有后缀名无法识别，实际上这是个exe文件，所以只需要暴力地在后面加上.exe就可以开始愉快使用了。&lt;/p&gt;
&lt;p&gt;使用方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;首先将.md文档复制到gh-md-toc.exe的根目录下&lt;/li&gt;
&lt;li&gt;在该目录下打开系统命令行，输入命令：gh-md-toc.exe README.MD 生成目录&lt;/li&gt;
&lt;li&gt;把生成的目录复制到.md文件即可。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;这是gh-md-toc生成的目录：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%80markdown&quot;&gt;一、Markdown&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%AE%80%E4%BB%8B&quot;&gt;简介&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%BA%94%E7%94%A8&quot;&gt;应用&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%BC%96%E8%BE%91%E5%99%A8&quot;&gt;编辑器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%8C%E5%BE%BD%E7%AB%A0&quot;&gt;二、徽章&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%BD%E7%AB%A0&quot;&gt;什么是徽章&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%BE%BD%E7%AB%A0%E7%9A%84%E4%BD%BF%E7%94%A8&quot;&gt;徽章的使用&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%89%E8%AE%BE%E7%BD%AE%E7%9B%AE%E5%BD%95&quot;&gt;三、设置目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%9B%9B%E6%A0%87%E9%A2%98&quot;&gt;四、标题&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%80%E7%BA%A7%E6%A0%87%E9%A2%98&quot;&gt;一级标题&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%8C%E7%BA%A7%E6%A0%87%E9%A2%98&quot;&gt;二级标题&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%89%E7%BA%A7%E6%A0%87%E9%A2%98&quot;&gt;三级标题&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%9B%9B%E7%BA%A7%E6%A0%87%E9%A2%98&quot;&gt;四级标题&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%94%E7%BA%A7%E6%A0%87%E9%A2%98&quot;&gt;五级标题&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%85%AD%E7%BA%A7%E6%A0%87%E9%A2%98&quot;&gt;六级标题&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%94%E6%96%87%E6%9C%AC&quot;&gt;五、文本&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%AE%B5%E8%90%BD&quot;&gt;段落&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AD%97%E4%BD%93&quot;&gt;字体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%88%A0%E9%99%A4%E7%BA%BF&quot;&gt;删除线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%8B%E5%88%92%E7%BA%BF&quot;&gt;下划线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%96%87%E5%AD%97%E9%AB%98%E4%BA%AE&quot;&gt;文字高亮&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%88%86%E9%9A%94%E7%BA%BF&quot;&gt;分隔线&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%84%9A%E6%B3%A8&quot;&gt;脚注&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%85%AD%E5%88%97%E8%A1%A8&quot;&gt;六、列表&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%97%A0%E5%BA%8F%E5%88%97%E8%A1%A8&quot;&gt;无序列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9C%89%E5%BA%8F%E5%88%97%E8%A1%A8&quot;&gt;有序列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%8A%98%E5%8F%A0%E5%88%97%E8%A1%A8&quot;&gt;折叠列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%B8%A6%E5%A4%8D%E9%80%89%E6%A1%86%E5%88%97%E8%A1%A8&quot;&gt;带复选框列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%88%97%E8%A1%A8%E5%B5%8C%E5%A5%97&quot;&gt;列表嵌套&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B8%83%E5%8C%BA%E5%9D%97%E5%BC%95%E7%94%A8&quot;&gt;七、区块引用&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8C%BA%E5%9D%97%E5%B5%8C%E5%A5%97&quot;&gt;区块嵌套&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8C%BA%E5%9D%97%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%88%97%E8%A1%A8&quot;&gt;区块中使用列表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%88%97%E8%A1%A8%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%8C%BA%E5%9D%97&quot;&gt;列表中使用区块&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%85%AB%E4%BB%A3%E7%A0%81&quot;&gt;八、代码&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BB%A3%E7%A0%81%E5%8C%BA%E5%9D%97&quot;&gt;代码区块&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%B9%9D%E9%93%BE%E6%8E%A5&quot;&gt;九、链接&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8F%98%E9%87%8F%E9%93%BE%E6%8E%A5&quot;&gt;变量链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#github%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%86%85%E9%83%A8%E9%93%BE%E6%8E%A5&quot;&gt;Github中使用内部链接&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%94%9A%E7%82%B9%E9%93%BE%E6%8E%A5&quot;&gt;锚点链接&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8D%81%E5%9B%BE%E7%89%87&quot;&gt;十、图片&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%9B%BE%E7%89%87%E5%AE%BD%E9%AB%98&quot;&gt;图片宽高&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E4%BB%A5%E5%8F%8Agithub%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%9B%BE%E7%89%87&quot;&gt;相对路径以及Github中使用图片&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8D%81%E4%B8%80%E8%A1%A8%E6%A0%BC&quot;&gt;十一、表格&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8D%81%E4%BA%8Cemoji%E8%A1%A8%E6%83%85%E5%8C%85&quot;&gt;十二、Emoji表情包&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%8D%81%E4%B8%89%E5%85%B6%E4%BB%96%E6%8A%80%E5%B7%A7&quot;&gt;十三、其他技巧&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%94%AF%E6%8C%81%E7%9A%84-html-%E5%85%83%E7%B4%A0&quot;&gt;支持的 HTML 元素&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E8%BD%AC%E4%B9%89&quot;&gt;转义&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%95%B0%E5%AD%A6%E5%85%AC%E5%BC%8F&quot;&gt;数学公式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%9B%BE%E8%A1%A8&quot;&gt;图表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%B5%81%E7%A8%8B%E5%9B%BE&quot;&gt;流程图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%97%B6%E5%BA%8F%E5%9B%BE&quot;&gt;时序图&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E7%94%98%E7%89%B9%E5%9B%BE&quot;&gt;甘特图&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;四、标题&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 一级标题
## 二级标题
### 三级标题
#### 四级标题
##### 五级标题
###### 六级标题
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;一级标题&lt;/h1&gt;
&lt;h2&gt;二级标题&lt;/h2&gt;
&lt;h3&gt;三级标题&lt;/h3&gt;
&lt;h4&gt;四级标题&lt;/h4&gt;
&lt;h5&gt;五级标题&lt;/h5&gt;
&lt;h6&gt;六级标题&lt;/h6&gt;
&lt;h2&gt;五、文本&lt;/h2&gt;
&lt;h3&gt;段落&lt;/h3&gt;
&lt;p&gt;Markdown 段落没有特殊的格式，直接编写文字，&lt;strong&gt;需要段落缩进时使用2个Tab&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;字体&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;*斜体文本*
或 _斜体文本_
**粗体文本**
或  __粗体文本__
***粗斜体文本***
或 ___粗斜体文本___
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;斜体文本&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;斜体文本&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;粗体文本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;粗体文本&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;粗斜体文本&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;strong&gt;粗斜体文本&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h3&gt;删除线&lt;/h3&gt;
&lt;p&gt;如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 &lt;strong&gt;~~&lt;/strong&gt; 即可，实例如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;~~BAIDU.COM~~
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;s&gt;BAIDU.COM&lt;/s&gt;&lt;/p&gt;
&lt;h3&gt;下划线&lt;/h3&gt;
&lt;p&gt;下划线可以通过 HTML 的&lt;code&gt;&amp;lt;u&amp;gt;&lt;/code&gt; 标签来实现：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;u&amp;gt;带下划线的文本&amp;lt;/u&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;u&amp;gt;带下划线的文本&amp;lt;/u&amp;gt;&lt;/p&gt;
&lt;h3&gt;文字高亮&lt;/h3&gt;
&lt;p&gt;文字高亮能使行内部分文字高亮，使用一对反引号。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;`html` `css` `javascript`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;html&lt;/code&gt; &lt;code&gt;css&lt;/code&gt; &lt;code&gt;javascript&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;分隔线&lt;/h3&gt;
&lt;p&gt;你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;***

*****

- - -

----------
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h3&gt;脚注&lt;/h3&gt;
&lt;p&gt;脚注是对文本的补充说明。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[^变量]
在文档结尾或其他位置給变量赋值：
[^变量]: 注明框内显示的内容

鼠标移到这里&amp;gt; [^哈喽]
[^哈喽]: 注明框内显示的内容
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注：在部分线上预览未支持&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;鼠标移到这里&amp;gt; &lt;a href=&quot;%E6%B3%A8%E6%98%8E%E6%A1%86%E5%86%85%E6%98%BE%E7%A4%BA%E7%9A%84%E5%86%85%E5%AE%B9&quot;&gt;^哈喽&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;六、列表&lt;/h2&gt;
&lt;h3&gt;无序列表&lt;/h3&gt;
&lt;p&gt;使用星号&lt;code&gt;*&lt;/code&gt;、加号&lt;code&gt;+&lt;/code&gt;或是减号&lt;code&gt;-&lt;/code&gt;作为列表标记：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;* 第一项
* 第二项

+ 第一项
+ 第二项

- 第一项
- 第二项
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;第一项&lt;/li&gt;
&lt;li&gt;第二项&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;有序列表&lt;/h3&gt;
&lt;p&gt;使用数字并加上&lt;code&gt;.&lt;/code&gt; 号来表示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;1. 第一项
2. 第二项
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;第一项&lt;/li&gt;
&lt;li&gt;第二项&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;折叠列表&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;点我打开关闭折叠&amp;lt;/summary&amp;gt;
 折叠内容
 &amp;lt;ul&amp;gt;
     &amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt;
     &amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;
     &amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt;
 &amp;lt;/ul&amp;gt;
&amp;lt;/details&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：&amp;lt;details&amp;gt; 标签内写markdown代码无效，可写html代码，如ul&amp;gt;li、table等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;点我打开关闭折叠&amp;lt;/summary&amp;gt;
折叠内容
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;1&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;2&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;3&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;/details&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;包含table的折叠&amp;lt;/summary&amp;gt;
&amp;lt;table&amp;gt;
&amp;lt;thead&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;th align=&quot;center&quot;&amp;gt;分类&amp;lt;/th&amp;gt;
&amp;lt;th align=&quot;center&quot;&amp;gt;例词&amp;lt;/th&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;/thead&amp;gt;
&amp;lt;tbody&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td align=&quot;center&quot;&amp;gt;人称代词-主格&amp;lt;/td&amp;gt;
&amp;lt;td align=&quot;center&quot;&amp;gt;I我，you你，he他，she她，they他们， we我们&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td align=&quot;center&quot;&amp;gt;人称代词-宾格&amp;lt;/td&amp;gt;
&amp;lt;td align=&quot;center&quot;&amp;gt;me我， you你， him他， her她， them他们， us我们&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td align=&quot;center&quot;&amp;gt;物主代词&amp;lt;/td&amp;gt;
&amp;lt;td align=&quot;center&quot;&amp;gt;my我的， his他的， your你的（your你们的）， their他们的， hers她的&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td align=&quot;center&quot;&amp;gt;指示代词&amp;lt;/td&amp;gt;
&amp;lt;td align=&quot;center&quot;&amp;gt;this这， that那， these这些， those 那些&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td align=&quot;center&quot;&amp;gt;反身代词&amp;lt;/td&amp;gt;
&amp;lt;td align=&quot;center&quot;&amp;gt;myself我自己， himself他自己， themselves他们自己， yourself你(们)自己，herself她自己&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td align=&quot;center&quot;&amp;gt;疑问代词&amp;lt;/td&amp;gt;
&amp;lt;td align=&quot;center&quot;&amp;gt;who谁， what什么， which哪个&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td align=&quot;center&quot;&amp;gt;不定代词&amp;lt;/td&amp;gt;
&amp;lt;td align=&quot;center&quot;&amp;gt;some一些， many许多， both两个、两个都， any许多&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td align=&quot;center&quot;&amp;gt;关系代词&amp;lt;/td&amp;gt;
&amp;lt;td align=&quot;center&quot;&amp;gt;which……的物， who……的人， that……的人或物， who谁， that引导定语从句&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td align=&quot;center&quot;&amp;gt;相互代词&amp;lt;/td&amp;gt;
&amp;lt;td align=&quot;center&quot;&amp;gt;each other 互相， one another互相&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td align=&quot;center&quot;&amp;gt;连接代词&amp;lt;/td&amp;gt;
&amp;lt;td align=&quot;center&quot;&amp;gt;who,whom,whose,what,which,whatever,whichever,whoever,whomever&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td align=&quot;center&quot;&amp;gt;替代词&amp;lt;/td&amp;gt;
&amp;lt;td align=&quot;center&quot;&amp;gt;one（单数），ones（复数）&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;/tbody&amp;gt;
&amp;lt;/table&amp;gt;
&amp;lt;/details&amp;gt;&lt;/p&gt;
&lt;h3&gt;带复选框列表&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;* [x] 第一项
* [ ] 第二项
* [ ] 第三项
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注：在部分线上预览未支持&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;[x] 第一项&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[ ] 第二项&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;[ ] 第三项&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;列表嵌套&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;1. 第一项：
    - 第一项嵌套的第一个元素
    - 第一项嵌套的第二个元素
2. 第二项：
    - 第二项嵌套的第一个元素
       - 第三层嵌套
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;第一项
&lt;ul&gt;
&lt;li&gt;嵌套1&lt;/li&gt;
&lt;li&gt;嵌套2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;第二项
&lt;ul&gt;
&lt;li&gt;嵌套1
&lt;ul&gt;
&lt;li&gt;嵌套2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;七、区块引用&lt;/h2&gt;
&lt;p&gt;区块引用是在段落开头使用 &lt;code&gt;&amp;gt;&lt;/code&gt;符号 ，然后后面紧跟一个&lt;strong&gt;空格&lt;/strong&gt;符号：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; 区块引用
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;区块引用&lt;/p&gt;
&lt;p&gt;Typora中回车键自动延伸区块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;区块嵌套&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; 第一层
&amp;gt; &amp;gt; 第二层
&amp;gt; &amp;gt; &amp;gt; 第三层
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;第一层&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第二层&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;第三层&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;h4&gt;区块中使用列表&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; 区块中使用列表
&amp;gt; 1. 第一项
&amp;gt; 2. 第二项
&amp;gt; * 111
&amp;gt; * 222
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;区块中使用列表&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一项&lt;/li&gt;
&lt;li&gt;第二项
&lt;ul&gt;
&lt;li&gt;111&lt;/li&gt;
&lt;li&gt;222&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h4&gt;列表中使用区块&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;* 第一项
    &amp;gt; 区块
* 第二项
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一项&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;区块&lt;/p&gt;
&lt;p&gt;区块&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二项&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;八、代码&lt;/h2&gt;
&lt;p&gt;如果是段落上的一个代码片段可以用反引号把它包起来（&lt;strong&gt;`&lt;/strong&gt;），示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;`alert()`
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;alert()&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;代码区块&lt;/h3&gt;
&lt;p&gt;用三个反引号 &lt;strong&gt;```&lt;/strong&gt; 包裹一段代码，并指定一种语言（也可以不指定），指定代码语言后会有代码的颜色高亮&lt;/p&gt;
&lt;p&gt;本代码区块为示例说明：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;​```javascript
function test() {
 alert(&apos;test&apos;)
}
​```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;function test() {
 alert(&apos;test&apos;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;九、链接&lt;/h2&gt;
&lt;p&gt;格式：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[链接名称](链接地址)

[链接名称](链接地址,可选的alt)

或

&amp;lt;链接地址&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[百度](http://www.baidu.com,&apos;百度&apos;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;http://www.baidu.com,&apos;%E7%99%BE%E5%BA%A6&apos;&quot;&gt;百度&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;直接显示链接地址：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;http://www.baidu.com&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;http://www.baidu.com&quot;&gt;http://www.baidu.com&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;变量链接&lt;/h3&gt;
&lt;p&gt;链接可以用变量来代替，文档末尾或其他位置附带变量地址：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这个链接用 1 作为网址变量 [Google][1]
这个链接用 baidu 作为网址变量 [Baidu][baidu]

然后在文档的结尾或其他位置给变量赋值（网址）
  [1]: http://www.google.com/
  [baidu]: http://www.baidu.com/
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个链接用 1 作为网址变量 &lt;a href=&quot;http://www.google.com&quot;&gt;Google&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这个链接用 baidu 作为网址变量 &lt;a href=&quot;http://www.baidu.com/&quot;&gt;Baidu&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Github仓库中使用内部链接&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;可使用相对路径（前提是有该路径下的文件）
[test](test.md)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;a href=&quot;./md-img/test.md&quot;&gt;test&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;锚点链接&lt;/h3&gt;
&lt;p&gt;本文件中每一个标题都是一个锚点，和HTML的锚点（&lt;code&gt;#&lt;/code&gt;）类似&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[Markdown](#Markdown)
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注： github对含有标点符号的标题进行锚点时会忽略掉标点符号，
本页中，如果这样写则无法跳转：[链接](#九、链接)
正确写法：[链接](#九链接)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href=&quot;#%E4%B8%80Markdown&quot;&gt;Markdown&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#%E4%B9%9D%E9%93%BE%E6%8E%A5&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#%E6%B5%81%E7%A8%8B%E5%9B%BE&quot;&gt;流程图&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;十、图片&lt;/h2&gt;
&lt;p&gt;和链接的区别是前面多一个感叹号&lt;code&gt;!&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;![图片名](图片链接)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然，你也可以像链接那样对图片地址使用变量:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;这里链接用 img 作为图片地址变量
然后在文档的结尾或其他位置给变量赋值（图片地址）
![RUNOOB][img]
[img]: https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png&quot; alt=&quot;RUNOOB&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;图片宽高&lt;/h3&gt;
&lt;p&gt;如下想设置图片宽高，可以使用 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 标签。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;img src=&quot;https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png&quot; width=&quot;50px&quot; height=&quot;30px&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;img src=&quot;https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png&quot; width=&quot;50px&quot; height=&quot;30px&quot;&amp;gt;&lt;/p&gt;
&lt;h3&gt;相对路径以及Github中使用图片&lt;/h3&gt;
&lt;p&gt;不管是在本地还是在github同一个仓库中，如果图片存在，可以使用&lt;strong&gt;相对路径&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;相对路径图片：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;![头像图片](./md-img/test.jpg)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;github上如果引用其他github仓库中的图片则要注意地址格式：&lt;code&gt;仓库地址/raw/分支名/图片路径&lt;/code&gt; 或 &lt;code&gt;https://raw.githubusercontent.com/用户名/仓库名/分支名/图片路径&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;![其他仓库的图片1](https://github.com/xugaoyi/vue-music/raw/master/src/common/image/default.png)
或
![其他仓库的图片2](https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png)

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://github.com/xugaoyi/vue-music/raw/master/src/common/image/default.png&quot; alt=&quot;其他仓库的图片&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/xugaoyi/image_store/master/blog/md_logo.png&quot; alt=&quot;其他仓库的图片2&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;十一、表格&lt;/h2&gt;
&lt;p&gt;制作表格使用 &lt;code&gt;|&lt;/code&gt;来分隔不同的单元格，使用&lt;code&gt;-&lt;/code&gt;来分隔表头和其他行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;|  表头   | 表头  |
|  ----  | ----  |
| 单元格  | 单元格 |
| 单元格  | 单元格 |
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;表头&lt;/th&gt;
&lt;th&gt;表头&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;单元格&lt;/td&gt;
&lt;td&gt;单元格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;单元格&lt;/td&gt;
&lt;td&gt;单元格&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;对齐方式&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;-:&lt;/strong&gt; 设置内容和标题栏居右对齐&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;:-&lt;/strong&gt; 设置内容和标题栏居左对齐&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;:-:&lt;/strong&gt; 设置内容和标题栏居中对齐&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;| 左对齐 | 右对齐 | 居中对齐 |
| :-----| ----: | :----: |
| 单元格 | 单元格 | 单元格 |
| 单元格 | 单元格 | 单元格 |
&lt;/code&gt;&lt;/pre&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;左对齐&lt;/th&gt;
&lt;th&gt;右对齐&lt;/th&gt;
&lt;th&gt;居中对齐&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;单元格&lt;/td&gt;
&lt;td&gt;单元格&lt;/td&gt;
&lt;td&gt;单元格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;单元格&lt;/td&gt;
&lt;td&gt;单元格&lt;/td&gt;
&lt;td&gt;单元格&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2&gt;十二、Emoji表情包&lt;/h2&gt;
&lt;p&gt;Emoji表情英文名的前后加冒号，Typore上先输入冒号再输入首字母有表情提示&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;:smirk:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;:kiss:
:smile_cat::see_no_evil::horse:
:smirk::blush::smiley::smile: :sunny:&lt;/p&gt;
&lt;p&gt;更多表情名称请查看：&lt;a href=&quot;https://www.webfx.com/tools/emoji-cheat-sheet/&quot;&gt;表情包清单&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;十三、其他技巧&lt;/h2&gt;
&lt;h3&gt;支持的 HTML 元素&lt;/h3&gt;
&lt;p&gt;不在 Markdown 语法涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。&lt;/p&gt;
&lt;p&gt;目前支持的 HTML 元素有：&lt;code&gt;&amp;lt;kbd&amp;gt; &amp;lt;b&amp;gt; &amp;lt;i&amp;gt; &amp;lt;em&amp;gt; &amp;lt;sup&amp;gt; &amp;lt;sub&amp;gt; &amp;lt;br&amp;gt;&lt;/code&gt;等等 ，如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;使用 &amp;lt;kbd&amp;gt;Ctrl&amp;lt;/kbd&amp;gt;+&amp;lt;kbd&amp;gt;Alt&amp;lt;/kbd&amp;gt;+&amp;lt;kbd&amp;gt;Del&amp;lt;/kbd&amp;gt; 重启电脑
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用 &amp;lt;kbd&amp;gt;Ctrl&amp;lt;/kbd&amp;gt;+&amp;lt;kbd&amp;gt;Alt&amp;lt;/kbd&amp;gt;+&amp;lt;kbd&amp;gt;Del&amp;lt;/kbd&amp;gt; 重启电脑&lt;/p&gt;
&lt;p&gt;&amp;lt;b&amp;gt;我是使用b标签的加粗字体&amp;lt;/b&amp;gt;&lt;/p&gt;
&lt;h3&gt;转义&lt;/h3&gt;
&lt;p&gt;Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用反斜杠转义字符：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;**未转义星号显示加粗**
\*\* 转义显示星号 \*\*
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;未转义星号显示加粗&lt;/strong&gt;
** 转义显示星号 **&lt;/p&gt;
&lt;p&gt;Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\   反斜线
`   反引号
*   星号
_   下划线
{}  花括号
[]  方括号
()  小括号
#   井字号
+   加号
-   减号
.   英文句点
!   感叹号
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;p&gt;*** &lt;strong&gt;以下部分在Github或其他在线预览中暂未支持&lt;/strong&gt; ***&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;数学公式&lt;/h3&gt;
&lt;p&gt;当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$$
\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}
\mathbf{i} &amp;amp; \mathbf{j} &amp;amp; \mathbf{k} \\
\frac{\partial X}{\partial u} &amp;amp;  \frac{\partial Y}{\partial u} &amp;amp; 0 \\
\frac{\partial X}{\partial v} &amp;amp;  \frac{\partial Y}{\partial v} &amp;amp; 0 \\
\end{vmatrix}
$$tep1}{\style{visibility:hidden}{(x+1)(x+1)}}
$$
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;$$
\mathbf{V}_1 \times \mathbf{V}_2 =  \begin{vmatrix}
\mathbf{i} &amp;amp; \mathbf{j} &amp;amp; \mathbf{k} \
\frac{\partial X}{\partial u} &amp;amp;  \frac{\partial Y}{\partial u} &amp;amp; 0 \
\frac{\partial X}{\partial v} &amp;amp;  \frac{\partial Y}{\partial v} &amp;amp; 0 \
\end{vmatrix}
$$&lt;/p&gt;
&lt;h3&gt;图表&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;​```chart
,Budget,Income,Expenses,Debt
June,5000,8000,4000,6000
July,3000,1000,4000,3000
Aug,5000,7000,6000,3000
Sep,7000,2000,3000,1000
Oct,6000,5000,4000,2000
Nov,4000,3000,5000,

type: pie
title: Monthly Revenue
x.title: Amount
y.title: Month
y.suffix: $
​```
​```mermaid
sequenceDiagram
A-&amp;gt;&amp;gt;B: 是否已收到消息？
B--&amp;gt;&amp;gt;A: 已收到消息
​```
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注：在Typora中未支持&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;流程图&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;语法：
​```mermaid
graph TD
A[模块A] --&amp;gt;|A1| B(模块B)
B --&amp;gt; C{判断条件C}
C --&amp;gt;|条件C1| D[模块D]
C --&amp;gt;|条件C2| E[模块E]
C --&amp;gt;|条件C3| F[模块F]
​```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;流程图相关文章：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/b421cc723da5&quot;&gt;https://www.jianshu.com/p/b421cc723da5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.imooc.com/article/292708&quot;&gt;http://www.imooc.com/article/292708&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;时序图&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;​```mermaid
sequenceDiagram
A-&amp;gt;&amp;gt;B: 是否已收到消息？
B--&amp;gt;&amp;gt;A: 已收到消息
​```
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;甘特图&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;​```mermaid
gantt
title 甘特图
dateFormat  YYYY-MM-DD
section 项目A
任务1           :a1, 2018-06-06, 30d
任务2     :after a1  , 20d
section 项目B
任务3      :2018-06-12  , 12d
任务4      : 24d
​```
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;​                                            &lt;a href=&quot;#markdown%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B&quot;&gt;回到顶部&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>npm packageJson属性详解</title><link>https://newpower.pro/posts/document/npm-packagejson%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/</link><guid isPermaLink="true">https://newpower.pro/posts/document/npm-packagejson%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/</guid><pubDate>Sat, 08 Apr 2023 17:16:38 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;本文转自&lt;a href=&quot;https://www.cnblogs.com/tzyy/p/5193811.html&quot;&gt;https://www.cnblogs.com/tzyy/p/5193811.html&lt;/a&gt;，作者：TZYY&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;概述&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;package.json&lt;/code&gt;必须是一个严格的json文件，而不仅仅是js里边的一个对象。其中很多属性可以通过&lt;code&gt;npm-config&lt;/code&gt;来生成&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- more --&amp;gt;&lt;/p&gt;
&lt;h2&gt;name&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;package.json&lt;/code&gt;中最重要的属性是&lt;code&gt;name&lt;/code&gt;和&lt;code&gt;version&lt;/code&gt;两个属性，这两个属性是必须要有的，否则模块就无法被安装，这两个属性一起形成了一个npm模块的唯一标识符。模块中内容变更的同时，模块版本也应该一起变化。
&lt;code&gt;name&lt;/code&gt;属性就是你的模块名称，下面是一些命名规则:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;name&lt;/code&gt;必须小于等于214个字节，包括前缀名称在内（如 xxx/xxxmodule）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;name&lt;/code&gt;不能以&quot;_&quot;或&quot;.&quot;开头&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不能含有大写字母&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;name&lt;/code&gt;会成为url的一部分，不能含有url非法字符&lt;/p&gt;
&lt;p&gt;下面是官网文档的一些建议：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不要使用和node核心模块一样的名称&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;name&lt;/code&gt;中不要含有&quot;js&quot;和&quot;node&quot;。 It&apos;s assumed that it&apos;s js, since you&apos;re writing a package.json file, and you can specify the engine using the &quot;engines&quot; field. (See below.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;name&lt;/code&gt;属性会成为模块url、命令行中的一个参数或者一个文件夹名称，任何非url安全的字符在name中都不能使用，也不能以&quot;_&quot;或&quot;.&quot;开头&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;name&lt;/code&gt;属性也许会被写在&lt;code&gt;require()&lt;/code&gt;的参数中，所以最好取个简短而语义化的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建一个模块前可以先到后边的网址查查&lt;code&gt;name&lt;/code&gt;是否已经被占用. &lt;a href=&quot;https://www.npmjs.com/&quot;&gt;https://www.npmjs.com/&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;pre&gt;&lt;code&gt;# 发布一个包的时候，需要检验某个包名是否存在
npm search &amp;lt;ModuleName&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;name&lt;/code&gt;属性可以有一些前缀如 e.g. @myorg/mypackage.在npm-scope(7)的文档中可以看到详细说明&lt;/p&gt;
&lt;h2&gt;version&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;version&lt;/code&gt;必须可以被npm依赖的一个&lt;code&gt;node-semver&lt;/code&gt;模块解析。具体规则见下面的&lt;code&gt;dependencies&lt;/code&gt;模块&lt;/p&gt;
&lt;h2&gt;description&lt;/h2&gt;
&lt;p&gt;一个描述，方便别人了解你的模块作用，搜索的时候也有用。&lt;/p&gt;
&lt;h2&gt;keywords&lt;/h2&gt;
&lt;p&gt;一个字符串数组，方便别人搜索到本模块&lt;/p&gt;
&lt;h2&gt;homepage&lt;/h2&gt;
&lt;p&gt;项目主页url
&lt;strong&gt;注意:&lt;/strong&gt; 这个项目主页url和url属性不同，如果你填写了url属性，npm注册工具会认为你把项目发布到其他地方了，获取模块的时候不会从npm官方仓库获取，而是会重定向到url属性配置的地址。
（原文档中用了 spit(吐)这个单词，作者表示他不是在开玩笑:）&lt;/p&gt;
&lt;h2&gt;bugs&lt;/h2&gt;
&lt;p&gt;填写一个bug提交地址或者一个邮箱，被你的模块坑到的人可以通过这里吐槽，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &quot;url&quot; : &quot;https://github.com/owner/project/issues&quot;,
    &quot;email&quot; : &quot;project@hostname.com&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;url和email可以任意填或不填，如果只填一个，可以直接写成一个字符串而不是对象。如果填写了url，npm bugs命令会使用这个url。&lt;/p&gt;
&lt;h2&gt;license&lt;/h2&gt;
&lt;p&gt;你应该为你的模块制定一个协议，让用户知道他们有何权限来使用你的模块，以及使用该模块有哪些限制。最简单的，例如你用BSD-3-Clause 或 MIT之类的协议，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ &quot;license&quot; : &quot;MIT&quot; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;你可以在&lt;a href=&quot;https://spdx.org/licenses/&quot;&gt;https://spdx.org/licenses/&lt;/a&gt;这个地址查阅协议列表 。&lt;/p&gt;
&lt;h2&gt;和用户相关的属性: author, contributors&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;author&lt;/code&gt;是一个码农， &lt;code&gt;contributors&lt;/code&gt;是一个码农数组。 &lt;code&gt;person&lt;/code&gt;是一个有一些描述属性的对象，如下 like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &quot;name&quot; : &quot;Barney Rubble&quot;,
    &quot;email&quot; : &quot;b@rubble.com&quot;,
    &quot;url&quot; : &quot;http://barnyrubble.tumblr.com/&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也可以按如下格式缩写，npm会帮着转换:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;Barney Rubble b@rubble.com (http://barnyrubble.tumblr.com/)&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;email&lt;/code&gt;和&lt;code&gt;url&lt;/code&gt;属性实际上都是可以省略的。描述用户信息的还有一个&lt;code&gt;maintainers&lt;/code&gt;（维护者）属性。&lt;/p&gt;
&lt;h2&gt;files&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;files&lt;/code&gt;属性的值是一个数组，内容是模块下文件名或者文件夹名，如果是文件夹名，则文件夹下所有的文件也会被包含进来（除非文件被另一些配置排除了）
你也可以在模块根目录下创建一个&lt;code&gt;.npmignore&lt;/code&gt;文件（windows下无法直接创建以&quot;.&quot;开头的文件，使用linux命令行工具创建如git bash），写在这个文件里边的文件即便被写在files属性里边也会被排除在外，这个文件的写法&quot;.gitignore&quot;类似。&lt;/p&gt;
&lt;h2&gt;main&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;main&lt;/code&gt;属性指定了程序的主入口文件。意思是，如果你的模块被命名为foo，用户安装了这个模块并通过require(&quot;foo&quot;)来使用这个模块，那么require返回的内容就是main属性指定的文件中 module.exports指向的对象。
它应该指向模块根目录下的一个文件。对大对数模块而言，这个属性更多的是让模块有一个主入口文件，然而很多模块并不写这个属性。&lt;/p&gt;
&lt;h2&gt;bin&lt;/h2&gt;
&lt;p&gt;很多模块有一个或多个需要配置到PATH路径下的可执行模块，npm让这个工作变得十分简单（实际上npm本身也是通过bin属性安装为一个可执行命令的）
如果要用npm的这个功能，在package.json里边配置一个bin属性。bin属性是一个已命令名称为key，本地文件名称为value的map如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &quot;bin&quot; : { &quot;myapp&quot; : &quot;./cli.js&quot; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;模块安装的时候，若是全局安装，则npm会为bin中配置的文件在bin目录下创建一个软连接（对于windows系统，默认会在C:\Users\username\AppData\Roaming\npm目录下），若是局部安装，则会在项目内的./node_modules/.bin/目录下创建一个软链接。
因此，按上面的例子，当你安装myapp的时候，npm就会为cli.js在/usr/local/bin/myapp路径创建一个软链接。
如果你的模块只有一个可执行文件，并且它的命令名称和模块名称一样，你可以只写一个字符串来代替上面那种配置，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ 
    &quot;name&quot;: &quot;my-program&quot;,
    &quot;version&quot;: &quot;1.2.5&quot;, 
    &quot;bin&quot;: &quot;./path/to/program&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;作用和如下写法相同:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ 
    &quot;name&quot;: &quot;my-program&quot;, 
    &quot;version&quot;: &quot;1.2.5&quot;, 
    &quot;bin&quot; : { 
        &quot;my-program&quot; : &quot;./path/to/program&quot; 
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;man&lt;/h2&gt;
&lt;p&gt;制定一个或通过数组制定一些文件来让linux下的man命令查找文档地址。
如果只有一个文件被指定的话，安装后直接使用man+模块名称，而不管man指定的文件的实际名称。例如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
    &quot;name&quot; : &quot;foo&quot;,
    &quot;version&quot; : &quot;1.2.3&quot;, 
    &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;, 
    &quot;main&quot; : &quot;foo.js&quot;, 
    &quot;man&quot; : &quot;./man/doc.1&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过man foo命令会得到 ./man/doc.1 文件的内容。
如果man文件名称不是以模块名称开头的，安装的时候会给加上模块名称前缀。因此，下面这段配置：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ 
    &quot;name&quot; : &quot;foo&quot;, 
    &quot;version&quot; : &quot;1.2.3&quot;, 
    &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;, 
    &quot;main&quot; : &quot;foo.js&quot;, 
    &quot;man&quot; : [ &quot;./man/foo.1&quot;, &quot;./man/bar.1&quot; ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会创建一些文件来作为man foo和man foo-bar命令的结果。
man文件必须以数字结尾，或者如果被压缩了，以.gz结尾。数字表示文件将被安装到man的哪个部分。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ 
    &quot;name&quot; : &quot;foo&quot;, 
    &quot;version&quot; : &quot;1.2.3&quot;,
    &quot;description&quot; : &quot;A packaged foo fooer for fooing foos&quot;, 
    &quot;main&quot; : &quot;foo.js&quot;, 
    &quot;man&quot; : [ &quot;./man/foo.1&quot;, &quot;./man/foo.2&quot; ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;会创建 man foo 和 man 2 foo 两条命令。&lt;/p&gt;
&lt;h2&gt;directories&lt;/h2&gt;
&lt;p&gt;CommonJs通过directories来制定一些方法来描述模块的结构，看看npm的package.json文件&lt;a href=&quot;https://registry.npmjs.org/npm/latest&quot;&gt;https://registry.npmjs.org/npm/latest&lt;/a&gt; ，可以发现里边有这个字段的内容。
&lt;img src=&quot;http://zoucz.com/blogimgs/2016-02-16/1455624810992.png&quot; alt=&quot;img&quot; /&gt;
目前这个配置没有任何作用，将来可能会整出一些花样来。&lt;/p&gt;
&lt;h3&gt;directories.lib&lt;/h3&gt;
&lt;p&gt;告诉用户模块中lib目录在哪，这个配置目前没有任何作用，但是对使用模块的人来说是一个很有用的信息。&lt;/p&gt;
&lt;h3&gt;directories.bin&lt;/h3&gt;
&lt;p&gt;如果你在这里指定了bin目录，这个配置下面的文件会被加入到bin路径下，如果你已经在package.json中配置了bin目录，那么这里的配置将不起任何作用。&lt;/p&gt;
&lt;h3&gt;directories.man&lt;/h3&gt;
&lt;p&gt;指定一个目录，目录里边都是man文件，这是一种配置man文件的语法糖。&lt;/p&gt;
&lt;h3&gt;directories.doc&lt;/h3&gt;
&lt;p&gt;在这个目录里边放一些markdown文件，可能最终有一天它们会被友好的展现出来（应该是在npm的网站上）&lt;/p&gt;
&lt;h3&gt;directories.example&lt;/h3&gt;
&lt;p&gt;放一些示例脚本，或许某一天会有用 - -！&lt;/p&gt;
&lt;h2&gt;repository&lt;/h2&gt;
&lt;p&gt;指定一个代码存放地址，对想要为你的项目贡献代码的人有帮助。像这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;repository&quot; :
  {
      &quot;type&quot; : &quot;git&quot;,
      &quot;url&quot; : &quot;https://github.com/npm/npm.git&quot;
  }

&quot;repository&quot; :
  { 
      &quot;type&quot; : &quot;svn&quot;, 
      &quot;url&quot; : &quot;https://v8.googlecode.com/svn/trunk/&quot;
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若你的模块放在GitHub, GitHub gist, Bitbucket, or GitLab的仓库里，npm install的时候可以使用缩写标记来完成：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&quot;repository&quot;: &quot;npm/npm&quot;

&quot;repository&quot;: &quot;gist:11081aaa281&quot;

&quot;repository&quot;: &quot;bitbucket:example/repo&quot;

&quot;repository&quot;: &quot;gitlab:another/repo&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;scripts&lt;/h2&gt;
&lt;p&gt;scripts属性是一个对象，里边指定了项目的生命周期个各个环节需要执行的命令。key是生命周期中的事件，value是要执行的命令。
具体的内容有 install start stop 等，详见&lt;a href=&quot;https://docs.npmjs.com/misc/scripts&quot;&gt;https://docs.npmjs.com/misc/scripts&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;config&lt;/h2&gt;
&lt;p&gt;用来设置一些项目不怎么变化的项目配置，例如port等。
用户用的时候可以使用如下用法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;http.createServer(...).listen(process.env.npm_package_config_port)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以通过npm config set foo:port 80来修改config。详见&lt;a href=&quot;https://docs.npmjs.com/misc/config&quot;&gt;https://docs.npmjs.com/misc/config&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ 
    &quot;name&quot; : &quot;foo&quot;, 
    &quot;config&quot; : { &quot;port&quot; : &quot;8080&quot; }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;dependencies&lt;/h2&gt;
&lt;p&gt;dependencies属性是一个对象，配置模块依赖的模块列表，key是模块名称，value是版本范围，版本范围是一个字符，可以被一个或多个空格分割。
dependencies也可以被指定为一个git地址或者一个压缩包地址。
不要把测试工具或transpilers写到dependencies中。 下面是一些写法，详见&lt;a href=&quot;https://docs.npmjs.com/misc/semver&quot;&gt;https://docs.npmjs.com/misc/semver&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;version 精确匹配版本&lt;/li&gt;
&lt;li&gt;&amp;gt;version 必须大于某个版本&lt;/li&gt;
&lt;li&gt;&amp;gt;=version 大于等于&lt;/li&gt;
&lt;li&gt;&amp;lt;version 小于&lt;/li&gt;
&lt;li&gt;&amp;lt;=versionversion 小于&lt;/li&gt;
&lt;li&gt;~version &quot;约等于&quot;，具体规则详见semver文档&lt;/li&gt;
&lt;li&gt;^version &quot;兼容版本&quot;具体规则详见semver文档&lt;/li&gt;
&lt;li&gt;1.2.x 仅一点二点几的版本&lt;/li&gt;
&lt;li&gt;http://... 见下面url作为denpendencies的说明&lt;/li&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;任何版本&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&quot;&quot; 空字符，和*相同&lt;/li&gt;
&lt;li&gt;version1 - version2 相当于 &amp;gt;=version1 &amp;lt;=version2.&lt;/li&gt;
&lt;li&gt;range1 || range2 范围1和范围2满足任意一个都行&lt;/li&gt;
&lt;li&gt;git... 见下面git url作为denpendencies的说明&lt;/li&gt;
&lt;li&gt;user/repo See 见下面GitHub仓库的说明&lt;/li&gt;
&lt;li&gt;tag 发布的一个特殊的标签，见npm-tag的文档 &lt;a href=&quot;https://docs.npmjs.com/getting-started/using-tags&quot;&gt;https://docs.npmjs.com/getting-started/using-tags&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;path/path/path 见下面本地模块的说明
下面的写法都是可以的:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;{ &quot;dependencies&quot; :
  { &quot;foo&quot; : &quot;1.0.0 - 2.9999.9999&quot;
  , &quot;bar&quot; : &quot;&amp;gt;=1.0.2 &amp;lt;2.1.2&quot;
  , &quot;baz&quot; : &quot;&amp;gt;1.0.2 &amp;lt;=2.3.4&quot;
  , &quot;boo&quot; : &quot;2.0.1&quot;
  , &quot;qux&quot; : &quot;&amp;lt;1.0.0 || &amp;gt;=2.3.1 &amp;lt;2.4.5 || &amp;gt;=2.5.2 &amp;lt;3.0.0&quot;
  , &quot;asd&quot; : &quot;http://asdf.com/asdf.tar.gz&quot;
  , &quot;til&quot; : &quot;~1.2&quot;
  , &quot;elf&quot; : &quot;~1.2.3&quot;
  , &quot;two&quot; : &quot;2.x&quot;
  , &quot;thr&quot; : &quot;3.3.x&quot;
  , &quot;lat&quot; : &quot;latest&quot;
  , &quot;dyl&quot; : &quot;file:../dyl&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;URLs as Dependencies&lt;/h2&gt;
&lt;p&gt;在版本范围的地方可以写一个url指向一个压缩包，模块安装的时候会把这个压缩包下载下来安装到模块本地。&lt;/p&gt;
&lt;h2&gt;Git URLs as Dependencies&lt;/h2&gt;
&lt;p&gt;Git url可以像下面一样:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git://github.com/user/project.git#commit-ish
git+ssh://user@hostname:project.git#commit-ish
git+ssh://user@hostname/project.git#commit-ish
git+http://user@hostname/project/blah.git#commit-ish
git+https://user@hostname/project/blah.git#commit-ish
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;commit-ish 可以是任意标签，哈希值，或者可以检出的分支，默认是master分支。&lt;/p&gt;
&lt;h2&gt;GitHub URLs&lt;/h2&gt;
&lt;p&gt;支持github的 username/modulename 的写法，#后边可以加后缀写明分支hash或标签：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &quot;name&quot;: &quot;foo&quot;,
  &quot;version&quot;: &quot;0.0.0&quot;,
  &quot;dependencies&quot;: {
    &quot;express&quot;: &quot;visionmedia/express&quot;,
    &quot;mocha&quot;: &quot;visionmedia/mocha#4727d357ea&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Local Paths&lt;/h2&gt;
&lt;p&gt;npm2.0.0版本以上可以提供一个本地路径来安装一个本地的模块，通过npm install xxx --save 来安装，格式如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;../foo/bar
~/foo/bar
./foo/bar
/foo/bar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;package.json 生成的相对路径如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &quot;name&quot;: &quot;baz&quot;,
  &quot;dependencies&quot;: {
    &quot;bar&quot;: &quot;file:../foo/bar&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这种属性在离线开发或者测试需要用npm install的情况，又不想自己搞一个npm server的时候有用，但是发布模块到公共仓库时不应该使用这种属性。&lt;/p&gt;
&lt;h2&gt;devDependencies&lt;/h2&gt;
&lt;p&gt;如果有人想要下载并使用你的模块，也许他们并不希望或需要下载一些你在开发过程中使用的额外的测试或者文档框架。
在这种情况下，最好的方法是把这些依赖添加到devDependencies属性的对象中。
这些模块会在npm link或者npm install的时候被安装，也可以像其他npm配置一样被管理，详见npm的config文档。
对于一些跨平台的构建任务，例如把CoffeeScript编译成JavaScript，就可以通过在package.json的script属性里边配置prepublish脚本来完成这个任务，然后需要依赖的coffee-script模块就写在devDependencies属性种。
例如:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ &quot;name&quot;: &quot;ethopia-waza&quot;,
  &quot;description&quot;: &quot;a delightfully fruity coffee varietal&quot;,
  &quot;version&quot;: &quot;1.2.3&quot;,
  &quot;devDependencies&quot;: {
    &quot;coffee-script&quot;: &quot;~1.6.3&quot;
  },
  &quot;scripts&quot;: {
    &quot;prepublish&quot;: &quot;coffee -o lib/ -c src/waza.coffee&quot;
  },
  &quot;main&quot;: &quot;lib/waza.js&quot;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;prepublish脚本会在发布之前运行，因此用户在使用之前就不用再自己去完成编译的过程了。在开发模式下，运行npm install也会执行这个脚本（见npm script文档），因此可以很方便的调试。&lt;/p&gt;
&lt;h2&gt;peerDependencies&lt;/h2&gt;
&lt;p&gt;有时候做一些插件开发，比如grunt等工具的插件，它们往往是在grunt的某个版本的基础上开发的，而在他们的代码中并不会出现require(&quot;grunt&quot;)这样的依赖，dependencies配置里边也不会写上grunt的依赖，为了说明此模块只能作为插件跑在宿主的某个版本范围下，可以配置peerDependencies：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  &quot;name&quot;: &quot;tea-latte&quot;,
  &quot;version&quot;: &quot;1.3.5&quot;,
  &quot;peerDependencies&quot;: {
    &quot;tea&quot;: &quot;2.x&quot;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面这个配置确保再npm install的时候tea-latte会和2.x版本的tea一起安装，而且它们两个的依赖关系是同级的：
├── tea-latte@1.3.5
└── tea@2.2.0
这个配置的目的是让npm知道，如果要使用此插件模块，请确保安装了兼容版本的宿主模块。&lt;/p&gt;
&lt;h2&gt;bundledDependencies&lt;/h2&gt;
&lt;p&gt;上面的单词少个d，写成bundleDependencies也可以。
指定发布的时候会被一起打包的模块。&lt;/p&gt;
&lt;h2&gt;optionalDependencies&lt;/h2&gt;
&lt;p&gt;如果一个依赖模块可以被使用， 同时你也希望在该模块找不到或无法获取时npm继续运行，你可以把这个模块依赖放到optionalDependencies配置中。这个配置的写法和dependencies的写法一样，不同的是这里边写的模块安装失败不会导致npm install失败。
当然，这种模块就需要你自己在代码中处理模块确实的情况了，例如：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;try {
  var foo = require(&apos;foo&apos;)
  var fooVersion = require(&apos;foo/package.json&apos;).version
} catch (er) {
  foo = null
}
if ( notGoodFooVersion(fooVersion) ) {
  foo = null
}

// .. then later in your program ..

if (foo) {
  foo.doFooThings()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;optionalDependencies 中的配置会覆盖dependencies中的配置，最好只在一个地方写。&lt;/p&gt;
&lt;h2&gt;engines&lt;/h2&gt;
&lt;p&gt;你可以指定项目运行的node版本范围，如下：
{ &quot;engines&quot; : { &quot;node&quot; : &quot;&amp;gt;=0.10.3 &amp;lt;0.12&quot; } }
和dependencies一样，如果你不指定版本范围或者指定为*，任何版本的node都可以。
也可以指定一些npm版本可以正确的安装你的模块，例如：
{ &quot;engines&quot; : { &quot;npm&quot; : &quot;~1.0.20&quot; } }
要注意的是，除非你设置了engine-strict属性，engines属性是仅供参考的。&lt;/p&gt;
&lt;h2&gt;engineStrict&lt;/h2&gt;
&lt;p&gt;注意：这个属性已经弃用，将在npm 3.0.0 版本干掉。&lt;/p&gt;
&lt;h2&gt;os&lt;/h2&gt;
&lt;p&gt;可以指定你的模块只能在哪个操作系统上跑：
&quot;os&quot; : [ &quot;darwin&quot;, &quot;linux&quot; ]
也可以指定黑名单而不是白名单：
&quot;os&quot; : [ &quot;!win32&quot; ]
服务的操作系统是由process.platform来判断的，这个属性允许黑白名单同时存在，虽然没啥必要这样搞...&lt;/p&gt;
&lt;h2&gt;cpu&lt;/h2&gt;
&lt;p&gt;限制模块只能在某某cpu架构下运行
&quot;cpu&quot; : [ &quot;x64&quot;, &quot;ia32&quot; ]
同样可以设置黑名单:
&quot;cpu&quot; : [ &quot;!arm&quot;, &quot;!mips&quot; ]
cpu架构通过 process.arch 判断&lt;/p&gt;
&lt;h2&gt;preferGlobal&lt;/h2&gt;
&lt;p&gt;如果您的软件包主要用于安装到全局的命令行应用程序，那么该值设置为true ，如果它被安装在本地，则提供一个警告。实际上该配置并没有阻止用户把模块安装到本地，只是防止该模块被错误的使用引起一些问题。&lt;/p&gt;
&lt;h2&gt;private&lt;/h2&gt;
&lt;p&gt;如果这个属性被设置为true，npm将拒绝发布它，这是为了防止一个私有模块被无意间发布出去。如果你只想让模块被发布到一个特定的npm仓库，如一个内部的仓库，可与在下面的publishConfig中配置仓库参数。&lt;/p&gt;
&lt;h2&gt;publishConfig&lt;/h2&gt;
&lt;p&gt;这个配置是会在模块发布时用到的一些值的集合。如果你不想模块被默认被标记为最新的，或者默认发布到公共仓库，可以在这里配置tag或仓库地址。&lt;/p&gt;
&lt;h2&gt;DEFAULT VALUES&lt;/h2&gt;
&lt;p&gt;npm设置了一些默认参数，如：
&quot;scripts&quot;: {&quot;start&quot;: &quot;node server.js&quot;}
如果模块根目录下有一个server.js文件，那么npm start会默认运行这个文件。
&quot;scripts&quot;:{&quot;preinstall&quot;: &quot;node-gyp rebuild&quot;}
如果模块根目录下有binding.gyp, npm将默认用node-gyp来编译preinstall的脚本
&quot;contributors&quot;: [...]
若模块根目录下有AUTHORS 文件，则npm会按Name (url)格式解析每一行的数据添加到contributors中，可以用#添加行注释&lt;/p&gt;
&lt;h2&gt;参考文档列表(&lt;a href=&quot;https://docs.npmjs.com/&quot;&gt;https://docs.npmjs.com/&lt;/a&gt;)&lt;/h2&gt;
&lt;p&gt;semver(7)
npm-init(1)
npm-version(1)
npm-config(1)
npm-config(7)
npm-help(1)
npm-faq(7)
npm-install(1)
npm-publish(1)
npm-rm(1)&lt;/p&gt;
</content:encoded></item><item><title>提高记忆的技巧</title><link>https://newpower.pro/posts/notebook/%E6%8F%90%E9%AB%98%E8%AE%B0%E5%BF%86%E7%9A%84%E6%8A%80%E5%B7%A7/</link><guid isPermaLink="true">https://newpower.pro/posts/notebook/%E6%8F%90%E9%AB%98%E8%AE%B0%E5%BF%86%E7%9A%84%E6%8A%80%E5%B7%A7/</guid><pubDate>Tue, 03 Jan 2023 14:34:48 GMT</pubDate><content:encoded>&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;多个感官并用&lt;/strong&gt;
记忆时调用一切感官。没人的话可以大声阅读，有人的话可以默念，轻微摇晃手指等，有助于保持专注。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&amp;lt;!-- more --&amp;gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;重复记忆&lt;/strong&gt;
每天留出半个到一个小时，梳理总结今天所学的内容。每一章复习完成后做系统的知识整理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;建立关联&lt;/strong&gt;
把你所学的新知识与已有的认知建立联系，对于记忆事半功倍。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;场景记忆&lt;/strong&gt;
把知识具象化为一个场景，想象自己在何时何地能用这些知识，与自身发生联系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;提出问题&lt;/strong&gt;
每学习一个知识点，试着提问，然后给出答案。用了就记住了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content:encoded></item><item><title>yaml语言教程</title><link>https://newpower.pro/posts/document/yaml%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/</link><guid isPermaLink="true">https://newpower.pro/posts/document/yaml%E8%AF%AD%E8%A8%80%E6%95%99%E7%A8%8B/</guid><pubDate>Sun, 25 Dec 2022 14:27:01 GMT</pubDate><content:encoded>&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;YAML 是 &quot;YAML Ain&apos;t a Markup Language&quot;（YAML 不是一种标记语言）的递归缩写。在开发的这种语言时，YAML 的意思其实是：&quot;Yet Another Markup Language&quot;（仍是一种标记语言）。&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- more --&amp;gt;&lt;/p&gt;
&lt;p&gt;YAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别&lt;strong&gt;适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲&lt;/strong&gt;（例如：许多电子邮件标题格式和YAML非常接近）。&lt;/p&gt;
&lt;p&gt;YAML 的配置文件后缀为 &lt;strong&gt;.yml&lt;/strong&gt;，如：&lt;strong&gt;runoob.yml&lt;/strong&gt; 。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;yaml常用来用作配置文件，和json类似&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;基本语法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;大小写敏感&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用缩进表示层级关系&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缩进不允许使用tab，只允许空格&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缩进的空格数不重要，只要相同层级的元素左对齐即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&apos;#&apos;表示注释&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;数据类型&lt;/h2&gt;
&lt;p&gt;YAML 支持以下几种数据类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;对象&lt;/strong&gt;：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数组&lt;/strong&gt;：一组按次序排列的值，又称为序列（sequence） / 列表（list）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;纯量&lt;/strong&gt;（scalars）：单个的、不可再分的值&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;YAML 对象&lt;/h2&gt;
&lt;p&gt;对象的几种表示形式：&lt;/p&gt;
&lt;p&gt;1、对象键值对使用冒号结构表示 &lt;strong&gt;key: value&lt;/strong&gt;，冒号后面要加一个空格。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;key: value
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2、也可以使用 &lt;strong&gt;key:{key1: value1, key2: value2, ...}&lt;/strong&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;key:{child-key1:value1,child-key2:value2}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;3、还可以使用缩进表示层级关系；&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;key: 
    child-key1: value1
    child-key2: value2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同2，只是表示形式不同。&lt;/p&gt;
&lt;p&gt;4、较为复杂的对象格式，可以使用问号加一个空格代表一个复杂的 key，配合一个冒号加一个空格代表一个 value：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;?  
    - complexkey1
    - complexkey2
:
    - complexvalue1
    - complexvalue2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;意思即对象的属性是一个数组 [complexkey1,complexkey2]，对应的值也是一个数组 [complexvalue1,complexvalue2]&lt;/p&gt;
&lt;h2&gt;YAML 数组&lt;/h2&gt;
&lt;p&gt;以 &lt;strong&gt;-&lt;/strong&gt; 开头的行表示构成一个数组：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- A
- B
- C
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;YAML 支持多维数组，可以使用行内表示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;key: [value1, value2, ...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-
 - A
 - B
 - C
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一个相对复杂的例子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;companies:
    -
        id: 1
        name: company1
        price: 200W
    -
        id: 2
        name: company2
        price: 500W
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;意思是 companies 属性是一个数组，每一个数组元素又是由 id、name、price 三个属性构成。&lt;/p&gt;
&lt;p&gt;数组也可以使用流式(flow)的方式表示：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;companies: [{id: 1,name: company1,price: 200W},{id: 2,name: company2,price: 500W}]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;复合结构（对象和数组组合）&lt;/h2&gt;
&lt;p&gt;数组和对象可以构成复合结构，例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;languages:
  - Ruby
  - Perl
  - Python 
websites:
  YAML: yaml.org 
  Ruby: ruby-lang.org 
  Python: python.org 
  Perl: use.perl.org
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;转换为 js 为：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ 
  languages: [ &apos;Ruby&apos;, &apos;Perl&apos;, &apos;Python&apos;],
  websites: {
    YAML: &apos;yaml.org&apos;,
    Ruby: &apos;ruby-lang.org&apos;,
    Python: &apos;python.org&apos;,
    Perl: &apos;use.perl.org&apos; 
  } 
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;纯量&lt;/h2&gt;
&lt;p&gt;纯量是最基本的，不可再分的值，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字符串&lt;/li&gt;
&lt;li&gt;布尔值&lt;/li&gt;
&lt;li&gt;整数&lt;/li&gt;
&lt;li&gt;浮点数&lt;/li&gt;
&lt;li&gt;Null&lt;/li&gt;
&lt;li&gt;时间&lt;/li&gt;
&lt;li&gt;日期&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用一个例子来快速了解纯量的基本使用：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;boolean: # 布尔值
    - TRUE  #true,True都可以
    - FALSE  #false，False都可以
float: # 浮点数
    - 3.14
    - 6.8523015e+5  #可以使用科学计数法
int: # 整数
    - 123
    - 0b1010_0111_0100_1010_1110    #二进制表示
null: # Null
    nodeName: &apos;node&apos;
    parent: ~  #使用~表示null
string: # 字符串
    - 哈哈 # 字符串默认不使用引号表示
    - &apos;Hello world&apos;  #可以使用双引号或者单引号包裹特殊字符
    - newline
      newline2    #字符串可以拆成多行，每一行会被转化成一个空格
date:
    - 2018-02-17    #日期必须使用ISO 8601格式，即yyyy-MM-dd
datetime: 
    -  2018-02-17T15:02:31+08:00    #时间使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;多行字符串可以使用&lt;code&gt;|&lt;/code&gt;保留换行符，也可以使用&lt;code&gt;&amp;gt;&lt;/code&gt;折叠换行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;this: |
  Foo
  Bar
that: &amp;gt;
  Foo
  Bar
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;转为js代码如下。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ this: &apos;Foo\nBar\n&apos;, that: &apos;Foo Bar\n&apos; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;+&lt;/code&gt;表示保留文字块末尾的换行，&lt;code&gt;-&lt;/code&gt;表示删除字符串末尾的换行。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;s1: |
  Foo
 
s2: |+
  Foo
 
 
s3: |-
  Foo
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;转为json代码如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ s1: &apos;Foo\n&apos;, s2: &apos;Foo\n\n\n&apos;, s3: &apos;Foo&apos; }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;字符串之中可以插入 HTML 标记。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;message: |
  &amp;lt;p style=&quot;color: red&quot;&amp;gt;
    段落
  &amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;转换数据格式&lt;/h2&gt;
&lt;p&gt;允许使用两个感叹号，强制转换数据类型。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;e: !!str 123
f: !!str true
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;转换js结果同：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{ e: &apos;123&apos;, f: &apos;true&apos; }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;锚点引用&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;&amp;amp;&lt;/strong&gt; 锚点和&amp;lt; span class=&quot;marked&quot;&amp;gt;* 别名，可以用来引用:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;defaults: &amp;amp;defaults # 添加锚点
  adapter:  postgres
  host:     localhost

development:
  database: myapp_development
  &amp;lt;&amp;lt;: *defaults # &amp;lt;&amp;lt;表示合并，*引用锚点

test:
  database: myapp_test
  &amp;lt;&amp;lt;: *defaults # &amp;lt;&amp;lt;表示合并，*引用锚点
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;相当于:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;defaults:
  adapter:  postgres
  host:     localhost

development:
  database: myapp_development
  adapter:  postgres
  host:     localhost

test:
  database: myapp_test
  adapter:  postgres
  host:     localhost
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;&amp;amp;&lt;/strong&gt; 用来建立锚点（defaults），&lt;strong&gt;&amp;lt;&amp;lt;&lt;/strong&gt; 表示合并到当前数据，***** 用来引用锚点。&lt;/p&gt;
&lt;p&gt;下面是另一个例子:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;- &amp;amp;showell Steve 
- Clark 
- Brian 
- Oren 
- *showell 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;转为js代码如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[ &apos;Steve&apos;, &apos;Clark&apos;, &apos;Brian&apos;, &apos;Oren&apos;, &apos;Steve&apos; ]
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;yaml官网：&lt;a href=&quot;https://yaml.org/&quot;&gt;https://yaml.org/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;yaml与js的转换demo：&lt;a href=&quot;http://nodeca.github.io/js-yaml/&quot;&gt;http://nodeca.github.io/js-yaml/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;菜鸟教程：&lt;a href=&quot;https://www.ruanyifeng.com/blog/2016/07/yaml.html&quot;&gt;https://www.ruanyifeng.com/blog/2016/07/yaml.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
</content:encoded></item><item><title>Git变基合并</title><link>https://newpower.pro/posts/notebook/git/git%E5%8F%98%E5%9F%BA%E5%90%88%E5%B9%B6/</link><guid isPermaLink="true">https://newpower.pro/posts/notebook/git/git%E5%8F%98%E5%9F%BA%E5%90%88%E5%B9%B6/</guid><pubDate>Sat, 19 Nov 2022 17:43:57 GMT</pubDate><content:encoded>&lt;h2&gt;说明&lt;/h2&gt;
&lt;p&gt;以下 &lt;code&gt;v2&lt;/code&gt; 是某个需求的开发分支， &lt;code&gt;dev&lt;/code&gt;是总的开发分支，&lt;code&gt;v2&lt;/code&gt; 是基于&lt;code&gt;dev&lt;/code&gt;分支签出的。&lt;/p&gt;
&lt;p&gt;当完成&lt;code&gt;v2&lt;/code&gt;的开发后，需要把代码合并到&lt;code&gt;dev&lt;/code&gt;，我们可以使用&lt;code&gt;rebase&lt;/code&gt;进行合并：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 首先将 v2 push到远程仓库
git add .
git commit -m &apos;xxx&apos;
git push origin v2

# 切换到 dev 拉取最新代码
git checkout dev
git pull origin dev

# 切换到 v2
git checkout v2
git rebase dev # 将 v2 的所有[commit] 变基到(应用到) dev

# 切换到 dev
git checkout dev
git merge v2  # 将 dev分支 快进合并 （此时 (HEAD -&amp;gt; dev, v2) [commit] 两个分支指向同一个提交）

# 查看 原v2的[commit]记录 是否在dev分支的最前面（变基成功会把v2的提交记录应用到dev分支的最前面）
git log

 # 如果到这一步发现有问题，尝试使用 git --abort中止变基，如果还是有问题的可以在dev分支上使用《后悔药》操作， 再到v2分支上使用《后悔药》操作，即可使两个分支都回退到 rebase变基 之前的状态

# 试运行项目是否有问题
yarn start

git status # 查看状态是否有问题
git push origin dev # 推送到远程仓库的 dev

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;变基要遵守的准则&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;几个人同时在一个分支上进行开发和提交时，开发中途请不要私自执行变基，只有在大家都完成工作之后才可以执行变基。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;变基的实质&lt;/h3&gt;
&lt;p&gt;变基操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。
因此，&lt;strong&gt;变基操作过后的分支将不要再使用&lt;/strong&gt;。&lt;/p&gt;
&lt;h2&gt;后悔药&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 查看HEAD指针变动记录
git reflog
# 记录示例(当前分支是v2):
07c398f (HEAD -&amp;gt; v2, master) HEAD@{0}: checkout: moving from master to v2
07c398f (HEAD -&amp;gt; v2, master) HEAD@{1}: rebase (finish): returning to refs/heads/master
07c398f (HEAD -&amp;gt; v2, master) HEAD@{2}: rebase (start): checkout v2
15a97d8 HEAD@{3}: reset: moving to 15a97d8
07c398f (HEAD -&amp;gt; v2, master) HEAD@{4}: merge v2: Fast-forward
15a97d8 HEAD@{5}: checkout: moving from v2 to master
07c398f (HEAD -&amp;gt; v2, master) HEAD@{6}: rebase (finish): returning to refs/heads/v2
07c398f (HEAD -&amp;gt; v2, master) HEAD@{7}: rebase (pick): C
15a97d8 HEAD@{8}: rebase (start): checkout master # 首次rebase
d278ecd HEAD@{9}: checkout: moving from master to v2 # rebase前的状态
15a97d8 HEAD@{10}: commit: D

# 可见，示例中最初的 rebase 操作是 HEAD@{8}，想回退到变基前的状态需让指针指向 HEAD@{9}
git reset --hard d278ecd  # 重置当前分支的HEAD为指定[commit]，同时重置暂存区和工作区，与指定[commit]一致

# 此时打印 log 查看是否回到之前的状态
git log
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：此操作只能回退当前的分支，如其他分支也要回退，需要切换到该分支并执行上面操作。&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;开发期间的rebase操作&lt;/h2&gt;
&lt;h3&gt;背景&lt;/h3&gt;
&lt;p&gt;有两个分支：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dev
*v2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;v2&lt;/code&gt; 是基于&lt;code&gt;dev&lt;/code&gt;切出来的。&lt;/p&gt;
&lt;p&gt;提交记录如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;  dev
a - b - c
  v2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;开发期间，两个分支同时有新的commit ：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    dev
a - b - c - d - e
  \ - f - g
    v2
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当前你正在&lt;code&gt;v2&lt;/code&gt;进行开发，&lt;code&gt;dev&lt;/code&gt;也同时进行开发，并有重大的改变，你需要把&lt;code&gt;dev&lt;/code&gt;的提交同步到&lt;code&gt;v2&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需求： 把&lt;code&gt;dev&lt;/code&gt;中新的提交同步到&lt;code&gt;v2&lt;/code&gt;，且不能影响&lt;code&gt;dev&lt;/code&gt;分支。&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;操作步骤&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;基于最新的 &lt;code&gt;dev&lt;/code&gt; 切一个新的分支 &lt;code&gt;dev-copy&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;dev-copy&lt;/code&gt; 和 &lt;code&gt;dev&lt;/code&gt;  两者的 commit ID 一致。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在&lt;code&gt;dev-copy&lt;/code&gt;中执行rebase，将 &lt;code&gt;dev-copy&lt;/code&gt; 的提交变基到 &lt;code&gt;v2&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git rebase v2 # 将 dev-copy 的提交[commit] 变基到(应用到) v2
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除原&lt;code&gt;v2&lt;/code&gt;分支，将&lt;code&gt;dev-copy&lt;/code&gt;分支名改为&lt;code&gt;v2&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 当前在 dev-copy 分支
git branch -d v2 # 删除分支
git branch -m dev-copy v2 # 重命名
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;git cherry-pick&lt;/h2&gt;
&lt;p&gt;来源：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html&quot;&gt;《git cherry-pick 教程》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;用于将单个或几个&lt;code&gt;[commit]&lt;/code&gt;复制到另一个分支。&lt;/p&gt;
&lt;h3&gt;基本应用&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git cherry-pick &amp;lt;commitHash&amp;gt; # 将commitHash应用于当前分支
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面命令就会将指定的提交&lt;code&gt;commitHash&lt;/code&gt;，应用于当前分支。这会在当前分支产生一个新的提交，当然它们的&lt;strong&gt;哈希值会不一样&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;git cherry-pick命令的参数，不一定是提交的哈希值，分支名也是可以的，表示转移该分支的最新提交。&lt;/p&gt;
&lt;h3&gt;转移多个提交&lt;/h3&gt;
&lt;p&gt;Cherry pick 支持一次转移多个提交。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git cherry-pick &amp;lt;HashA&amp;gt; &amp;lt;HashB&amp;gt; # A和B提交
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的命令将 A 和 B 两个提交应用到当前分支。这会在当前分支生成两个对应的新提交。&lt;/p&gt;
&lt;p&gt;如果想要转移一系列的连续提交，可以使用下面的简便语法。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git cherry-pick A..B # A到B提交，不包含A
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面的命令可以转移从 A 到 B 的所有提交。它们必须按照正确的顺序放置：提交 A 必须早于提交 B，否则命令将失败，但不会报错。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意，使用上面的命令，提交 A 将不会包含在 Cherry pick 中。如果要包含提交 A，可以使用下面的语法。&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git cherry-pick A^..B # A到B提交，包含A
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>常用Git命令清单</title><link>https://newpower.pro/posts/notebook/git/%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/</link><guid isPermaLink="true">https://newpower.pro/posts/notebook/git/%E5%B8%B8%E7%94%A8git%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/</guid><pubDate>Fri, 18 Nov 2022 17:43:57 GMT</pubDate><content:encoded>&lt;p&gt;一般来说，日常使用只要记住下图6个命令，就可以了。但是熟练使用，恐怕要记住60～100个命令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;
&lt;p&gt;下面是我整理的常用 Git 命令清单。几个专用名词的译名如下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Workspace：工作区&lt;/li&gt;
&lt;li&gt;Index / Stage：暂存区&lt;/li&gt;
&lt;li&gt;Repository：仓库区（或本地仓库）&lt;/li&gt;
&lt;li&gt;Remote：远程仓库&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2&gt;一、新建代码库&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 在当前目录新建一个Git代码库
$ git init

# 新建一个目录，将其初始化为Git代码库
$ git init [project-name]

# 下载一个项目和它的整个代码历史
$ git clone [url]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;二、配置&lt;/h2&gt;
&lt;p&gt;Git的设置文件为&lt;code&gt;.gitconfig&lt;/code&gt;，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 显示当前的Git配置
$ git config --list

# 编辑Git配置文件
$ git config -e [--global]

# 设置提交代码时的用户信息
$ git config [--global] user.name &quot;[name]&quot;
$ git config [--global] user.email &quot;[email address]&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;三、增加/删除文件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 添加指定文件到暂存区
$ git add [file1] [file2] ...

# 添加指定目录到暂存区，包括子目录
$ git add [dir]

# 添加当前目录的所有文件到暂存区
$ git add .

# 添加每个变化前，都会要求确认
# 对于同一个文件的多处变化，可以实现分次提交
$ git add -p

# 删除工作区文件，并且将这次删除放入暂存区
$ git rm [file1] [file2] ...

# 停止追踪指定文件，但该文件会保留在工作区
$ git rm --cached [file]

# 改名文件，并且将这个改名放入暂存区
$ git mv [file-original] [file-renamed]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;四、代码提交&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 提交暂存区到仓库区
$ git commit -m [message]

# 提交暂存区的指定文件到仓库区
$ git commit [file1] [file2] ... -m [message]

# 提交工作区自上次commit之后的变化，直接到仓库区
$ git commit -a

# 提交时显示所有diff信息
$ git commit -v

# 使用一次新的commit，替代上一次提交
# 如果代码没有任何新变化，则用来改写上一次commit的提交信息
$ git commit --amend -m [message]

# 重做上一次commit，并包括指定文件的新变化
$ git commit --amend [file1] [file2] ...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;五、分支&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 列出所有本地分支
$ git branch

# 列出所有远程分支
$ git branch -r

# 列出所有本地分支和远程分支
$ git branch -a

# 新建一个分支，但依然停留在当前分支
$ git branch [branch-name]

# 新建一个分支，并切换到该分支
$ git checkout -b [branch]

# 新建一个分支，指向指定commit
$ git branch [branch] [commit]

# 新建一个分支，与指定的远程分支建立追踪关系
$ git branch --track [branch] [remote-branch]

# 切换到指定分支，并更新工作区
$ git checkout [branch-name]

# 切换到上一个分支
$ git checkout -

# 建立追踪关系，在现有分支与指定的远程分支之间
$ git branch --set-upstream [branch] [remote-branch]

# 合并指定分支到当前分支
$ git merge [branch]

# 选择一个commit，合并进当前分支
$ git cherry-pick [commit]

# 删除分支
$ git branch -d [branch-name]

# 删除远程分支
$ git push origin --delete [branch-name]
$ git branch -dr [remote/branch]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;六、标签&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 列出所有tag
$ git tag

# 新建一个tag在当前commit
$ git tag [tag]

# 新建一个tag在指定commit
$ git tag [tag] [commit]

# 删除本地tag
$ git tag -d [tag]

# 删除远程tag
$ git push origin :refs/tags/[tagName]

# 查看tag信息
$ git show [tag]

# 提交指定tag
$ git push [remote] [tag]

# 提交所有tag
$ git push [remote] --tags

# 新建一个分支，指向某个tag
$ git checkout -b [branch] [tag]
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;七、查看信息&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 显示有变更的文件
$ git status

# 显示当前分支的版本历史
$ git log

# 显示commit历史，以及每次commit发生变更的文件
$ git log --stat

# 搜索提交历史，根据关键词
$ git log -S [keyword]

# 显示某个commit之后的所有变动，每个commit占据一行
$ git log [tag] HEAD --pretty=format:%s

# 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件
$ git log [tag] HEAD --grep feature

# 显示某个文件的版本历史，包括文件改名
$ git log --follow [file]
$ git whatchanged [file]

# 显示指定文件相关的每一次diff
$ git log -p [file]

# 显示过去5次提交
$ git log -5 --pretty --oneline

# 显示所有提交过的用户，按提交次数排序
$ git shortlog -sn

# 显示指定文件是什么人在什么时间修改过
$ git blame [file]

# 显示暂存区和工作区的差异
$ git diff

# 显示暂存区和上一个commit的差异
$ git diff --cached [file]

# 显示工作区与当前分支最新commit之间的差异
$ git diff HEAD

# 显示两次提交之间的差异
$ git diff [first-branch]...[second-branch]

# 显示今天你写了多少行代码
$ git diff --shortstat &quot;@{0 day ago}&quot;

# 显示某次提交的元数据和内容变化
$ git show [commit]

# 显示某次提交发生变化的文件
$ git show --name-only [commit]

# 显示某次提交时，某个文件的内容
$ git show [commit]:[filename]

# 显示当前分支的最近几次提交
$ git reflog
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;八、远程同步&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 下载远程仓库的所有变动
$ git fetch [remote]

# 显示所有远程仓库
$ git remote -v

# 显示某个远程仓库的信息
$ git remote show [remote]

# 增加一个新的远程仓库，并命名
$ git remote add [shortname] [url]

# 取回远程仓库的变化，并与本地分支合并
$ git pull [remote] [branch]

# 上传本地指定分支到远程仓库
$ git push [remote] [branch]

# 强行推送当前分支到远程仓库，即使有冲突
$ git push [remote] --force

# 推送所有分支到远程仓库
$ git push [remote] --all
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;九、撤销&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 恢复暂存区的指定文件到工作区
$ git checkout [file]

# 恢复某个commit的指定文件到暂存区和工作区
$ git checkout [commit] [file]

# 恢复暂存区的所有文件到工作区
$ git checkout .

# 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变
$ git reset [file]

# 重置暂存区与工作区，与上一次commit保持一致
$ git reset --hard

# 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变
$ git reset [commit]

# 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致
$ git reset --hard [commit]

# 重置当前HEAD为指定commit，但保持暂存区和工作区不变
$ git reset --keep [commit]

# 新建一个commit，用来撤销指定commit
# 后者的所有变化都将被前者抵消，并且应用到当前分支
$ git revert [commit]

# 暂时将未提交的变化移除，稍后再移入
$ git stash
$ git stash pop
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;十、常用操作组合&lt;/h2&gt;
&lt;h3&gt;1. 修改本地分支名和远程分支名&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git branch -m old_branch new_branch # 重命名本地分支
git push origin :old_branch # 删除远程旧分支（分支名前有冒号）
git push --set-upstream origin new_branch # 推送新的分支，并设置本地分支跟踪新的远程分支
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;相关文章：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2019/12/git-undo.html&quot;&gt;《如何撤销 Git 操作？》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2020/04/git-cherry-pick.html&quot;&gt;《git cherry-pick 教程》&lt;/a&gt; 复制某分支上的部分提交到另一个分支上（相对于可以选择指定提交的 rebase 操作）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;命令清单来源：https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded></item><item><title>Git修改分支名</title><link>https://newpower.pro/posts/document/git%E4%BF%AE%E6%94%B9%E5%88%86%E6%94%AF%E5%90%8D/</link><guid isPermaLink="true">https://newpower.pro/posts/document/git%E4%BF%AE%E6%94%B9%E5%88%86%E6%94%AF%E5%90%8D/</guid><pubDate>Thu, 11 Aug 2022 10:51:18 GMT</pubDate><content:encoded>&lt;h2&gt;同时修改本地分支名和对应的远程分支名&lt;/h2&gt;
&lt;p&gt;修改前要确保本地分支的代码是最新的，并且修改后不会影响到同事的代码。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;修改本地分支名&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git branch -m oldBranchName newBranchName
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;删除远程分支&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git push origin :oldBranchName
# 或者 git push origin --delete oldBranchName
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
&lt;li&gt;改名后的本地分支推送到远程&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;git push --set-upstream origin newBranchName
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>费曼学习法</title><link>https://newpower.pro/posts/notebook/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/</link><guid isPermaLink="true">https://newpower.pro/posts/notebook/%E8%B4%B9%E6%9B%BC%E5%AD%A6%E4%B9%A0%E6%B3%95/</guid><pubDate>Sat, 16 Jul 2022 10:04:14 GMT</pubDate><content:encoded>&lt;p&gt;费曼学习法，我很喜欢的一个学习方法，简单来说，就是：通过向别人清楚的解说某一件事或是写一篇浅显易懂的教程文章，来确认自己是否真正弄懂了这件事。
可以说是在通过向别讲解过程中来对自身的 &lt;strong&gt;查缺补漏&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;步骤&lt;/h3&gt;
&lt;p&gt;费曼学习法分为4个步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;确定学习目标&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你想学习的概念、内容、主题是什么。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;模拟教学学习法&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;你要模拟自己是一位老师，面对完全不懂这个领域的人，用自己的话，尽可能具体形象地讲诉。这样的讲诉有助于你活学活用，触类旁通，联系生活具体情境。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;回顾&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;反思第2步遇到的问题，哪些地方卡壳了，哪些地方对方没有真正听懂。找出问题的要害，把握关键环节。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;简化&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;把这些遇到问题的地方，重新梳理理解，尽可能了解更多背景和相关知识，再用尽可能简化的方式重新表达，设法看穿本质。然后，返回第2步。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/88209825&quot;&gt;《费曼学习法：为何被称为史上最牛的学习法，它的本质究竟是什么？》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/90be6a69528a&quot;&gt;《费曼学习法》&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded></item><item><title>网站</title><link>https://newpower.pro/posts/favorite/%E7%BD%91%E7%AB%99/</link><guid isPermaLink="true">https://newpower.pro/posts/favorite/%E7%BD%91%E7%AB%99/</guid><description>个人收藏夹</description><pubDate>Tue, 19 Apr 2022 11:33:04 GMT</pubDate><content:encoded>&lt;h2&gt;推荐&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://panjiachen.github.io/awesome-bookmarks/&quot;&gt;panjiachen&lt;/a&gt; by 花裤衩&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.code-nav.cn/&quot;&gt;编程导航&lt;/a&gt; by 程序员鱼皮&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://r2coding.com/&quot;&gt;编程自学之路&lt;/a&gt; by 程序羊&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://gitee.com/jishupang/web_atlas&quot;&gt;前端知识图谱+B站资源整合&lt;/a&gt; by 技术胖&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://shengxinjing.cn/&quot;&gt;大圣编程自学网&lt;/a&gt; by 大圣&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://devtool.tech/&quot;&gt;开发者武器库&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.fly63.com/tool/home.html&quot;&gt;工具大全&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;文档&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web&quot;&gt;MDN&lt;/a&gt; | &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects&quot;&gt;MDN-JS标准内置对象&lt;/a&gt; Web技术权威文档&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://devdocs.io/&quot;&gt;DevDocs&lt;/a&gt; Web 开发技术文档，非常不错的学习手册！&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zh.javascript.info&quot;&gt;现代JavaScript教程&lt;/a&gt; 以最新标准为基准的JS教程&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://wangdoc.com/javascript/&quot;&gt;ES5教程&lt;/a&gt; 阮一峰的JS教程&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://es6.ruanyifeng.com/&quot;&gt;ES6教程&lt;/a&gt; 阮一峰的ES6教程&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://wangdoc.com/bash/&quot;&gt;Bash 脚本教程&lt;/a&gt; 阮一峰编写&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ecma-international.org/&quot;&gt;ECMA&lt;/a&gt; ECMA官网&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.runoob.com/&quot;&gt;菜鸟教程&lt;/a&gt; 涵盖多种语言的初级教程&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cloud.tencent.com/developer/devdocs&quot;&gt;腾讯云开发者手册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twikoo.js.org/&quot;&gt;Twikoo 文档&lt;/a&gt; 一款简洁、安全、免费的静态网站评论系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;社区&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/&quot;&gt;Github&lt;/a&gt; 程序员同性交友社区&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.im/&quot;&gt;掘金&lt;/a&gt; 一个帮助开发者成长的社区&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/&quot;&gt;简书&lt;/a&gt; 有很多频道的创作社区&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://segmentfault.com/&quot;&gt;思否&lt;/a&gt; 解决技术问题的社区&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://stackoverflow.com/&quot;&gt;stack overflow&lt;/a&gt; 同上，外网的&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.infoq.cn/topic/Front-end&quot;&gt;InfoQ&lt;/a&gt; 促进软件开发及相关领域知识与创新的传播&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.v2ex.com/&quot;&gt;V2EX&lt;/a&gt; 创意工作者们的社区&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://mo.fish&quot;&gt;鱼塘热榜&lt;/a&gt; 划水网站，收集了很多网站，当天热门文章&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://maliquankai.com/designnav/&quot;&gt;码力全开资源库&lt;/a&gt; 很全很强大，独立开发者/设计干货/优质利器/工具资源...&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;技巧&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://trends.google.com/trends&quot;&gt;Google 趋势&lt;/a&gt; 查看某项技术或关键字的热度趋势，可用于分析某项技术的发展前景，或对比某两项技术的热度。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://index.baidu.com/v2/index.html#/&quot;&gt;百度指数&lt;/a&gt; 同上，但百度的数据仅限国内。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;博客&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/&quot;&gt;阮一峰的网络日志&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.samanthaming.com/&quot;&gt;samanthaming&lt;/a&gt; 对前端小知识点的总结，并为每个知识点制作精美的小卡片。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;电子书&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ebook.hep.com.cn/ebooks/h5/index.html&quot;&gt;高教书苑&lt;/a&gt; 高等教育出版社的书籍，包含多种学科。
&amp;lt;!-- * &lt;a href=&quot;http://www.yuanchengcheng.vip/books&quot;&gt;前端电子书收集&lt;/a&gt; --&amp;gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://sobooks.cc/&quot;&gt;SoBooks&lt;/a&gt; 免费的电子书资源网站&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.shidianguji.com/&quot;&gt;识典古籍&lt;/a&gt; 古籍数字化平台&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;优秀文章&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://coolshell.cn/articles/21672.html&quot;&gt;我做系统架构的一些原则&lt;/a&gt; 作者对系统架构的方法论总结&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.im/post/5d4d0ec651882549594e7293&quot;&gt;灵活运用CSS开发技巧&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ishadeed.com/article/defensive-css/&quot;&gt;防御性CSS&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;视频&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.bilibili.com/&quot;&gt;bilibili&lt;/a&gt; B站，上面很多免费教学视频&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.imooc.com/&quot;&gt;慕课网&lt;/a&gt; 实战视频教程&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.miaov.com/&quot;&gt;妙味课堂&lt;/a&gt; 比较系统的前端入门视频教程&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.icourse163.org/&quot;&gt;中国大学MOOC&lt;/a&gt; 涵盖计算机、外语、心理学等专业免费课程&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://le.ouchn.cn/&quot;&gt;终身教育平台&lt;/a&gt; 涵盖生活、兴趣、职场、技能、老年、学历等免费课程&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://egghead.io&quot;&gt;egghead&lt;/a&gt; 质量还不错的短视频教程，外网&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Github&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://repobeats.axiom.co/&quot;&gt;Repobeats&lt;/a&gt; 生成仓库的动态数据统计图&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://git.io/&quot;&gt;github 短域名服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://shields.io/&quot;&gt;shields&lt;/a&gt; 徽章图标&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://wangchujiang.com/github-rank/index.html&quot;&gt;followers 全球排名&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://star-history.t9t.io/&quot;&gt;star-history&lt;/a&gt; 展示一个项目 Stars 增长曲线&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;评论系统&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://giscus.app/zh-CN&quot;&gt;giscus&lt;/a&gt; 由 &lt;a href=&quot;https://docs.github.com/en/discussions&quot;&gt;GitHub Discussions&lt;/a&gt; 驱动的评论系统&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://twikoo.js.org/&quot;&gt;Twikoo&lt;/a&gt; 一个简洁、安全、免费的静态网站评论系统&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://valine.js.org/&quot;&gt;Valine&lt;/a&gt; 一款快速、简洁且高效的无后端评论系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;前端小工具&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://caniuse.com/&quot;&gt;Can I use&lt;/a&gt; 查看属性和方法的兼容性&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://30secondsofcode.org/&quot;&gt;30 seconds of code&lt;/a&gt; 收集了许多有用的代码小片段&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;代码编辑&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://codepen.io&quot;&gt;codepen&lt;/a&gt; 在线代码编辑与演示&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://codesandbox.io&quot;&gt;codesandbox&lt;/a&gt; 内嵌VSCode的在线IDE&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Emoji表情&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://emojipedia.org/&quot;&gt;emoji表情&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.webfx.com/tools/emoji-cheat-sheet&quot;&gt;emoji表情备忘录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://translate.yandex.com/?lang=zh-emj&quot;&gt;根据文本匹配emoji&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/carloscuesta/gitmoji&quot;&gt;gitmoji&lt;/a&gt; 通过 emoji 表达 git 的操作内容&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;在任意输入框快速打开emoji表情方法：&amp;lt;br/&amp;gt;
Windows系统下按&amp;lt;kbd&amp;gt;Win&amp;lt;/kbd&amp;gt; + &amp;lt;kbd&amp;gt;.&amp;lt;/kbd&amp;gt;&amp;lt;br/&amp;gt;
Mac系统下按&amp;lt;kbd&amp;gt;Control&amp;lt;/kbd&amp;gt; + &amp;lt;kbd&amp;gt;Command&amp;lt;/kbd&amp;gt; + &amp;lt;kbd&amp;gt;空格&amp;lt;/kbd&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;图片工具&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://tinypng.com&quot;&gt;tinypng图片压缩&lt;/a&gt; 压缩png很有用&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://devtool.tech/tiny-image&quot;&gt;微图&lt;/a&gt; 浏览器端图片压缩，不会上传图片到服务器&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://squoosh.app/&quot;&gt;Squoosh&lt;/a&gt; 谷歌出品在线免费图片压缩工具（jpg、png等,压缩效果比tinypng稍好）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://waifu2x.udp.jp/&quot;&gt;waifu2x&lt;/a&gt; 通过卷积网络放大图片&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://vectormagic.com/&quot;&gt;vectormagic&lt;/a&gt; 转换矢量图&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.vectorizer.io/&quot;&gt;vectorizer&lt;/a&gt; 真正的 png 转 svg 神器&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://photo.opencool.cn/&quot;&gt;在线AI图片处理&lt;/a&gt; 黑白修复、无损放大、动漫化、铅笔画等。&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.remove.bg/zh&quot;&gt;remove&lt;/a&gt; AI抠图（抠背景）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.magiceraser.io/&quot;&gt;magic eraser&lt;/a&gt; AI抠图（抠前景）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/nadermx/backgroundremover&quot;&gt;backgroundremover&lt;/a&gt; 又一个抠图的&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.websiteplanet.com/zh-hans/webtools/imagecompressor/&quot;&gt;websiteplanet&lt;/a&gt; 高质量图片压缩工具&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;SVG&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://e2.cool/&quot;&gt;svg编辑器-E2.Cool&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://x.ipaiban.com/login&quot;&gt;svg编辑器-i排版&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;音视频工具&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://app.xunjieshipin.com/video-converter/&quot;&gt;迅捷视频转换器&lt;/a&gt; 在线转换各种视频格式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://app.xunjieshipin.com/video-converter/&quot;&gt;迅捷音频转换器&lt;/a&gt; 在线转换各种音频格式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://mp3cut.net/cn/&quot;&gt;修剪音频&lt;/a&gt; 在线修剪或剪切任何音频文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;思维导图&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.processon.com/&quot;&gt;processon在线作图&lt;/a&gt; 流程图、思维导图、原型图等&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://naotu.baidu.com&quot;&gt;百度脑图&lt;/a&gt; 思维导图&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;plectica.com&quot;&gt;plectica&lt;/a&gt; 绘制知识图谱&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;CSS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://juejin.cn/post/7030572979868139551?utm_source=gold_browser_extension&quot;&gt;各种CSS生成器和JS代码片段&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://css-tricks.neatbang.com/&quot;&gt;CSS Tricks&lt;/a&gt; CSS技巧收集与演示&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://neumorphism.io/&quot;&gt;CSS生成器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.colorzilla.com/gradient-editor/&quot;&gt;CSS渐变生成器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.html.cn/tool/css3Preview/Box-Shadow.html&quot;&gt;CSS3-Box Shadow(阴影)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cubic-bezier.com&quot;&gt;贝塞尔曲线生成器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.heropatterns.com/&quot;&gt;花纹背景生成器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/bansal-io/pattern.css&quot;&gt;花纹背景-pattern.css&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://bennettfeely.com/ztext/&quot;&gt;3D字体&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://css-tricks.com/&quot;&gt;css-tricks&lt;/a&gt; css技巧文章&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://lhammer.cn/You-need-to-know-css/#/zh-cn/&quot;&gt;You-need-to-know-css&lt;/a&gt; CSS的各种DEMO，很全&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://animista.net/&quot;&gt;animista&lt;/a&gt; CSS动画可视化工具，复制代码就能用&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://navnav.co/&quot;&gt;navnav&lt;/a&gt; 各种炫酷的CSS动画组件&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;CDN加速&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.jsdelivr.com/&quot;&gt;jsDelivr&lt;/a&gt; 国外的一家优秀的公共 CDN 服务提供商&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://unpkg.com/&quot;&gt;unpkg&lt;/a&gt; cdn 服务&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;网站托管&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://vercel.com/&quot;&gt;vercel&lt;/a&gt; 好用的网站托管服务&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;正则&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://regex101.com/&quot;&gt;正则可视化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://ihateregex.io/&quot;&gt;iHateRegex&lt;/a&gt; 正则搜索，细节做得很好&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/qdlaoyao/js-regex-mini-book&quot;&gt;正则迷你书&lt;/a&gt; 学习正则的小手册&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;其他&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://ipcmen.com/&quot;&gt;Linux命令手册&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://carbon.now.sh/&quot;&gt;carbon代码图片生成器&lt;/a&gt; 生成好看的代码图片&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;设计&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://chuangzaoshi.com/&quot;&gt;创造师导航&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://hao.uisdc.com/&quot;&gt;设计师网址导航&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.remove.bg/zh&quot;&gt;remove&lt;/a&gt; AI抠图，抠图算法很厉害&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.manypixels.co/gallery/&quot;&gt;Manypixels&lt;/a&gt; 插画&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://undraw.co/illustrations&quot;&gt;Undraw&lt;/a&gt; 插画&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://storytale.io/&quot;&gt;storytale&lt;/a&gt; 插画，种类丰富，包含3D插画&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://uimovement.com/&quot;&gt;uimovement&lt;/a&gt; 能从这个网站找到不少动画交互的灵感&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.awwwards.com/&quot;&gt;awwwards&lt;/a&gt;是一个一个专门为设计精美的网站以及富有创意的网站颁奖的网站&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://dribbble.com/&quot;&gt;dribbble&lt;/a&gt; 经常能在上面找到很多有创意好看的 gif 或者图片&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.behance.net/&quot;&gt;Bēhance&lt;/a&gt; dribbble 是设计师的微博，Bēhance 是设计师的博客&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://logojoy.com/&quot;&gt;Logojoy&lt;/a&gt; 使用 ai 做 logo 的网站，做出来的 logo 质量还不错。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://brandmark.io/&quot;&gt;brandmark&lt;/a&gt; 另一个在线制作 logo 网站&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://instantlogodesign.com/&quot;&gt;instant&lt;/a&gt; 又一个 logo 制作网站&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.namecheap.com/logo-maker/app/&quot;&gt;namecheap&lt;/a&gt;又一个 logo 制作网站&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.designevo.com/logo-maker/&quot;&gt;logo-maker&lt;/a&gt; 又一个 logo 制作网站 这个更简单点 就是选模板之后微调&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://coolors.co/&quot;&gt;coolors&lt;/a&gt; 帮你在线配色的网站 你能找到不少配色灵感&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://colorhunt.co/&quot;&gt;colorhunt&lt;/a&gt; 另一个配色网站&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://uigradients.com/#SummerDog&quot;&gt;uigradients&lt;/a&gt; 渐变色网站&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.designcap.com/&quot;&gt;designcap&lt;/a&gt; 在线海报设计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://flatuicolors.com/&quot;&gt;Flat UI 色表&lt;/a&gt; Flat UI 色表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.0to255.com/&quot;&gt;0to255&lt;/a&gt; 颜色梯度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/mikolajdobrucki/ikonate&quot;&gt;Ikonate&lt;/a&gt; 提供免费的图标 icons&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://remixicon.com/&quot;&gt;remixicon&lt;/a&gt; 又一个提供免费图标 icons&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/feathericons/feather&quot;&gt;feather&lt;/a&gt; 免费的 icons&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/arcticicestudio/nord&quot;&gt;nord&lt;/a&gt; 北欧性冷淡风主题配色&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://unsplash.com/&quot;&gt;Unsplash&lt;/a&gt; 提供免费的高清图片&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.pexels.com/zh-cn/&quot;&gt;Pexels&lt;/a&gt; 提供免费的高清图片&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://colorkitty.com/&quot;&gt;colorkitty&lt;/a&gt; 从你的图片中提取配色&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://design.youzan.com/&quot;&gt;design.youzan&lt;/a&gt; 有赞设计原则&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.iconfont.cn/&quot;&gt;iconfont&lt;/a&gt; 阿里巴巴矢量图标库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://undraw.co/illustrations&quot;&gt;undraw&lt;/a&gt; 免费的矢量插画&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://icomoon.io/&quot;&gt;icomoon&lt;/a&gt; 矢量图标库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://cssicon.space/#/&quot;&gt;cssicon&lt;/a&gt; 所有的 icon 都是纯 css 画的 缺点：icon 不够多&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://apps.eky.hk/css-triangle-generator/&quot;&gt;CSS triangle generator&lt;/a&gt; 帮你快速用 css 做出三角形&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://bennettfeely.com/clippy/&quot;&gt;clippy&lt;/a&gt; 在线帮你使用 css clip-path 做出各种形状的图形&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://picsum.photos/&quot;&gt;Lorem Picsum&lt;/a&gt; 提供免费的占位图&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.canva.cn/&quot;&gt;Canva 可画&lt;/a&gt; 生成插画、封面、海报、头像等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://error404.fun/&quot;&gt;404页&lt;/a&gt; 404页素材&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://collectui.com/&quot;&gt;collectui&lt;/a&gt; 按功能组件分类的设计图&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://smartmockups.com/zh&quot;&gt;smartmockups&lt;/a&gt; 产品模板生成工具&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;图库&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://uigradients.com/&quot;&gt;uigradients&lt;/a&gt; 渐变色生成工具&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.freepik.com/&quot;&gt;freepik&lt;/a&gt; banner 图库&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.51yuansu.com/&quot;&gt;觅元素&lt;/a&gt;一天免费下载十张 psd（免抠元素）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.gaoding.com/&quot;&gt;搞定设计&lt;/a&gt; 可以抠图&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.vectorizer.io/&quot;&gt;vectorizer&lt;/a&gt; 真正的 png 转 svg 神器&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.zcool.com.cn/&quot;&gt;站酷&lt;/a&gt; 国内优秀的设计作品展示&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://huaban.com/&quot;&gt;花瓣&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://huke88.com/&quot;&gt;虎克&lt;/a&gt; ps 学习教程&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://themes.muffingroup.com/be/splash/&quot;&gt;beTheme&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ui.cn/&quot;&gt;UI 中国&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://alpha.wallhaven.cc/&quot;&gt;wallhaven&lt;/a&gt; 壁纸网站-&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://colorsite.librian.net/&quot;&gt;色圖網站&lt;/a&gt; 來不及解釋了，快上車&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;3D&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://sketchfab.com/&quot;&gt;sketchfab&lt;/a&gt; 3D模型&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;交互&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://aliscued.lofter.com/&quot;&gt;微交互&lt;/a&gt; 里面收集了市面上很多很好的微交互例子 值得学习&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://littlebigdetails.com/&quot;&gt;Little Big Details&lt;/a&gt; 同上，一个国外微交互汇集网站&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://cruip.com/&quot;&gt;cruip&lt;/a&gt; 登录页的各种页面设计，可以免费下载模板&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://comixify.ii.pw.edu.pl/&quot;&gt;Comixify&lt;/a&gt; 一个波兰团队做了非常好玩的工具，可以把视频自动转成漫画，上图是他们提供的 demo，效果很棒。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/bui/taiko-web&quot;&gt;taiko-web&lt;/a&gt; 太鼓达人网页版 只能说很 6&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;有趣&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://pranx.com/&quot;&gt;电脑恶搞&lt;/a&gt; 收集了一些恶搞小网页，比如xp系统蓝屏、黑客界面等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://neocities.org/browse&quot;&gt;neocities&lt;/a&gt; 上面托管了很多有趣的网站&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://fuun.fun/&quot;&gt;奇趣网站收藏家&lt;/a&gt; 收藏了很多有趣的网站&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://game.xugaoyi.com/&quot;&gt;FC在线模拟器(小霸王游戏机)&lt;/a&gt; 童年回忆&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://www.baidu-x.com/&quot;&gt;帮你百度一下&lt;/a&gt; 可以 &lt;a href=&quot;http://www.baidu-x.com/?q=%E5%92%8C%E8%B0%90%E6%9C%89%E7%88%B1%E5%AF%8C%E5%BC%BA&quot;&gt;点我测试一下&lt;/a&gt;-&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://lmgtfy.com/&quot;&gt;国际版&lt;/a&gt; 同&lt;code&gt;帮我百度一下&lt;/code&gt;-&lt;a href=&quot;http://lmgtfy.com/?q=a&quot;&gt;点我测试一下&lt;/a&gt;-&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://matthewrayfield.com/articles/animating-urls-with-javascript-and-emojis/#%F0%9F%8C%96&quot;&gt;URL 地址播放 Emojis 动画&lt;/a&gt; 在地址栏里面播放 emoji&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://cantunsee.space/&quot;&gt;Can&apos;t Unsee&lt;/a&gt; 强烈建议前端、客户端、UI 开发的同学玩下，检查一下自己对设计稿的敏感度怎么样&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://talk.swift.gg/&quot;&gt;ggtalk&lt;/a&gt; 平时一直在听的一个技术博客&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/Blankj/awesome-comment&quot;&gt;awesome-comment&lt;/a&gt; 里面收集了很多有趣的代码注释&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.text-image.com/index.html&quot;&gt;text-img&lt;/a&gt; 都将图片转化为 ascii 用来写注释&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://pessimistress.github.io/ascii/&quot;&gt;ascii video&lt;/a&gt; 使用ascii编码生成视频动画&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/beizhedenglong/weird-fonts&quot;&gt;weird-fonts&lt;/a&gt; 将普通字母转化为 特殊 unicode&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/epidemian/snake&quot;&gt;snake&lt;/a&gt; 在地址栏里面玩贪吃蛇&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/yuanfux/zero-width-lib&quot;&gt;zero-width-lib&lt;/a&gt; 利用零宽度字符实现 隐形水印、加密信息分享、逃脱词匹配，很有创意&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.abbreviations.com/&quot;&gt;abbreviations&lt;/a&gt; 查看一个简写是什么意思的网站&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://magi.com/&quot;&gt;magi&lt;/a&gt; ai 搜索神器，超屌&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.qmsjmfb.com/&quot;&gt;在线取名&lt;/a&gt; 解决取名难问题，超多名字生成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://collet66.web.fc2.com/nijisanji/index.html&quot;&gt;像素画GIF&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://uchinoko-maker.jp/&quot;&gt;猫咪生成器&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;生成器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://toonme.com/&quot;&gt;卡通头像生成器&lt;/a&gt; 上传真人头像生成卡通头像&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.artbreeder.com/&quot;&gt;artbreeder&lt;/a&gt; 动漫图生成真人图像&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://neal.fun/ambient-chaos/&quot;&gt;声音生成器&lt;/a&gt; 生成下雨、咖啡厅、海浪、火车等声音，可几种声音合成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://zzkia.noddl.me:8020/&quot;&gt;诺基亚短信图片生成器&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://zfb.xugaoyi.com/&quot;&gt;到账语音生成器&lt;/a&gt; 支付宝到账1亿元&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;元宇宙&lt;/h2&gt;
&lt;p&gt;符合元宇宙特征的几个网站，允许用户拥有虚拟土地，在上面构建自己的世界：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.sandbox.game/cn/&quot;&gt;沙盒&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://somniumspace.com/&quot;&gt;梦境空间&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://market.decentraland.org/&quot;&gt;Decentraland&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;教程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://egghead.io/courses/execute-npm-package-binaries-with-the-npx-package-runner&quot;&gt;npx&lt;/a&gt; 教你怎么合理的使用 npx&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.hacksplaining.com/lessons&quot;&gt;hacksplaining&lt;/a&gt; 网络安全学习网站&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/mcuking/mobile-web-best-practice&quot;&gt;mobile-web-best-practice&lt;/a&gt; 移动 web 最佳实践&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;产品&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.producthunt.com/&quot;&gt;Product Hunt&lt;/a&gt; 好产品推荐&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://www.pmdaniu.com/&quot;&gt;产品大牛&lt;/a&gt; 什么有很多完整的产品原型可以借鉴&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://modao.cc/pricing&quot;&gt;磨刀&lt;/a&gt; 快速出 ui 原型&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;实用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://webden.dev/&quot;&gt;webden&lt;/a&gt; 在线网页编辑器，轻便快捷&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://browser-update.org/&quot;&gt;browser-update&lt;/a&gt; 浏览器版本更新提示插件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://admin.typeform.com/signup&quot;&gt;typeform&lt;/a&gt; 一个国外的在线调查问卷网站&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.videofk.com/&quot;&gt;VideoFk&lt;/a&gt; VideoFk 视频在线解析下载&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.allhistory.com/&quot;&gt;全历史&lt;/a&gt; 历史内容聚合网站&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.uzer.me/&quot;&gt;UzerMe&lt;/a&gt; 云端办公工具&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://sobooks.cc/&quot;&gt;SoBooks&lt;/a&gt; 强大的电子书资源网站&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.gaoding.com/&quot;&gt;稿定设计&lt;/a&gt; 键式设计工具+智能抠图&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://dalipan.com/&quot;&gt;大力盘&lt;/a&gt; 百度网盘搜索&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.macbl.com/app/internet/enfi&quot;&gt;ENFI 下载器&lt;/a&gt; 不限速下载器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.laihua.com/&quot;&gt;来画视频&lt;/a&gt; 像做 PPT 一样做短视频&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.arkie.cn/&quot;&gt;Arkie 海报制作工具&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://www.ypppt.com/&quot;&gt;优品 PPT&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://www.tretars.com/&quot;&gt;比格 PPT&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.pexels.com/&quot;&gt;高清免费图片&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://unsplash.com/&quot;&gt;高清免费图片 2&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.shapedivider.app/&quot;&gt;shapedivider&lt;/a&gt; 生成波浪分隔线&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://www.notion.so/&quot;&gt;Notion&lt;/a&gt; 知识库、快速笔记、TaskList、日记、读书清单，各种类型，应有尽有&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Talk&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/peerigon/talks&quot;&gt;peerigon-talks&lt;/a&gt; 收集了不少有意思的 talks&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/azl397985856/leetcode&quot;&gt;leetcode&lt;/a&gt; 用 js 刷 leetcode&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;nginx&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.digitalocean.com/community/tools/nginx?global.app.lang=zhCN&quot;&gt;nginx 可视化配置工具&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;生活&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.ventusky.com/&quot;&gt;Ventusky&lt;/a&gt; 风雨气温图&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item><item><title>提高学习效率的策略</title><link>https://newpower.pro/posts/notebook/%E6%8F%90%E9%AB%98%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87%E7%9A%84%E7%AD%96%E7%95%A5/</link><guid isPermaLink="true">https://newpower.pro/posts/notebook/%E6%8F%90%E9%AB%98%E5%AD%A6%E4%B9%A0%E6%95%88%E7%8E%87%E7%9A%84%E7%AD%96%E7%95%A5/</guid><pubDate>Tue, 04 Jan 2022 11:54:14 GMT</pubDate><content:encoded>&lt;p&gt;推荐一本关于学习方法的书《认知天性》，里面有讲到有一些简单实用的学习策略，能让大家学的更好、记得更牢，而且这些策略人人可用，时时可用。这些方法包括各种形式的&lt;strong&gt;检索练习&lt;/strong&gt;——例如小的测试和自测，&lt;strong&gt;间隔练习&lt;/strong&gt;、&lt;strong&gt;穿插&lt;/strong&gt;不同但相关科目或技能的练习（&lt;strong&gt;多样化练习&lt;/strong&gt;），在别人教给你解决方案前自己先试着解决问题，从不同类型问题中提取基本原理和规则。由于学习是反复的过程，需要复习早先学过的东西，持续更新已知，并把它们和新知识联系起来。&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- more --&amp;gt;&lt;/p&gt;
&lt;h3&gt;检索式学习&lt;/h3&gt;
&lt;p&gt;练习从记忆中检索新知识或新技能是有效的学习工具，也是保持长久记忆的有力武器。但凡需要大脑记忆、需要在将来回忆的东西，都可以用到它——对于事实、复杂的概念、解决问题的技巧、运动技能来说都适用。&lt;/p&gt;
&lt;p&gt;那么到底什么是检索式学习呢？说说我理解的检索式学习：在脑中检索知识，比如课后的一个小测试、对某个知识点用笔默写出来，甚至去参加面试，等等，都可以理解为检索式学习。&lt;/p&gt;
&lt;p&gt;努力检索有助于人们获得更好的学习效果，产生更持久的记忆。我们很容易相信，学东西时越轻松，学习效果越好，但研究表明，事实恰恰相反。只有当头脑被迫工作时，才会将所学的东西记得更牢靠。在检索时所付出的努力越大——只要真正做到这一点检索就会更好地强化你的所学。在第一次检测后，推迟后续检索练习要比立即练习更能强化记忆，因为延迟后再检索需要会费更大力气。&lt;/p&gt;
&lt;p&gt;反复检索不仅能让记忆更持久，还能让知识在更多变的环境中更容易被检索，而且可以解决更多的问题。&lt;/p&gt;
&lt;h3&gt;频繁的集中练习只会产生短期记忆&lt;/h3&gt;
&lt;p&gt;人们顽固地相信，自己把心思放在一件事上，拼命重复就能学得更好，认为这些观点经受住了时间的考验，而且“练习，练习，再练习”的明显收效再次证明了这种方法的好处。但是，科学家们把习得技能阶段的这种成绩称为“暂时的优势”，并把它同“潜在的习惯优势”区分开来。形成习惯优势有种种技巧，例如有间隔的练习、有穿插内容的练习，以及多样化练习，这些技巧恰恰会放缓有明显成果的学习进程，它们不会在练习中提高我们的表现。我们从表面上看不到成绩提高，也就没有付出努力的动力（大多数人的学习心理就是这样，在看不到成果的时候容易失去动力）。填鸭式练习是集中练习的一种形式，它一直被比作贪食症——吃得不少，但没过多久基本上都吐出来了。&lt;/p&gt;
&lt;h3&gt;间隔练习使知识存储更牢固&lt;/h3&gt;
&lt;p&gt;把学习与练习间隔开来分期进行，让两者之间隔上一定时间，这样做就能让学习成果更加显著、记忆更加牢固，能有效地形成习惯优势。&lt;strong&gt;间隔多长时间才够？答案很简单：从最低限度上说，间隔的时间足够出现一点儿遗忘就对了&lt;/strong&gt;。练习环节中间出现一点儿遗忘是好事，只要它能让人更加努力地练习就行。话说回来，你肯定不愿意忘掉太多东西，以至于检索最终变成了对资料的重新学习。间隔一段时间再练习能巩固记忆。睡眠似乎在巩固记忆的工作中扮演了重要角色，所以在两次练习间至少间隔一天应该是不错的做法。
要当心熟悉这个陷阱：你感觉自己明白了某样东西，觉得不再需要练习了。如果想走捷径，这种熟悉会让你在自测时受伤。道格拉斯·拉尔森说：“你必须自觉地说，好吧，我要强迫自己把这些全想起来，要是我想不起来，那我是忘掉了什么，我怎，么会不知道那个呢?’如果是教师出题测验，那就一下子变成你&lt;/p&gt;
&lt;h3&gt;穿插练习有助于长期记忆&lt;/h3&gt;
&lt;p&gt;穿插练习两样或更多的内容同样也提供了一种间隔。穿插内容练习有助于发展人们辨识不同问题的能力，也是在培养人们从不断增加的解决方案中寻找合适工具的能力。进行穿插内容练习，不能是完成一个科目的全部练习再跳到下一个科目。你需要在每个科目的练习完成前就跳到下一个科目。我们的一个朋友这样描述自己的经历，“我去上了一堂冰球课，学习滑冰、控球、射门。滑冰练习还没进行多长时间，自己刚刚有点儿上手的感觉，教练就转到控球练习上了，这让我感到非常沮丧。灰心地到家后，我说，‘为什么教练不让我们一次把技能练好呢？”其实他是遇上了少有的好教练。这位教练懂得分散精力练习不同技能要比下力气一次掌握一件事更有效果。球员感到沮丧是因为并没有在短时间内看到成果，但到下一周，无论是滑冰、控球，还是其他内容，他都会获得全面进步，效果会好于每次只专心练习一项技能。&lt;/p&gt;
&lt;h3&gt;多样化练习促进知识的活学活用&lt;/h3&gt;
&lt;p&gt;与穿插内容练习一样，多样化练习有助于学习者树立更开阔的心理模式。这是一种能力，掌握它的人可以评估不断变化的条件，并调整应对方式进行适应。可以说，穿插内容练习与多样化练习有助于学习者超越暂时性记忆，步入更高层次的概念性学习，并把它们应用到实际情景中，从而获得更全面、更深刻、更持久的学习效果。这些学习成果在运动技能中就表现为潜在的习惯优势。&lt;/p&gt;
&lt;h3&gt;小总结&lt;/h3&gt;
&lt;p&gt;有间隔、有内容穿插出现，以及内容多样化，其实就是我们生活的本来面貌。程序员每开发一个项目，都是一次测验，也是一次检索练习的锻炼。每次常规的拦车检查对于警察来说都是一次测验，而且每次检查都不一样，这会加强警察的外显记忆与内隐记忆。只要他上心，今后的工作就会更有效率。人们常说的一句话是“从经验中学习”。有些人似乎从来不学习，学与不学的一个区别可能就在于，人们是否培养了反思（总结）的习惯。反思（总结）是检索练习的一种形式（发生了什么？我是怎么做的？怎样才能有用？），而且辅以细化加强（下次我要采取别的什么方法？）&lt;/p&gt;
&lt;h3&gt;知识的“滚雪球”效应&lt;/h3&gt;
&lt;p&gt;学习的过程至少可以分成三步：最开始是对短期工作记忆中信息的&lt;strong&gt;编码&lt;/strong&gt;。这时信息还没有被巩固成长期记忆中坚实的知识表征。&lt;strong&gt;巩固&lt;/strong&gt;会辨识并稳定记忆线索，赋予其含义，把它们与过去的经验以及长期记忆中已经存储下来的其他知识联系起来。&lt;strong&gt;检索&lt;/strong&gt;会更新所学的东西，并让你做到学以致用。&lt;/p&gt;
&lt;p&gt;学习总是建立在已知基础之上。我们是通过与已知建立联系这种方式来解读事件和记忆事件的。&lt;/p&gt;
&lt;p&gt;长期记忆的容量基本上是无限的。你知道得越多，就越有可能为新知识建立联系。&lt;/p&gt;
&lt;p&gt;由于长期记忆的容量颇大，所以关键是要有一种能力，让你在需要的时候锁定并回忆已知。回忆所学知识的难易程度取决于对信息的重复使用（保持检索路径不会被忘却），也取决于你是否建立起了强大的检索线索，因为它能重新激活你的记忆。&lt;/p&gt;
&lt;p&gt;阶段性地检索所学，有助于强化记忆间的联系，也能强化回忆知识的线索，同时还能弱化连通冲突记忆的路径。检索练习若是没什么难度，那就不能强化所学的知识；练习难度越大，收效才越大。&lt;/p&gt;
&lt;p&gt;当你从短期记忆中回忆所学时，例如快速频繁地进行练习，是不需要花什么心思的，也不会有长期性的收效。但当你过一段时间再回忆时，当你对所学的东西有些遗忘时，你就不得不努力重建这一切。这种耗费心力的检索既能强化记忆，又能让所学再次具有可塑性，引发对所学知识的再巩固。再巩固可以用新信息更新你的记忆，同时可以将它们与最近学到的东西联系起来。&lt;/p&gt;
&lt;p&gt;重复进行费力的回忆或是练习，有助于把所学的知识整合成心智模型。在心智模型中，一套彼此相关的概念或一系列运动技能被融会贯通，形成一个有意义的整体。它能适应随后的各种环境，并发挥作用。开车时的感知和操控就是一个例子。在面对弧线球时知道如何打出全垒打也是同一个道理。&lt;/p&gt;
&lt;p&gt;练习的条件如果发生了变化，或是在检索中穿插安排了对其他资料的练习，我们就能强化自己的辨析与归纳能力，凭借全面发展，我们还能把所学的知识用在以后的新环境中。穿插与多样化建立了新的联系，拓展并进一步深化了记忆中的知识，同时增加了检索线索的数量。、&lt;/p&gt;
&lt;p&gt;试着自己想出答案，而不是坐等别人给你答案，或是在拿到解决方案前自行尝试解决一个问题，会产生更好的学习效果，也能让你把正确的答案或解决方案记得更持久。即便有时你会犯错，只要有纠正性反馈就没问题。&lt;/p&gt;
&lt;p&gt;——以上内容摘自《认知天性》，结合本人的个人理解，更多内容请查看该书籍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200103144032.png&quot; alt=&quot;认知天性&quot; title=&quot;认知天性&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>npm常用命令</title><link>https://newpower.pro/posts/document/npm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link><guid isPermaLink="true">https://newpower.pro/posts/document/npm%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid><pubDate>Sat, 25 Dec 2021 14:27:01 GMT</pubDate><content:encoded>&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;npm是跟随node一起安装的包（模块）管理器。常见的使用场景有以下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;允许用户从npm服务器下载别人编写的第三方包到本地使用。&lt;/li&gt;
&lt;li&gt;允许用户从npm服务器下载并安装别人编写的命令行程序到本地使用。&lt;/li&gt;
&lt;li&gt;允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lt;!-- more --&amp;gt;&lt;/p&gt;
&lt;h2&gt;常用命令&lt;/h2&gt;
&lt;h4&gt;检测是否安装及版本&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;npm -v # 显示版本号说明已经安装相应的版本
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;生成package.json文件&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;npm init
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;package.json用来描述项目中用到的模块和其他信息&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;安装模块&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;npm install # 安装package.json定义好的模块，简写 npm i

# 安装包指定模块
npm i &amp;lt;ModuleName&amp;gt;

# 全局安装
npm i &amp;lt;ModuleName&amp;gt; -g 

# 安装包的同时，将信息写入到package.json中的 dependencies 配置中
npm i &amp;lt;ModuleName&amp;gt; --save

# 安装包的同时，将信息写入到package.json中的 devDependencies 配置中
npm i &amp;lt;ModuleName&amp;gt; --save-dev

# 安装多模块
npm i &amp;lt;ModuleName1&amp;gt; &amp;lt;ModuleName2&amp;gt;

# 安装方式参数：
-save # 简写-S，加入到生产依赖中
-save-dev # 简写-D，加入到开发依赖中
-g # 全局安装 将安装包放在 /usr/local 下或者你 node 的安装目录
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;查看&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 查看所有全局安装的包
npm ls -g

# 查看本地项目中安装的包
npm ls

# 查看包的 package.json文件
npm view &amp;lt;ModuleName&amp;gt;

# 查看包的依赖关系
npm view &amp;lt;ModuleName&amp;gt; dependencies

# 查看包的源文件地址
npm view &amp;lt;ModuleName&amp;gt; repository.url

# 查看包所依赖的node版本
npm view &amp;lt;ModuleName&amp;gt; engines

# 查看帮助
npm help
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;更新模块&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 更新本地模块
npm update &amp;lt;ModuleName&amp;gt;

# 更新全局模块
npm update -g &amp;lt;ModuleName&amp;gt; # 更新全局软件包。
npm update -g # 更新所有的全局软件包。
npm outdated -g --depth=0 # 找出需要更新的包。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;卸载模块&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 卸载本地模块
npm uninstall &amp;lt;ModuleName&amp;gt;

# 卸载全局模块
npm uninstall -g &amp;lt;ModuleName&amp;gt; # 卸载全局软件包。
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;清空缓存&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 清空npm缓存
npm cache clear
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;使用淘宝镜像&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 使用淘宝镜像
npm install -g cnpm --registry=https://registry.npm.taobao.org
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;其他&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 更改包内容后进行重建
npm rebuild &amp;lt;ModuleName&amp;gt;

# 检查包是否已经过时，此命令会列出所有已经过时的包，可以及时进行包的更新
npm outdated

# 访问npm的json文件，此命令将会打开一个网页
npm help json

# 发布一个包的时候，需要检验某个包名是否存在
npm search &amp;lt;ModuleName&amp;gt;

# 撤销自己发布过的某个版本代码
npm unpublish &amp;lt;package&amp;gt; &amp;lt;version&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;使用技巧&lt;/h2&gt;
&lt;h4&gt;多次安装不成功尝试先清除缓存&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;npm cache clean -f
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;查看已安装的依赖包版本号&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;npm ls &amp;lt;ModuleName&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;注意：用此方法才能准确的知道项目使用的版本号，查看package.json时，有“^&quot; 符号表示大于此版本&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;npm发布包教程&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000017461666&quot;&gt;npm发布包教程&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;nrm的作用与使用&lt;/h2&gt;
&lt;h4&gt;nrm是什么？&lt;/h4&gt;
&lt;p&gt;nrm(npm registry manager )是npm的镜像源管理工具，有时候国外资源太慢，使用这个就可以快速地在 npm 源间切换&lt;/p&gt;
&lt;h4&gt;nrm的安装&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;npm install -g nrm
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;nrm命令&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;nrm ls　#查看可用的源（有*号的表示当前所使用的源,以下&amp;lt;registry&amp;gt;表示源的名称）
nrm use &amp;lt;registry&amp;gt; # 将npm下载源切换成指定的源
nrm add &amp;lt;registry&amp;gt; &amp;lt;url&amp;gt; # 添加源，url为源的路径
nrm del &amp;lt;registry&amp;gt; # 删除源
nrm test &amp;lt;registry&amp;gt; # 测试源的响应时间，可以作为使用哪个源的参考

nrm help　# 查看nrm帮助
nrm home &amp;lt;registry&amp;gt;　# 跳转到指定源的官网
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;nrm使用&lt;/h4&gt;
&lt;p&gt;如果在你的网络不太理想或者受到其他网络限制导致不能使用npm原本的源进行下载时，nrm就非常有用了，你只需要：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;nrm ls # 查看可用的源
nrm use &amp;lt;registry&amp;gt;　# 切换到指定源
&lt;/code&gt;&lt;/pre&gt;
</content:encoded></item><item><title>Git使用手册</title><link>https://newpower.pro/posts/document/git%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</link><guid isPermaLink="true">https://newpower.pro/posts/document/git%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</guid><pubDate>Sat, 25 Dec 2021 14:27:01 GMT</pubDate><content:encoded>&lt;h2&gt;安装&lt;/h2&gt;
&lt;p&gt;官网下载：&lt;a href=&quot;https://git-scm.com/downloads&quot;&gt;https://git-scm.com/downloads&lt;/a&gt; 下载完成后使用默认进行安装。&lt;/p&gt;
&lt;p&gt;安装完成后，在开始菜单里找到 &lt;code&gt;Git&lt;/code&gt; -&amp;gt; &lt;code&gt;Git Bash&lt;/code&gt;，蹦出一个类似命令行窗口的东西，就说明Git安装成功！
还需要最后一步设置，在命令行输入：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git config --global user.name &quot;Your Name&quot;
git config --global user.email &quot;email@example.com&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。&lt;/p&gt;
&lt;p&gt;&amp;lt;!-- more --&amp;gt;&lt;/p&gt;
&lt;h2&gt;创建版本库（仓库）&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;# 创建仓库
mkdir &amp;lt;仓库name&amp;gt; 

# 进入仓库
cd &amp;lt;仓库name&amp;gt;

# 此命令用于显示当前目录
pwd

# 把当前目录初始化成Git仓库
git init
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录直接&lt;code&gt;git init&lt;/code&gt;也是可以的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;添加文件到仓库&lt;/h2&gt;
&lt;p&gt;在仓库目录下放入文件，如新建一个&lt;code&gt;test.txt&lt;/code&gt;文件，然后使用&lt;code&gt;git add test.txt&lt;/code&gt;命令告诉Git，把文件添加到缓存区，然后使用&lt;code&gt;git commit -m &quot;提交描述&quot;&lt;/code&gt;告诉Git，把文件提交到仓库。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 添加指定文件或文件夹到缓存区，文件需添加后缀
git add &amp;lt;文件或文件夹name&amp;gt;                   # 单个文件
git add &amp;lt;文件或文件夹name&amp;gt; &amp;lt;文件或文件夹name&amp;gt;  # 多个文件

# 或 全部文件同时添加到缓存区
git add .

# 把文件从缓存区提交至仓库
git commit -m &quot;提交描述&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;提交描述规范&lt;/h4&gt;
&lt;p&gt;在提交代码时输入清晰的说明有利于版本管理，建议搭配如下关键字编写提交描述&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 新建(add)
# 删除(rm)
# 更新(update)
# 改动(change)
# 实现
# 发布
# 修复
...
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;版本管理&lt;/h2&gt;
&lt;h4&gt;提交修改&lt;/h4&gt;
&lt;p&gt;如修改&lt;code&gt;test.txt&lt;/code&gt;的内容后，运行&lt;code&gt;git status&lt;/code&gt;命令看看被修改的文件，然后再使用&lt;code&gt;git add test.txt&lt;/code&gt;、
&lt;code&gt;git commit -m &quot;修改描述&quot;&lt;/code&gt;把修改后的文件提交到仓库，提交后可再次使用&lt;code&gt;git status&lt;/code&gt;查看当前状态。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 显示 新增/删除/被改动等 的文件
git status
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;查看版本记录&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 查看版本记录
git log   # 显示版本号、提交时间等信息
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;也可使用可视化工具查看Git版本历史：
在仓库目录右键 &amp;gt; &lt;code&gt;Git BUI Here&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;回退版本&lt;/h4&gt;
&lt;p&gt;首先，Git必须知道当前版本是哪个版本，在Git中，用&lt;code&gt;HEAD&lt;/code&gt;表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是&lt;code&gt;HEAD^&lt;/code&gt;，上上一个版本就是&lt;code&gt;HEAD^^&lt;/code&gt;，当然往上100个版本写100个^比较容易数不过来，所以写成&lt;code&gt;HEAD~100&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 回退到上一个版本
$ git reset --hard HEAD^
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此时查看&lt;code&gt;git log&lt;/code&gt;记录发现，原来最新的版本已经没有了，想回到原来最新的版本怎么办？这就需要知道最新的版本的版本号&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 跳转到指定版本
git reset --hard &amp;lt;版本号前几位&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是不知道版本号怎么办？Git提供了一个命令&lt;code&gt;git reflog&lt;/code&gt;用来记录你的每一次命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git reflog
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;撤销修改&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/896043488029600/897889638509536&quot;&gt;https://www.liaoxuefeng.com/wiki/896043488029600/897889638509536&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;删除文件&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/896043488029600/900002180232448&quot;&gt;https://www.liaoxuefeng.com/wiki/896043488029600/900002180232448&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;远程仓库&lt;/h2&gt;
&lt;h4&gt;SSH验证&lt;/h4&gt;
&lt;p&gt;使本机能关联远程仓库，首次需要SSH验证&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第1步：创建&lt;code&gt;SSH Key&lt;/code&gt;。在用户主（C:\Users\dell）目录下，看看有没有.ssh目录，
如果有，再看看这个目录下有没有&lt;code&gt;id_rsa&lt;/code&gt;和&lt;code&gt;id_rsa.pub&lt;/code&gt;这两个文件，如果已经有了，可直接跳到下一步。
如果没有，打开Shell（Windows下打开Git Bash），创建&lt;code&gt;SSH Key&lt;/code&gt;：&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# 创建SSH Key
ssh-keygen -t rsa -C &quot;邮件地址&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;第2步：登陆GitHub，右上角头像 &amp;gt; settings &amp;gt; SSH and GPG keys &amp;gt;Add SSH Key，在key的文本框里粘贴&lt;code&gt;id_rsa.pub&lt;/code&gt;文件的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;关联远程仓库&lt;/h4&gt;
&lt;p&gt;SSH验证完成后，在github创建仓库，创建仓库时记得取消 &lt;code&gt;Initialize this repository with a README&lt;/code&gt;的勾选，然后在本地命令：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 关联远程仓库，仓库名一般使用origin
git remote add &amp;lt;仓库名&amp;gt; &amp;lt;远程仓库地址&amp;gt;

# 示例
git remote add origin git@github.com:xugaoyi/test.git
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下一步，就可以把本地库的所有内容推送到远程库上&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 把文件推送到远程仓库
git push -u &amp;lt;仓库名&amp;gt; &amp;lt;分支名&amp;gt;

# 示例
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;由于远程库是空的，我们第一次推送&lt;code&gt;master&lt;/code&gt;分支时，加上了&lt;code&gt;-u&lt;/code&gt;参数，Git不但会把本地的&lt;code&gt;master&lt;/code&gt;分支内容推送的远程新的&lt;code&gt;master&lt;/code&gt;分支，还会把本地的&lt;code&gt;master&lt;/code&gt;分支和远程的&lt;code&gt;master&lt;/code&gt;分支关联起来，在以后的推送或者拉取时就可以简化命令。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;前提是目录已经&lt;code&gt;git init&lt;/code&gt;初始化成仓库，并且&lt;code&gt;git status&lt;/code&gt;状态是没有改动的，如果有改动则先&lt;code&gt;git add .&lt;/code&gt;添加至缓存区，&lt;code&gt;git commit -m &apos;提交描述&apos;&lt;/code&gt;提交至仓库，然后执行上面命令。&lt;/p&gt;
&lt;p&gt;如创建仓库时勾选了 &lt;code&gt;Initialize this repository with a README&lt;/code&gt; 则需先拉取&lt;code&gt;README.md&lt;/code&gt;文件到本地仓库&lt;code&gt;git pull&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;可关联多个远程仓库，注意给不同的远程仓库取不一样的名称，提交是分别按名称提交到不一样的远程仓库。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;# 简化的推送命令
git push
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;查看远程仓库&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 查看远程仓库
git remote -v
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;删除远程仓库&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 删除远程仓库
git remote rm &amp;lt;仓库名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;从远程库克隆项目&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 从远程库克隆项目
git clone &amp;lt;仓库地址&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;克隆指定分支&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;# 克隆指定分支
git clone -b &amp;lt;分支名&amp;gt; &amp;lt;仓库地址&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;分支管理&lt;/h2&gt;
&lt;h4&gt;创建分支&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 创建分支
git checkout -b &amp;lt;分支名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;查看分支&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 查看分支
git branch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看分支时，在分支前带 * 号的表示当前的分支&lt;/p&gt;
&lt;h4&gt;切换分支&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 切换分支
git checkout &amp;lt;分支名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;合并分支&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 合并本地的分支
git merge &amp;lt;分支名&amp;gt;

# 合并远程的分支
git merge &amp;lt;远程仓库名&amp;gt;/&amp;lt;分支名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;，是将指定分支合并到当前分支，并非当前分支合并到指定分支。&lt;/p&gt;
&lt;p&gt;一般情况下是把当前分支切换到&lt;strong&gt;主分支&lt;/strong&gt;，然后把&lt;strong&gt;子分支&lt;/strong&gt;合并到&lt;strong&gt;主分支&lt;/strong&gt;。&lt;/p&gt;
&lt;h4&gt;删除分支&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 删除分支
git branch -d &amp;lt;分支名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;修改分支名&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;# 修改分支名
git branch -m &amp;lt;原分支名&amp;gt; &amp;lt;新分支名&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;帮助命令&lt;/h2&gt;
&lt;p&gt;如对命令不清楚时，可使用&lt;code&gt;git help&lt;/code&gt;命令显示出git命令介绍。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;# 帮助命令
git help
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;$ git help
usage: git [--version] [--help] [-C &amp;lt;path&amp;gt;] [-c &amp;lt;name&amp;gt;=&amp;lt;value&amp;gt;]
           [--exec-path[=&amp;lt;path&amp;gt;]] [--html-path] [--man-path] [--info-path]
           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]
           [--git-dir=&amp;lt;path&amp;gt;] [--work-tree=&amp;lt;path&amp;gt;] [--namespace=&amp;lt;name&amp;gt;]
           &amp;lt;command&amp;gt; [&amp;lt;args&amp;gt;]

These are common Git commands used in various situations:

start a working area (see also: git help tutorial)
   clone      Clone a repository into a new directory
   init       Create an empty Git repository or reinitialize an existing one

work on the current change (see also: git help everyday)
   add        Add file contents to the index
   mv         Move or rename a file, a directory, or a symlink
   reset      Reset current HEAD to the specified state
   rm         Remove files from the working tree and from the index

examine the history and state (see also: git help revisions)
   bisect     Use binary search to find the commit that introduced a bug
   grep       Print lines matching a pattern
   log        Show commit logs
   show       Show various types of objects
   status     Show the working tree status

grow, mark and tweak your common history
   branch     List, create, or delete branches
   checkout   Switch branches or restore working tree files
   commit     Record changes to the repository
   diff       Show changes between commits, commit and working tree, etc
   merge      Join two or more development histories together
   rebase     Reapply commits on top of another base tip
   tag        Create, list, delete or verify a tag object signed with GPG

collaborate (see also: git help workflows)
   fetch      Download objects and refs from another repository
   pull       Fetch from and integrate with another repository or a local branch
   push       Update remote refs along with associated objects

&apos;git help -a&apos; and &apos;git help -g&apos; list available subcommands and some
concept guides. See &apos;git help &amp;lt;command&amp;gt;&apos; or &apos;git help &amp;lt;concept&amp;gt;&apos;
to read about a specific subcommand or concept.
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;翻译工具翻译中文&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ git help
使用：git [--version] [--help] [-C &amp;lt;path&amp;gt;] [-c &amp;lt;name&amp;gt;=&amp;lt;value&amp;gt;]
           [--exec-path[=&amp;lt;path&amp;gt;]] [--html-path] [--man-path] [--info-path]
           [-p | --paginate | -P | --no-pager] [--no-replace-objects] [--bare]
           [--git-dir=&amp;lt;path&amp;gt;] [--work-tree=&amp;lt;path&amp;gt;] [--namespace=&amp;lt;name&amp;gt;]
           &amp;lt;command&amp;gt; [&amp;lt;args&amp;gt;]

这些是在各种情况下使用的通用Git命令：

start a working area (参见命令: git help tutorial)
   clone      将存储库克隆到新目录中
   init       创建一个空的Git存储库或重新初始化一个现有的存储库

work on the current change (参见命令: git help everyday)
   add        将文件内容添加到索引中
   mv         移动或重命名文件、目录或符号链接
   reset      将当前磁头重置为指定状态
   rm         从工作树和索引中删除文件

examine the history and state (参见命令: git help revisions)
   bisect     使用二分查找查找引入错误的提交
   grep       打印与模式匹配的行
   log        显示提交日志
   show       显示各种类型的对象
   status     显示工作树状态

grow, mark and tweak your common history
   branch     列出、创建或删除分支
   checkout   切换分支或还原工作树文件
   commit     记录对存储库的更改
   diff       显示提交、提交和工作树等之间的更改
   merge      将两个或多个开发历史连接在一起
   rebase     在另一个基本提示之上重新应用提交
   tag        创建、列表、删除或验证用GPG签名的标记对象

collaborate (参见命令: git help workflows)
   fetch      从另一个存储库下载对象和引用
   pull       从另一个存储库或本地分支获取并与之集成
   push       更新远程引用和相关对象

&apos;git help -a&apos; 和 &apos;git help -g&apos; 列出可用的子命令和一些概念指导。
命令&apos;git help &amp;lt;command&amp;gt;&apos; 或 &apos;git help &amp;lt;concept&amp;gt;&apos; 查看特定子命令或概念.
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;参考文档&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/896043488029600&quot;&gt;https://www.liaoxuefeng.com/wiki/896043488029600&lt;/a&gt;&lt;/p&gt;
</content:encoded></item><item><title>笔记方法</title><link>https://newpower.pro/posts/notebook/%E7%AC%94%E8%AE%B0%E6%96%B9%E6%B3%95/</link><guid isPermaLink="true">https://newpower.pro/posts/notebook/%E7%AC%94%E8%AE%B0%E6%96%B9%E6%B3%95/</guid><pubDate>Fri, 16 Jul 2021 11:00:55 GMT</pubDate><content:encoded>&lt;h2&gt;康奈尔笔记法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200716105752.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;思维导图法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200716105747.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;金三角笔记法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200716105753.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;曼陀罗九宫格笔记法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200716105748.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;记号记录法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200716105749.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;六色笔记法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200716105750.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;加工笔记法&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200716105751.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;整理笔记要点1-科学标记重点&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200716105746.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;整理笔记要点2-修改不涂改&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://jsd.cdn.zzko.cn/gh/xugaoyi/image_store/blog/20200716105745.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded></item><item><title>处理问题的思路</title><link>https://newpower.pro/posts/notebook/%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF/</link><guid isPermaLink="true">https://newpower.pro/posts/notebook/%E5%A4%84%E7%90%86%E9%97%AE%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF/</guid><pubDate>Sun, 03 Jan 2021 14:36:02 GMT</pubDate><content:encoded>&lt;h2&gt;工作中遇到问题？&lt;/h2&gt;
&lt;p&gt;遇到问题卡住了，可以先休息一会儿，调整一下状态，喝杯水走走放松放松，然后想想有没有遗漏的地方，或者其他的解决方案呢&lt;/p&gt;
&lt;h2&gt;这个问题我该怎么解决呢？&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;学会搜索&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;关键词&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多关键词&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加入时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加入特定的社区&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;site用法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;高阶搜索方法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;英文搜索（必应搜索、google搜索，很多英文文档或文章相对来说层数结构很清晰）&lt;/li&gt;
&lt;li&gt;视频站搜索（&lt;a href=&quot;http://www.youtube.com/&quot;&gt;http://www.youtube.com/&lt;/a&gt;、&lt;a href=&quot;http://egghead.io&quot;&gt;http://egghead.io&lt;/a&gt;）&lt;/li&gt;
&lt;li&gt;百度盘搜索&lt;/li&gt;
&lt;li&gt;指定文件后缀&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;寻求帮助&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;找同学&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找同事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;找朋友&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://xugaoyi.com/pages/2e9ba3fa6e1ed0e9/#%E7%A4%BE%E5%8C%BA%E7%B1%BB&quot;&gt;找社区&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;开拓思路——发散性解决问题&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;去问问原作者？&lt;/li&gt;
&lt;li&gt;去发个邮件/twitter/facebook?&lt;/li&gt;
&lt;li&gt;去找Boss要资源？&lt;/li&gt;
&lt;li&gt;加入公共社区参与讨论?&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
</content:encoded></item><item><title>自律小建议</title><link>https://newpower.pro/posts/notebook/%E8%87%AA%E5%BE%8B%E5%B0%8F%E5%BB%BA%E8%AE%AE/</link><guid isPermaLink="true">https://newpower.pro/posts/notebook/%E8%87%AA%E5%BE%8B%E5%B0%8F%E5%BB%BA%E8%AE%AE/</guid><pubDate>Sun, 03 Jan 2021 14:35:18 GMT</pubDate><content:encoded>&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;培养专注&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;练习冥想、瑜伽等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;排除外界干扰&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;手机调到勿扰，在图书馆学习等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lt;!-- more --&amp;gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;规定学习时间&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/%E7%95%AA%E8%8C%84%E5%B7%A5%E4%BD%9C%E6%B3%95/6353502?fr=aladdin&quot;&gt;&lt;strong&gt;番茄时间管理&lt;/strong&gt;&lt;/a&gt;——使用番茄时间管理法，选择一个待完成的任务，将番茄时间设为25分钟，专注工作，中途不允许做任何与该任务无关的事，直到番茄时钟响起，然后短暂休息一下（5分钟就行），每4个番茄时段多休息一会儿。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;人的大脑在记忆一个东西的时候，有短期记忆和长期记忆之分。大脑编码内容进行长期记忆，需要一个过程的，可能是几个小时或几天，集中练习就给不了这个过程，所以集中练习带来的效果是短期记忆，而进行间隔练习，大脑则有时间进行充分的编码，学习到的知识就会储存为长期记忆。&lt;/p&gt;
&lt;p&gt;推荐几种间歇锻炼方法：体能训练、课间操、眼保操、拉伸训练...&lt;/p&gt;
&lt;p&gt;有好的身体可以使大脑更清醒哟~&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;限制娱乐时间&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;减少使用娱乐app的时间（苹果手机可设定屏幕使用时间）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;推荐观看&amp;gt;&lt;a href=&quot;https://www.bilibili.com/video/av47180907&quot;&gt;B站某位UP主的视频《每天只看半小时手机，坚持一周后我有哪些变化？》&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;戒网瘾（特别是游戏）&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;除了手机、游戏以外，周围有很多美好的事物值得我们去关注。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;设定目标&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;想要更好的薪水和职位？多花点时间在学习上吧~&lt;/li&gt;
&lt;li&gt;潜意识暗示自己，建立信心，让自己变得更优秀，然后去挑战更高的目标&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;优秀的人仍在不断努力&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;且看大神 &lt;a href=&quot;https://github.com/ruanyf&quot;&gt;阮一峰github&lt;/a&gt; 提交记录&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</content:encoded></item></channel></rss>